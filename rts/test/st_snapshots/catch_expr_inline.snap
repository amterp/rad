### TITLE ###
Catch inline
### INPUT ###
a = foo() catch 0
b = 2 + bar() catch 0
c = foo() catch bar() catch 0
d = foo() catch null ?? "default"
### STDOUT ###
B: [  0, 103] PS: [0,  0] PE: [3, 33] source_file
B: [  0,  17] PS: [0,  0] PE: [0, 17]   assign
B: [  0,   1] PS: [0,  0] PE: [0,  1]     left: var_path
B: [  0,   1] PS: [0,  0] PE: [0,  1]       root: identifier `a`
B: [  2,   3] PS: [0,  2] PE: [0,  3]     = `=`
B: [  4,  17] PS: [0,  4] PE: [0, 17]     right: expr
B: [  4,  17] PS: [0,  4] PE: [0, 17]       delegate: ternary_expr
B: [  4,  17] PS: [0,  4] PE: [0, 17]         delegate: or_expr
B: [  4,  17] PS: [0,  4] PE: [0, 17]           delegate: and_expr
B: [  4,  17] PS: [0,  4] PE: [0, 17]             delegate: compare_expr
B: [  4,  17] PS: [0,  4] PE: [0, 17]               delegate: add_expr
B: [  4,  17] PS: [0,  4] PE: [0, 17]                 delegate: mult_expr
B: [  4,  17] PS: [0,  4] PE: [0, 17]                   delegate: unary_expr
B: [  4,  17] PS: [0,  4] PE: [0, 17]                     delegate: fallback_expr
B: [  4,  17] PS: [0,  4] PE: [0, 17]                       delegate: catch_expr
B: [  4,   9] PS: [0,  4] PE: [0,  9]                         left: catch_expr
B: [  4,   9] PS: [0,  4] PE: [0,  9]                           delegate: indexed_expr
B: [  4,   9] PS: [0,  4] PE: [0,  9]                             root: primary_expr
B: [  4,   9] PS: [0,  4] PE: [0,  9]                               call
B: [  4,   7] PS: [0,  4] PE: [0,  7]                                 func: identifier `foo`
B: [  7,   8] PS: [0,  7] PE: [0,  8]                                 ( `(`
B: [  8,   9] PS: [0,  8] PE: [0,  9]                                 ) `)`
B: [ 10,  15] PS: [0, 10] PE: [0, 15]                         catch `catch`
B: [ 16,  17] PS: [0, 16] PE: [0, 17]                         right: indexed_expr
B: [ 16,  17] PS: [0, 16] PE: [0, 17]                           root: primary_expr
B: [ 16,  17] PS: [0, 16] PE: [0, 17]                             literal
B: [ 16,  17] PS: [0, 16] PE: [0, 17]                               int `0`
B: [ 18,  39] PS: [1,  0] PE: [1, 21]   assign
B: [ 18,  19] PS: [1,  0] PE: [1,  1]     left: var_path
B: [ 18,  19] PS: [1,  0] PE: [1,  1]       root: identifier `b`
B: [ 20,  21] PS: [1,  2] PE: [1,  3]     = `=`
B: [ 22,  39] PS: [1,  4] PE: [1, 21]     right: expr
B: [ 22,  39] PS: [1,  4] PE: [1, 21]       delegate: ternary_expr
B: [ 22,  39] PS: [1,  4] PE: [1, 21]         delegate: or_expr
B: [ 22,  39] PS: [1,  4] PE: [1, 21]           delegate: and_expr
B: [ 22,  39] PS: [1,  4] PE: [1, 21]             delegate: compare_expr
B: [ 22,  39] PS: [1,  4] PE: [1, 21]               delegate: add_expr
B: [ 22,  23] PS: [1,  4] PE: [1,  5]                 left: add_expr
B: [ 22,  23] PS: [1,  4] PE: [1,  5]                   delegate: mult_expr
B: [ 22,  23] PS: [1,  4] PE: [1,  5]                     delegate: unary_expr
B: [ 22,  23] PS: [1,  4] PE: [1,  5]                       delegate: fallback_expr
B: [ 22,  23] PS: [1,  4] PE: [1,  5]                         delegate: catch_expr
B: [ 22,  23] PS: [1,  4] PE: [1,  5]                           delegate: indexed_expr
B: [ 22,  23] PS: [1,  4] PE: [1,  5]                             root: primary_expr
B: [ 22,  23] PS: [1,  4] PE: [1,  5]                               literal
B: [ 22,  23] PS: [1,  4] PE: [1,  5]                                 int `2`
B: [ 24,  25] PS: [1,  6] PE: [1,  7]                 op: + `+`
B: [ 26,  39] PS: [1,  8] PE: [1, 21]                 right: mult_expr
B: [ 26,  39] PS: [1,  8] PE: [1, 21]                   delegate: unary_expr
B: [ 26,  39] PS: [1,  8] PE: [1, 21]                     delegate: fallback_expr
B: [ 26,  39] PS: [1,  8] PE: [1, 21]                       delegate: catch_expr
B: [ 26,  31] PS: [1,  8] PE: [1, 13]                         left: catch_expr
B: [ 26,  31] PS: [1,  8] PE: [1, 13]                           delegate: indexed_expr
B: [ 26,  31] PS: [1,  8] PE: [1, 13]                             root: primary_expr
B: [ 26,  31] PS: [1,  8] PE: [1, 13]                               call
B: [ 26,  29] PS: [1,  8] PE: [1, 11]                                 func: identifier `bar`
B: [ 29,  30] PS: [1, 11] PE: [1, 12]                                 ( `(`
B: [ 30,  31] PS: [1, 12] PE: [1, 13]                                 ) `)`
B: [ 32,  37] PS: [1, 14] PE: [1, 19]                         catch `catch`
B: [ 38,  39] PS: [1, 20] PE: [1, 21]                         right: indexed_expr
B: [ 38,  39] PS: [1, 20] PE: [1, 21]                           root: primary_expr
B: [ 38,  39] PS: [1, 20] PE: [1, 21]                             literal
B: [ 38,  39] PS: [1, 20] PE: [1, 21]                               int `0`
B: [ 40,  69] PS: [2,  0] PE: [2, 29]   assign
B: [ 40,  41] PS: [2,  0] PE: [2,  1]     left: var_path
B: [ 40,  41] PS: [2,  0] PE: [2,  1]       root: identifier `c`
B: [ 42,  43] PS: [2,  2] PE: [2,  3]     = `=`
B: [ 44,  69] PS: [2,  4] PE: [2, 29]     right: expr
B: [ 44,  69] PS: [2,  4] PE: [2, 29]       delegate: ternary_expr
B: [ 44,  69] PS: [2,  4] PE: [2, 29]         delegate: or_expr
B: [ 44,  69] PS: [2,  4] PE: [2, 29]           delegate: and_expr
B: [ 44,  69] PS: [2,  4] PE: [2, 29]             delegate: compare_expr
B: [ 44,  69] PS: [2,  4] PE: [2, 29]               delegate: add_expr
B: [ 44,  69] PS: [2,  4] PE: [2, 29]                 delegate: mult_expr
B: [ 44,  69] PS: [2,  4] PE: [2, 29]                   delegate: unary_expr
B: [ 44,  69] PS: [2,  4] PE: [2, 29]                     delegate: fallback_expr
B: [ 44,  69] PS: [2,  4] PE: [2, 29]                       delegate: catch_expr
B: [ 44,  61] PS: [2,  4] PE: [2, 21]                         left: catch_expr
B: [ 44,  49] PS: [2,  4] PE: [2,  9]                           left: catch_expr
B: [ 44,  49] PS: [2,  4] PE: [2,  9]                             delegate: indexed_expr
B: [ 44,  49] PS: [2,  4] PE: [2,  9]                               root: primary_expr
B: [ 44,  49] PS: [2,  4] PE: [2,  9]                                 call
B: [ 44,  47] PS: [2,  4] PE: [2,  7]                                   func: identifier `foo`
B: [ 47,  48] PS: [2,  7] PE: [2,  8]                                   ( `(`
B: [ 48,  49] PS: [2,  8] PE: [2,  9]                                   ) `)`
B: [ 50,  55] PS: [2, 10] PE: [2, 15]                           catch `catch`
B: [ 56,  61] PS: [2, 16] PE: [2, 21]                           right: indexed_expr
B: [ 56,  61] PS: [2, 16] PE: [2, 21]                             root: primary_expr
B: [ 56,  61] PS: [2, 16] PE: [2, 21]                               call
B: [ 56,  59] PS: [2, 16] PE: [2, 19]                                 func: identifier `bar`
B: [ 59,  60] PS: [2, 19] PE: [2, 20]                                 ( `(`
B: [ 60,  61] PS: [2, 20] PE: [2, 21]                                 ) `)`
B: [ 62,  67] PS: [2, 22] PE: [2, 27]                         catch `catch`
B: [ 68,  69] PS: [2, 28] PE: [2, 29]                         right: indexed_expr
B: [ 68,  69] PS: [2, 28] PE: [2, 29]                           root: primary_expr
B: [ 68,  69] PS: [2, 28] PE: [2, 29]                             literal
B: [ 68,  69] PS: [2, 28] PE: [2, 29]                               int `0`
B: [ 70, 103] PS: [3,  0] PE: [3, 33]   assign
B: [ 70,  71] PS: [3,  0] PE: [3,  1]     left: var_path
B: [ 70,  71] PS: [3,  0] PE: [3,  1]       root: identifier `d`
B: [ 72,  73] PS: [3,  2] PE: [3,  3]     = `=`
B: [ 74, 103] PS: [3,  4] PE: [3, 33]     right: expr
B: [ 74, 103] PS: [3,  4] PE: [3, 33]       delegate: ternary_expr
B: [ 74, 103] PS: [3,  4] PE: [3, 33]         delegate: or_expr
B: [ 74, 103] PS: [3,  4] PE: [3, 33]           delegate: and_expr
B: [ 74, 103] PS: [3,  4] PE: [3, 33]             delegate: compare_expr
B: [ 74, 103] PS: [3,  4] PE: [3, 33]               delegate: add_expr
B: [ 74, 103] PS: [3,  4] PE: [3, 33]                 delegate: mult_expr
B: [ 74, 103] PS: [3,  4] PE: [3, 33]                   delegate: unary_expr
B: [ 74, 103] PS: [3,  4] PE: [3, 33]                     delegate: fallback_expr
B: [ 74,  90] PS: [3,  4] PE: [3, 20]                       left: fallback_expr
B: [ 74,  90] PS: [3,  4] PE: [3, 20]                         delegate: catch_expr
B: [ 74,  79] PS: [3,  4] PE: [3,  9]                           left: catch_expr
B: [ 74,  79] PS: [3,  4] PE: [3,  9]                             delegate: indexed_expr
B: [ 74,  79] PS: [3,  4] PE: [3,  9]                               root: primary_expr
B: [ 74,  79] PS: [3,  4] PE: [3,  9]                                 call
B: [ 74,  77] PS: [3,  4] PE: [3,  7]                                   func: identifier `foo`
B: [ 77,  78] PS: [3,  7] PE: [3,  8]                                   ( `(`
B: [ 78,  79] PS: [3,  8] PE: [3,  9]                                   ) `)`
B: [ 80,  85] PS: [3, 10] PE: [3, 15]                           catch `catch`
B: [ 86,  90] PS: [3, 16] PE: [3, 20]                           right: indexed_expr
B: [ 86,  90] PS: [3, 16] PE: [3, 20]                             root: primary_expr
B: [ 86,  90] PS: [3, 16] PE: [3, 20]                               literal
B: [ 86,  90] PS: [3, 16] PE: [3, 20]                                 null `null`
B: [ 91,  93] PS: [3, 21] PE: [3, 23]                       op: ?? `??`
B: [ 94, 103] PS: [3, 24] PE: [3, 33]                       right: catch_expr
B: [ 94, 103] PS: [3, 24] PE: [3, 33]                         delegate: indexed_expr
B: [ 94, 103] PS: [3, 24] PE: [3, 33]                           root: primary_expr
B: [ 94, 103] PS: [3, 24] PE: [3, 33]                             literal
B: [ 94, 103] PS: [3, 24] PE: [3, 33]                               string
B: [ 94,  95] PS: [3, 24] PE: [3, 25]                                 start: string_start `"`
B: [ 95, 102] PS: [3, 25] PE: [3, 32]                                 contents: string_contents
B: [ 95, 102] PS: [3, 25] PE: [3, 32]                                   content: string_content `default`
B: [102, 103] PS: [3, 32] PE: [3, 33]                                 end: string_end `"`

### STDERR ###
PS: [0,  0] PE: [3, 33] SourceFile
PS: [0,  0] PE: [0, 17]   Assign
PS: [0,  0] PE: [0,  1]     Identifier "a"
PS: [0,  4] PE: [0, 17]     CatchExpr
PS: [0,  4] PE: [0,  9]       Call
PS: [0,  4] PE: [0,  7]         Identifier "foo"
PS: [0, 16] PE: [0, 17]       LitInt 0
PS: [1,  0] PE: [1, 21]   Assign
PS: [1,  0] PE: [1,  1]     Identifier "b"
PS: [1,  4] PE: [1, 21]     OpBinary +
PS: [1,  4] PE: [1,  5]       LitInt 2
PS: [1,  8] PE: [1, 21]       CatchExpr
PS: [1,  8] PE: [1, 13]         Call
PS: [1,  8] PE: [1, 11]           Identifier "bar"
PS: [1, 20] PE: [1, 21]         LitInt 0
PS: [2,  0] PE: [2, 29]   Assign
PS: [2,  0] PE: [2,  1]     Identifier "c"
PS: [2,  4] PE: [2, 29]     CatchExpr
PS: [2,  4] PE: [2, 21]       CatchExpr
PS: [2,  4] PE: [2,  9]         Call
PS: [2,  4] PE: [2,  7]           Identifier "foo"
PS: [2, 16] PE: [2, 21]         Call
PS: [2, 16] PE: [2, 19]           Identifier "bar"
PS: [2, 28] PE: [2, 29]       LitInt 0
PS: [3,  0] PE: [3, 33]   Assign
PS: [3,  0] PE: [3,  1]     Identifier "d"
PS: [3,  4] PE: [3, 33]     Fallback
PS: [3,  4] PE: [3, 20]       CatchExpr
PS: [3,  4] PE: [3,  9]         Call
PS: [3,  4] PE: [3,  7]           Identifier "foo"
PS: [3, 16] PE: [3, 20]         LitNull
PS: [3, 24] PE: [3, 33]       LitString "default"

