#!/usr/bin/env rad
---
Facilitates developing rad.
---
args:
    release r int?    # 1 to bump patch, 2 for minor and 3 for major.
    docs d bool       # Enable to deploy docs.
    amend a bool      # Enable to amend the last commit with the version bump instead of creating a new commit.
    push p bool       # Enable to push local commits.
    build b bool      # Enable to build.
    validate v bool   # Enable to build & test.
    dumps bool        # Enable to run the dump tests.
    test t bool       # Enable to run tests once.
    bump bool         # Enable to bump all dependency versions in go.mod.

    release range [1, 3]

get_branch = fn():
    _, branch  = $!`echo -n $(git branch --show-current)`
    return branch

if bump:
    print("Bumping all dependency versions in go.mod...")
    $!`go get -u=patch ./...`
    $!`go mod tidy`
    print(green("✅ Dependencies updated!"))
    validate = true

if build:
    $!`make build`

if test:
    $!`make test`

if release or push or validate:
    $!`go mod tidy`
    $!`make all`
    //$!`golines -w . -m 120`

if dumps or validate:
    $!`cd ./rts/test/dumps && ./test_dumps.rad`

if docs:
    $!`mkdocs gh-deploy -f ./docs-web/mkdocs.yml --strict`

if release:
    branch = get_branch()
    if branch != "main":
        print("{"ERROR".red()}: You can only release from the {"main".green()} branch; you're on {branch.yellow()}")
        exit(1)

    // check for replace directives in go.mod
    no_replace_directives = unsafe $`grep "^replace " go.mod`
    if not no_replace_directives:
        print("{"ERROR".red()}: go.mod contains replace directives which should not be present in releases:")
        print("Please remove all replace directives before releasing.".yellow())
        exit(1)

    // resolve version /////////////
    _, tags = $!`git tag -l`
    tags = split(tags[:-1], "\n")
    tags = [replace(t, "v", "") for t in tags]
    tags = [split(t, "\.") for t in tags]
    major = sort([parse_int(t[0]) for t in tags])[-1]
    minor = sort([parse_int(t[1]) for t in tags if parse_int(t[0]) == major])[-1]
    patch = sort([parse_int(t[2]) for t in tags if parse_int(t[0]) == major and parse_int(t[1]) == minor])[-1]
    if release == 1:
        version = "v{major}.{minor}.{patch + 1}"
    else if release == 2:
        version = "v{major}.{minor + 1}.0"
    else if release == 3:
        version = "v{major + 1}.0.0"
    print("Bumping to version:", green(version))
    ///////////////////////////////

    $!`go test ./core/testing -count 10`

    dirty = unsafe $`git status --porcelain`
    if dirty:
        print("Working directory is dirty! Aborting.".red())
        exit(1)

    $!`sed -i '' "s/Version = \".*\"/Version = \"{version}\"/" ./core/version.go`

    $!`git add ./core/version.go`

    if confirm("Commit, tag & push? ({version}) [y/n] > "):
        if amend:
            $!`git commit --amend --no-edit`
        else:
            $!`git commit -m "Bump version to {version}"`

        $!`git tag {version}`

        pushup()

        print("✅ Tag {version} created and pushed. GitHub Actions will create the release with binaries.")

if push:
    pushup()

fn pushup():
    branch = get_branch()
    $!`git push origin {branch} --tags`

print(green("✅ Done!"))
