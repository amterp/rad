{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Rad","text":""},{"location":"#new","title":"New?","text":"<p>Check out the Getting Started guide!</p>"},{"location":"#reference","title":"Reference","text":"<p>See 'Reference' in the side panel.</p> <p>These docs are still a work in progress!</p> <p>These docs are actively being worked on, and there are critical sections missing.</p> <p>Rad is also evolving, and so some docs here may be out of date. If you have any questions at all, don't hesitate to ask on Discussions!</p> <p>The Guide is pretty substantial and gives you quite a lot to go on, feel free to check it out!</p>"},{"location":"examples/brewi/","title":"brewi","text":""},{"location":"examples/brewi/#preview","title":"Preview","text":"<pre><code>#!/usr/bin/env rad\n---\nFacilitates checking a brew formula before installing it.\n---\nargs:\n    formula str    # Name of the formula to install.\n    cask c bool    # Enable if it's a cask.\n\n$`brew info {formula}`\nif confirm():\n    $`brew install{cask ? \" --cask\" : \"\"} {formula}`\n</code></pre> <pre><code>&gt; brewi -h\nFacilitates checking a brew formula before installing it.\n\nUsage:\n  brewi &lt;formula&gt; [cask]\n\nScript args:\n      --formula str      Name of the formula to install.\n  -c, --cask             Enable if it's a cask.\n</code></pre>"},{"location":"examples/brewi/#tutorial-building-brewi","title":"Tutorial: Building <code>brewi</code>","text":""},{"location":"examples/brewi/#motivation","title":"Motivation","text":"<p>I tend to run <code>brew info</code> before installing formulas just to double-check that I've got the right one. Most of the time, it is, so I follow that with a <code>brew install</code>.</p> <p>Rather than writing out these two commands manually each time, it'd be neat if I had an alias, which not only saved some characters, but did this workflow for me.</p>"},{"location":"examples/brewi/#writing-the-script","title":"Writing the script","text":"<p>We can use <code>rad</code> to create the script file for us.</p> <pre><code>rad new brewi -s\n</code></pre> <p>This will set us up with an executable script named <code>brewi</code>, and the <code>-s</code> simplifies the template it's instantiated with to contain just a shebang.</p> <p>The shebang will allow us to invoke the script as <code>brewi</code> from the CLI rather than writing out <code>rad ./brewi</code>. Open up <code>brewi</code> in your editor, and you should see something like this:</p> <pre><code>#!/usr/bin/env rad\n</code></pre> <p>Let's begin editing it. First, we want to quickly describe what the script is aiming to do, so we'll add a file header.</p> <pre><code>#!/usr/bin/env rad\n---\nFacilitates checking a brew formula before installing it.\n---\n</code></pre> <p>We want the script to accept a formula as an argument, i.e. the formula we may be installing. It'll be a string, so let's add this in an arg block. We'll include a little comment to improve our usage string.</p> <pre><code>#!/usr/bin/env rad\n---\nFacilitates checking a brew formula before installing it.\n---\nargs:\n    formula string # Name of the formula to install.\n</code></pre> <p><code>formula</code> will serve both as the variable name for the rest of the script, and be exposed to the user as the script's CLI API.</p> <p>Setup done. First thing we'll wanna do is run <code>brew info</code> with the formula. We'll do this via a shell command.</p> <p>Specifically, we'll use a critical shell command, because if the command fails (including if the formula just doesn't exist), we want to just print the error and exit the script.</p> <p>This uses the <code>$</code> syntax.</p> <pre><code>#!/usr/bin/env rad\n---\nFacilitates checking a brew formula before installing it.\n---\nargs:\n    formula string # Name of the formula to install.\n\n$`brew info {formula}`\n</code></pre> <p>We use string interpolation to insert the formula into the command.</p> <p>You can try running the command now! Make sure it's executable (<code>chmod +x ./brewi</code>).</p> <p>Next, we want to ask the user if they'd like to proceed with installing the formula. For that, Rad offers the <code>confirm</code> function. The default prompt is <code>Confirm? [y/n] &gt;</code>, which works fine for us here, so we'll do a simple 0-arg <code>confirm()</code> call. The function returns a bool for yes/no, so we'll put it in an if statement.</p> <pre><code>#!/usr/bin/env rad\n---\nFacilitates checking a brew formula before installing it.\n---\nargs:\n    formula string # Name of the formula to install.\n\n$`brew info {formula}`\nif confirm():\n    $`brew install {formula}`\n</code></pre> <p>Feel free to try it again now!</p> <p>One last touch: we should also allow installing casks with this script. We'll aim to offer a simple <code>-c</code> flag users can set which modifies the command. </p> <p>We'll add the <code>bool</code> arg, and insert an additional interpolation in our <code>brew install</code> command, leveraging Rad's ternary syntax. We need to pay close attention to whitespace so we make sure the command comes out correct in the cask and non-cask cases.</p> <pre><code>#!/usr/bin/env rad\n---\nFacilitates checking a brew formula before installing it.\n---\nargs:\n    formula string # Name of the formula to install.\n    cask c bool    # Enable if it's a cask.\n\n$`brew info {formula}`\nif confirm():\n    $`brew install{cask ? \" --cask\" : \"\"} {formula}`\n</code></pre> <p>Note the shorthand flag in <code>cask c bool</code>.</p> <p>Done! You've now got a great, convenient helper script for installing things with brew :)</p> <pre><code>&gt; brewi -h\nFacilitates checking a brew formula before installing it.\n\nUsage:\n  brewi &lt;formula&gt; [cask]\n\nScript args:\n      --formula string   Name of the formula to install.\n  -c, --cask             Enable if it's a cask.\n</code></pre> <p>If you'd like to see a more complex example next, check out hm.</p>"},{"location":"examples/hm/","title":"hm","text":"<p>TBC</p>"},{"location":"guide/AGENTS/","title":"Rad Guide","text":""},{"location":"guide/AGENTS/#secondary-goals","title":"Secondary goals","text":"<ul> <li>Examples</li> <li>Primary goal is to teach users the concepts in the guide, examples should serve that purpose</li> <li>Secondary goal is to use examples that inspire/motivate the user, and help them see how Rad can help them in the real world.</li> <li>Look for opportunities to sprinkle in useful built-in functions that we can teach the user, that aren't already being taught.</li> </ul>"},{"location":"guide/AGENTS/#tone","title":"Tone","text":"<p>Concise, friendly, approachable, empathetic, high-signal, personable, motivated.</p>"},{"location":"guide/CLAUDE/","title":"Rad Guide","text":""},{"location":"guide/CLAUDE/#secondary-goals","title":"Secondary goals","text":"<ul> <li>Examples</li> <li>Primary goal is to teach users the concepts in the guide, examples should serve that purpose</li> <li>Secondary goal is to use examples that inspire/motivate the user, and help them see how Rad can help them in the real world.</li> <li>Look for opportunities to sprinkle in useful built-in functions that we can teach the user, that aren't already being taught.</li> </ul>"},{"location":"guide/CLAUDE/#tone","title":"Tone","text":"<p>Concise, friendly, approachable, empathetic, high-signal, personable, motivated.</p>"},{"location":"guide/args/","title":"Args","text":"<p>This section covers syntax for declaring arguments that your script can accept.</p>"},{"location":"guide/args/#arg-declarations","title":"Arg Declarations","text":"<p>Rad takes a declarative approach to arguments. You simply declare what arguments your script accepts, you can define some constraints you want for them, and let Rad take care of the rest, including parsing user input and validation.</p> <p>Arguments are declared as part of an args block.</p> <p>Here's an example script we'll call <code>printwords</code> that prints an input word some number of times:</p> <pre><code>#!/usr/bin/env rad\nargs:\n    word str\n    repeats int\n\nfor _ in range(repeats):\n    print(word)\n</code></pre> <p>We can print its usage string using the <code>-h</code> flag:</p> <pre><code>./printwords -h\n</code></pre> <pre><code>Usage:\n  printwords &lt;word&gt; &lt;repeats&gt;\n\nScript args:\n      --word str\n      --repeats int\n</code></pre> <p>This script defines two mandatory arguments: <code>word</code> that is expected to be a string, and <code>repeats</code> which is expected to be an integer.</p> <p>Some important things to note:</p> <ul> <li>All arguments can be defined positionally or via a flag.</li> <li>The positional ordering of args follows the order of declaration in the block.</li> <li>Flags are automatically generated and can be used by users to pass values for that argument, instead of doing it positionally.</li> </ul> <p>Let's look at a more complex example to demonstrate some more features. Let's call it <code>wordjoin</code>.</p> <pre><code>#!/usr/bin/env rad\n---\nGiven some words, joins them together, and optionally capitalizes them.\n---\nargs:\n    words str[]                            # Words to join together.\n    joiner j str = \"-\"                     # Joiner for the words.\n    should_capitalize \"capitalize\" c bool  # If true, capitalize the words.\n\nif should_capitalize:\n    words = [upper(w) for w in words]\n\nprint(join(words, joiner))\n</code></pre> <p>If we run <code>-h</code> on this one:</p> <pre><code>./wordjoin -h\n</code></pre> <pre><code>Given some words, joins them together, and optionally capitalizes them.\n\nUsage:\n  wordjoin &lt;words&gt; [joiner] [OPTIONS]\n\nScript args:\n      --words strs   Words to join together.\n  -j, --joiner str   Joiner for the words. (default -)\n  -c, --capitalize   If true, capitalize the words.\n</code></pre> <p>Let's break down each declaration to see what's going on here.</p> <ol> <li> <p><code>words str[]  # Words to join together.</code></p> <ul> <li>We declare an arg <code>words</code> which is a list of strings. Note that <code>int[]</code>, <code>float[]</code> and <code>bool[]</code> can be used for int, float, and bool lists respectively.</li> <li>We also define an arg comment to make the usage string include a description of what the argument is.</li> </ul> </li> <li> <p><code>joiner j str = \"-\"  # Joiner for the words.</code></p> <ul> <li>We declare a second argument, this one a string called <code>joiner</code>. We also define a shorthand flag <code>j</code>, allowing users to specify the arg with a simple <code>-j</code> flag.</li> <li>After that, we define a default value <code>-</code> for this parameter that will be used if the user doesn't provide one. We finish with another arg comment.</li> </ul> </li> <li> <p><code>should_capitalize \"capitalize\" c bool  # If true, capitalize the words.</code></p> <ul> <li>We declare our final argument <code>should_capitalize</code>. We rename it with <code>\"capitalize\"</code>, which will be what users see exposed to them, instead of the initial variable name. <code>should_capitalize</code> will remain the name of the variable to be referenced throughout the script. We define a shorthand <code>c</code>, and specify the parameter is a <code>bool</code> before finally giving it an arg comment.</li> </ul> </li> </ol> <p>Bool args are always false by default.</p> <p>To bring it all together, this is the anatomy of an arg declaration (<code>&lt;angle brackets&gt;</code> mean it's required, <code>[square brackets]</code> indicate it's optional):</p> <p><code>&lt;name&gt; [rename] [shorthand flag] &lt;type&gt; [= default] [# arg comment]</code></p> <p>Feel free to go back up and check this against the example scripts we wrote, you'll see how each one fits this mold.</p>"},{"location":"guide/args/#argument-types-and-user-input","title":"Argument Types and User Input","text":"<p>This section explains the different argument types you can declare and how users pass values for each type.</p>"},{"location":"guide/args/#basic-types","title":"Basic Types","text":"<p>For basic types (<code>int</code>, <code>float</code>, <code>str</code>), users can pass values either positionally or via flags:</p> <pre><code>#!/usr/bin/env rad\nargs:\n    name str\n    age int\n    height float\n\nprint(\"{name} is {age} years old and {height}m tall\")\n</code></pre> <p>Both invocations work identically:</p> <pre><code>./script Alice 25 1.65\n./script --name Alice --age 25 --height 1.65\n./script Alice 25 --height 1.65\n</code></pre> <p>Type validation happens automatically. If a user provides <code>--age abc</code> when age is an <code>int</code>, Rad will show an error.</p>"},{"location":"guide/args/#bool-flags","title":"Bool Flags","text":"<p>Bool arguments are never positional - they must be passed via flags. You can set them either by presence or with an explicit value:</p> <pre><code>args:\n    verbose v bool\n    debug d bool\n\nprint(\"verbose: {verbose}, debug: {debug}\")\n</code></pre> <pre><code>./script --verbose           # verbose=true, debug=false\n./script -v                  # Same as above (short flag)\n./script -v -d               # Both true\n./script --verbose=true      # Explicit value\n./script --verbose=false     # Explicitly set to false\n</code></pre> <p>Bool args always default to <code>false</code> unless you give them a different default:</p> <pre><code>args:\n    verbose bool = true  # Defaults to true\n</code></pre>"},{"location":"guide/args/#list-types","title":"List Types","text":"<p>For list arguments (<code>str[]</code>, <code>int[]</code>, <code>float[]</code>, <code>bool[]</code>), users pass values by repeating the flag:</p> <pre><code>args:\n    files f str[]\n    counts int[]\n\nprint(\"files: {files}\")\nprint(\"counts: {counts}\")\n</code></pre> <pre><code>./script -f hello.txt -f world.txt --counts 1 --counts 2 --counts 3\n</code></pre> <pre><code>files: [ \"hello.txt\", \"world.txt\" ]\ncounts: [ 1, 2, 3 ]\n</code></pre> <p>Both long and short flags can be used interchangeably and repeated as needed.</p>"},{"location":"guide/args/#variadic-arguments","title":"Variadic Arguments","text":"<p>Variadic arguments use a <code>*</code> prefix and collect any number of positional values into a list:</p> <pre><code>args:\n    command str\n    *files str\n    verbose v bool\n\nprint(\"command: {command}\")\nprint(\"files: {files}\")\n</code></pre> <pre><code>./script build file1.txt file2.txt file3.txt --verbose\n</code></pre> <pre><code>command: build\nfiles: [ \"file1.txt\", \"file2.txt\", \"file3.txt\" ]\n</code></pre> <p>Variadic args can have defaults and work with any type (<code>*numbers int</code>, <code>*values float</code>, etc.):</p> <pre><code>args:\n    *items str = [\"default.txt\"]\n</code></pre> <p>You can have multiple variadic sections separated by flags - the flags act as delimiters:</p> <pre><code>args:\n    *section1 str\n    *section2 int\n    flag f bool\n\nprint(\"section1: {section1}\")\nprint(\"section2: {section2}\")\n</code></pre> <pre><code>./script a b c --flag 1 2 3\n</code></pre> <pre><code>section1: [ \"a\", \"b\", \"c\" ]\nsection2: [ 1, 2, 3 ]\n</code></pre>"},{"location":"guide/args/#optional-arguments","title":"Optional Arguments","text":"<p>Mark arguments as optional with <code>?</code> suffix. When not provided, their value is <code>null</code>:</p> <pre><code>args:\n    name str\n    role str?\n    year int?\n\nif role == null:\n    print(\"{name} has no role assigned\")\nelse:\n    print(\"{name} is a {role}\")\n</code></pre> <pre><code>./script Alice\n</code></pre> <pre><code>Alice has no role assigned\n</code></pre> <p>You can check for null values with <code>== null</code> or use truthy/falsy logic: <code>if role:</code> will be false when role is null.</p>"},{"location":"guide/args/#short-flag-clustering","title":"Short Flag Clustering","text":"<p>When you define short flags (single letters), users can cluster multiple bool flags together:</p> <pre><code>args:\n    verbose v bool\n    debug d bool\n    quiet q bool\n</code></pre> <pre><code>./script -vdq    # Same as: -v -d -q\n</code></pre> <p>All three flags are set to true with this single clustered argument.</p>"},{"location":"guide/args/#int-flag-counting","title":"Int Flag Counting","text":"<p>For <code>int</code> arguments with short flags, repeating the flag increments the count:</p> <pre><code>args:\n    verbosity v int\n</code></pre> <pre><code>./script -vvv           # verbosity = 3\n./script -vvvvv         # verbosity = 5\n</code></pre> <p>This is useful for verbosity levels. If an explicit value is provided, it overrides the counting:</p> <pre><code>./script -vvv=10        # verbosity = 10 (not 3)\n</code></pre>"},{"location":"guide/args/#constraints","title":"Constraints","text":"<p>In addition to declaring the arguments themselves, Rad also allows you to declare constraints on those arguments, such as what kinds of values are valid.</p> <p>By doing this in the args block, Rad can use this information to validate input for you, and automatically include the information in your script's usage string.</p> <p>If a user gives an input which doesn't meet one of the listed constraints, Rad will print:</p> <ol> <li> <p>The specific error and constraint that was violated.</p> </li> <li> <p>The usage string.</p> </li> </ol>"},{"location":"guide/args/#enums","title":"Enums","text":"<p>If you have a string argument where you really only want to accept some limited number of known values, you can use an enum constraint.</p> <p>Let's use a simple example, we'll call the script <code>colors</code>:</p> <pre><code>#!/usr/bin/env rad\nargs:\n    color str\n    color enum [\"red\", \"green\", \"blue\"]\nprint(\"You like {color}!\")\n</code></pre> <p>If we print the usage string, you can see it tells users what values are valid:</p> <pre><code>./colors -h\n</code></pre> <pre><code>Usage:\n  colors &lt;color&gt;\n\nScript args:\n      --color str    Valid values: [red, green, blue].\n</code></pre> <p>If we invoke this script with a value outside the listed valid values:</p> <pre><code>./colors yellow\n</code></pre> <pre><code>Invalid 'color' value: yellow (valid values: red, green, blue)\nUsage:\n  colors &lt;color&gt;\n\nScript args:\n      --color str    Valid values: [red, green, blue].\n</code></pre> <p>Whereas using a valid value will run the script as intended:</p> <pre><code>./colors green\n</code></pre> <pre><code>You like green!\n</code></pre>"},{"location":"guide/args/#range","title":"Range","text":"<p>For numeric arguments (<code>int</code> or <code>float</code>), you can enforce minimum and maximum values using a range constraint.</p> <p>Range constraints use <code>[</code> for inclusive bounds and <code>(</code> for exclusive bounds:</p> <pre><code>#!/usr/bin/env rad\nargs:\n    age int\n    temperature float\n\n    age range [0, 120]              // 0 to 120, both inclusive\n    temperature range (-50.0, 50.0) // Between -50 and 50, both exclusive\n</code></pre> <p>You can also specify only a floor or only a ceiling:</p> <pre><code>args:\n    count int\n    score float\n\n    count range [1,]      // Minimum of 1, no maximum\n    score range (,100.0]  // No minimum, maximum of 100 (inclusive)\n</code></pre> <p>Floor/Ceiling Syntax</p> <p>When specifying only a floor or ceiling, both <code>[0,]</code> and <code>[0,)</code> are equivalent (both mean \"minimum of 0, no maximum\"). The closing delimiter doesn't affect the meaning when the value is omitted.</p> <p>Let's look at a complete example with various range types:</p> File: validator<pre><code>#!/usr/bin/env rad\nargs:\n    age int              # Person's age\n    score float          # Test score\n    count int            # Item count\n\n    age range [0, 120]\n    score range (0, 100]\n    count range [1,]\n</code></pre> <p>The help text automatically shows the constraints:</p> <pre><code>./validator -h\n</code></pre> <pre><code>Usage:\n  validator &lt;age&gt; &lt;score&gt; &lt;count&gt; [OPTIONS]\n\nScript args:\n      --age int      Person's age. Range: [0, 120]\n      --score float  Test score. Range: (0, 100]\n      --count int    Item count. Range: [1, )\n</code></pre> <p>If a user provides an invalid value, they get a clear error:</p> <pre><code>./validator 150 50.0 5\n</code></pre> <pre><code>'age' value 150 is &gt; maximum 120\n\nUsage:\n  validator &lt;age&gt; &lt;score&gt; &lt;count&gt; [OPTIONS]\n\nScript args:\n      --age int      Person's age. Range: [0, 120]\n      --score float  Test score. Range: (0, 100]\n      --count int    Item count. Range: [1, )\n</code></pre> <p>When using exclusive bounds, values exactly at the boundary are rejected:</p> <pre><code>./validator 25 0 5   # score of 0 is invalid (exclusive minimum)\n</code></pre> <pre><code>'score' value 0 is &lt;= minimum (exclusive) 0\n</code></pre>"},{"location":"guide/args/#regex","title":"Regex","text":"<p>If you'd like input strings to match a certain pattern, you can do that via a regex constraint.</p> <pre><code>args:\n    name str\n    name regex \"[A-Z][a-z]*\"\nprint(\"Hi, {name}\")\n</code></pre> <p>In this example, a valid <code>name</code> value must start with a capital letter, and can then be followed by any number of lowercase letters. No other characters will be accepted, so <code>Alice</code> will be a valid value, but <code>bob</code> or <code>John123</code> are not.</p> <p>As with other constraints, Rad will validate input against this regex, and if it doesn't match, it will print an error. The constraint is also printed in the script's usage string.</p>"},{"location":"guide/args/#relational","title":"Relational","text":"<p>Relational constraints let you express logical relationships between your script's arguments. There are two types of constraints you can define:</p> <ul> <li><code>excludes</code> (arguments can't appear together)</li> <li><code>requires</code> (an argument depends on another argument also being provided)</li> </ul> <p>You can optionally precede these with the <code>mutually</code> keyword to indicate that the constraint applies in both directions.</p>"},{"location":"guide/args/#exclusion","title":"Exclusion","text":"<p>Use <code>excludes</code> to prevent arguments from being specified together. For example, consider a script that accepts either a file (<code>--file</code>) or a URL (<code>--url</code>), but not both:</p> File: fetcher<pre><code>#!/usr/bin/env rad\nargs:\n  file str\n  url str\n\n  file mutually excludes url\n\nif file:\n    print(\"Reading from file:\", file)\nelse:\n    print(\"Fetching from URL:\", url)\n</code></pre> <p>You can then provide either argument:</p> <pre><code>&gt; ./fetcher --file data.json\nReading from file: data.json\n\n&gt; ./fetcher --url https://example.com/data.json\nFetching from URL: https://example.com/data.json\n</code></pre> <p>If both are provided, Rad gives a clear error:</p> <pre><code>&gt; ./fetcher --file data.json --url https://example.com/data.json\nInvalid arguments: 'file' excludes 'url', but 'url' was given\n</code></pre> <p>Note in this example, that if e.g. <code>file</code> is provided, then <code>url</code> will be <code>null</code> (and vice versa).</p>"},{"location":"guide/args/#requirement","title":"Requirement","text":"<p>Use the <code>requires</code> keyword to indicate that, when one argument is defined, so must another argument.</p> <p>Consider a script that can authenticate either by using a token or by providing a username/password pair. </p> <p>If the user provides a username, the password is also required.</p> File: auth<pre><code>args:\n  token str\n  username str\n  password str\n\n  username mutually requires password\n  token mutually excludes username, password\n\nif token:\n    print(\"Authenticating with token {token}\")\nelse:\n    print(\"Authenticating user {username} with password length {len(password)}\")\n</code></pre> <p>Valid usage examples:</p> <pre><code>&gt; ./auth --token abc123\nAuthenticating with token abc123\n\n&gt; ./auth --username alice --password secret\nAuthenticating user alice with password length 6\n</code></pre> <p>Invalid usage examples:</p> <pre><code>&gt; ./auth --username alice\nInvalid arguments: 'username' requires 'password', but 'password' was not provided\n\n&gt; ./auth --token abc123 --password secret\nInvalid arguments: 'token' excludes 'password', but 'password' was given\n</code></pre>"},{"location":"guide/args/#summary","title":"Summary","text":"<ul> <li>Rad takes a declarative approach to args, and handles parsing user input.</li> <li>All args can be specified positionally or via a flag from the user.</li> <li> <p>Anatomy of an arg declaration:</p> <p><code>&lt;name&gt; [rename] [shorthand flag] &lt;type&gt; [= default] [# arg comment]</code></p> </li> <li> <p>Rad supports various argument types:</p> <ul> <li>Basic types: <code>int</code>, <code>float</code>, <code>str</code>, <code>bool</code></li> <li>List types: <code>str[]</code>, <code>int[]</code>, <code>float[]</code>, <code>bool[]</code> (passed via repeated flags)</li> <li>Variadic: <code>*args &lt;type&gt;</code> (collects remaining positional arguments)</li> <li>Optional: <code>&lt;type&gt;?</code> (value is <code>null</code> when not provided)</li> </ul> </li> <li>Short flags support clustering (<code>-vdq</code>) and counting for ints (<code>-vvv</code> = 3)</li> <li>You can apply constraints to arguments inside the arg block:<ul> <li><code>enum</code> for discrete values</li> <li><code>range</code> for numeric bounds (using <code>[</code> for inclusive, <code>(</code> for exclusive)</li> <li><code>regex</code> for pattern matching</li> <li>Relational constraints (<code>requires</code>, <code>excludes</code>)</li> </ul> </li> <li>Details in the arg block are used by Rad to provide a better usage/help string.</li> </ul>"},{"location":"guide/args/#next","title":"Next","text":"<p>Next, we'll look at another important concept in Rad: Functions.</p>"},{"location":"guide/basics/","title":"Basics","text":"<p>This section of the guide will rapidly cover the basics of Rad. Rad shares a lot of conventions and syntax with popular languages like Python, so if you're familiar with programming, this will be a breeze.</p>"},{"location":"guide/basics/#variables-assignment","title":"Variables &amp; Assignment","text":"<p>To create a variable, you can do it through assignment. Let's use a string example:</p> <pre><code>name = \"Alice\"\n</code></pre> <p>You can re-assign variables. Types don't need to stay the same:</p> <pre><code>name = \"Alice\"\nname = 2\n</code></pre>"},{"location":"guide/basics/#data-types","title":"Data Types","text":"<p>Rad has 6 basic types: strings, ints, floats, bools, lists, and maps.</p>"},{"location":"guide/basics/#str","title":"str","text":"<p>Strings can be delimited in three ways:</p> <ol> <li>Double quotes: <code>\"text\"</code></li> <li>Single quotes: <code>'text'</code></li> <li>Backticks: <code>`text`</code></li> </ol> <p>All three behave the same way. To demonstrate:</p> <pre><code>print(\"Hello!\")\nprint('Hello!')\nprint(`Hello!`)\n</code></pre> <pre><code>Hello!\nHello!\nHello!\n</code></pre> <p>Why 3 different delimiters?</p> <p>Having 3 different delimiters is particularly useful when you want your string to contain one (or more) of those delimiter characters.</p> <p>For example, if you want a double quote in your string, you can use double quote delimiters and escape them:</p> <pre><code>\"She said \\\"Goodbye\\\"\"\n</code></pre> <p>However, this can be finicky and hard to read. Instead, you can pick one of the other two delimiters, for example:</p> <pre><code>'She said \"Goodbye\"'\n`She said \"Goodbye\"`\n</code></pre> <p>We'll cover this again later, but as a note, backticks can be particularly useful in shell commands, as shell/bash commands may include single or double quotes, and backticks save us from having to escape them.</p> <p>Strings can include special characters such as <code>\\n</code> for new lines and <code>\\t</code> for tabs.</p> <pre><code>print(\"Hello\\tdear\\nreader!\")\n</code></pre> <pre><code>Hello   dear\nreader!\n</code></pre> <p>Strings also support interpolation. String interpolation allows you to write expressions inside your string that will be evaluated and replaced for the final string. We'll cover this in more depth in a future section, but to give a very simple example:</p> <pre><code>name = \"Alice\"\nprint(\"Hi, {name}!\")\n</code></pre> <pre><code>Hi, Alice!\n</code></pre> <p>Anything encapsulated in a <code>{}</code> gets treated as an expression. Here, the expression is just the identifier <code>name</code>, which gets evaluated and substituted, giving us the final <code>Hi, Alice!</code> string.</p> <p>Those are the basics for strings - we'll cover additional string concepts in a future section, Strings (Advanced).</p>"},{"location":"guide/basics/#int","title":"int","text":"<p>Rad has ints. There's nothing unusual about them. Example:</p> <pre><code>team_size = 20\ncelsius = -5\n</code></pre> <p>For large numbers, you can use underscores to improve readability:</p> <pre><code>population = 1_234_567\ndistance = 93_000_000\n</code></pre> <p>Note that if you divide two ints, you will get back a float.</p> <pre><code>liters = 10\npeople = 4\nprint(\"This is a float:\", liters / people)\n</code></pre> <pre><code>This is a float: 2.5\n</code></pre>"},{"location":"guide/basics/#float","title":"float","text":"<p>The other number type is float:</p> <pre><code>length_meters = 2.68\n</code></pre> <p>If you want to define a whole number as a float, simply include a decimal place:</p> <pre><code>years = 20.0\n</code></pre> <p>Like ints, floats also support underscores for readability and scientific notation:</p> <pre><code>precise_value = 123.456_789  // 123.456789\nsmall_number = 5e-3          // 0.005\n</code></pre>"},{"location":"guide/basics/#bool","title":"bool","text":"<p>Rad uses lowercase <code>true</code> / <code>false</code>:</p> <pre><code>is_running = true\nis_tired = false\n</code></pre>"},{"location":"guide/basics/#list","title":"list","text":"<p>Rad has two collection types: lists and maps. First, let's look at lists.</p> <pre><code>names = [\"alice\", \"bob\", \"charlie\"]\n</code></pre> <p>Lists you define can contain any types:</p> <pre><code>mixed = [\"alice\", true, 50, -2.4]\n</code></pre> <p>They can also be nested:</p> <pre><code>nested = [\"alice\", [1, [\"very nested\", \"bird\"]]]\n</code></pre> <p>Indexing and slicing works very similarly to Python. Using the above 3 variables for an example, you can index with both positive and negative indexes:</p> <pre><code>print(names[0])\nprint(mixed[-1])  // grab last element in the list\nprint(nested[1][1][0])\n</code></pre> <pre><code>alice\n-2.4\nvery nested\n</code></pre> <p>You can also slice:</p> <pre><code>numbers = [10, 20, 30, 40, 50]\nprint(numbers[1:3])\nprint(numbers[2:])\nprint(numbers[:-1])\n</code></pre> <pre><code>[20, 30]\n[30, 40, 50]\n[10, 20, 30, 40]\n</code></pre> <p>String Indexing and Slicing</p> <p>All the same indexing and slicing rules that apply to lists also work with strings:</p> <pre><code>text = \"hello\"\nprint(text[0])      // h\nprint(text[-1])     // o\nprint(text[1:4])    // ell\nprint(text[:3])     // hel\n</code></pre>"},{"location":"guide/basics/#map","title":"map","text":"<p>The other collection type is 'map'. These may also be referred to as 'hashmap' or 'dictionary' in other languages.</p> <pre><code>scores = { \"alice\": 25, \"bob\": 17, \"charlie\": 36 }\n</code></pre> <p>Like lists, they can contain mixed types for values, and can nest.</p> <pre><code>mixed_map = { \n  \"alice\": \"accountant\",\n  \"mylist\": [ \"London\", 25 ],\n}\n\nnested_map = {\n  \"error\": {\n    \"msg\": \"Request failed!\",\n    \"code\": 400,\n  }\n}\n</code></pre> <p>If we take the above example, values can then be accessed in two ways. First is the square bracket lookup:</p> <pre><code>print(mixed_map[\"alice\"])\nprint(nested_map[\"error\"][\"msg\"])\n</code></pre> <pre><code>accountant\nRequest failed!\n</code></pre> <p>Alternatively, you can use a dot syntax. Note this second way only works for keys with no spaces in the name.</p> <pre><code>print(mixed_map.alice)\nprint(nested_map.error.msg)\n</code></pre> <pre><code>accountant\nRequest failed!\n</code></pre> <p>You can modify maps using either syntax:</p> <pre><code>mymap = { \"alice\": 30 }\n\nmymap[\"alice\"] = 40\nprint(mymap)\n\nmymap.alice = 50\nprint(mymap)\n</code></pre> <pre><code>{ alice: 40 }\n{ alice: 50 }\n</code></pre> <p>You can also add keys this way:</p> <pre><code>mymap = { \"alice\": 30 }\nmymap[\"bob\"] = 31\nmymap.charlie = 32\nprint(mymap)\n</code></pre> <pre><code>{ alice: 30, bob: 31, charlie: 32 }\n</code></pre>"},{"location":"guide/basics/#other-types","title":"Other Types","text":"<p>Rad has other types that we won't cover here. For example <code>null</code> and function references.</p>"},{"location":"guide/basics/#destructuring","title":"Destructuring","text":"<p>You can unpack values from lists into separate variables. Let's start with the traditional way of accessing list elements:</p> <pre><code>coords = [10, 20]\nprint(coords[0], coords[1])  // 10 20\n</code></pre> <p>Instead of using indices, you can destructure the list by unpacking its values into separate variables:</p> <pre><code>[x, y] = [10, 20]\nprint(x, y)  // 10 20\n</code></pre> <p>As syntactic sugar, the square brackets are optional:</p> <pre><code>x, y = 10, 20\nprint(x, y)  // 10 20\n</code></pre> <p>Keep in mind that this is still destructuring - Rad is creating a list <code>[10, 20]</code> behind the scenes and unpacking it into <code>x</code> and <code>y</code>.</p> <p>Destructuring is particularly useful when functions return multiple values:</p> <pre><code>x, y = get_coordinates()\nwidth, height = get_dimensions()\n</code></pre> <p>You can also destructure in for loops, which we'll see later in the Control Flow section.</p>"},{"location":"guide/basics/#operators","title":"Operators","text":"<p>Rad offers operators similar to many other languages. Below sections very quickly demonstrate.</p>"},{"location":"guide/basics/#arithmetic","title":"Arithmetic","text":"<p>Rad follows the standard order of operations for operators <code>() , * , / , % , + , -</code>:</p> <ol> <li>Parentheses</li> <li>Multiplication, Division, Modulo</li> <li>Addition, Subtraction</li> </ol> <pre><code>print(1 + 4 / 2)    // 3\nprint(2.5 * 3 - 1)  // 6.5\nprint((4 + 5) * 2)  // 18\nprint(5 % 3)        // 2\n</code></pre> <p>Dividing two integers will result in a floating point number.</p> <pre><code>print(5 / 2)  // 2.5\n</code></pre> <p>You can multiply strings to repeat them:</p> <pre><code>name = \"alice\"\nprint(name * 3)  // alicealicealice\n</code></pre>"},{"location":"guide/basics/#comparison","title":"Comparison","text":"<p>Comparisons return bools that can be used in e.g. if statements.</p> <p>String comparison is done based on contents.</p> <pre><code>print(\"alice\" == \"alice\")  // true\nprint(\"alice\" == \"bob\")    // false\nprint(\"alice\" != \"bob\")    // true\nprint(\"alice\" == \"Alice\")  // false\n</code></pre> <p>Numbers can also be compared with the standard comparators <code>&gt; , &gt;= , &lt; , &lt;= , ==</code>.</p> <pre><code>print(2 &gt;= 2)  // true\nprint(2 &gt; 2)   // false\nprint(2 &lt;= 2)  // true\nprint(2 &lt; 2)   // false\nprint(2 == 2)  // true\n</code></pre> <p>You cannot use these operators (outside of <code>==</code>) to compare non-numbers such as strings:</p> <pre><code>print(\"alice\" &gt; \"bob\")  // error\n</code></pre> <p>But you can check them for equality (will always return false, except ints and floats that are equal):</p> <pre><code>print(2 == \"alice\")  // false\nprint(2 == 2.0)      // true\n</code></pre> <p>Difference From Python on <code>True == 1</code> and <code>False == 0</code></p> <p>In Python, <code>False == 0</code> and <code>True == 1</code> are true, because under the hood, False is really int 0 and True is really int 1, hence they're equal. That's not the case in Rad. In Rad, any two values of different types are not equal (except ints/floats).</p> <p>The reasoning stems from truthy/falsy-ness. In Python, both <code>1</code> and <code>2</code> are truthy. But only <code>1</code> equals <code>True</code>. Rad avoids this oddity of making <code>1</code> special by instead making any two different types not equal (except ints/floats).</p>"},{"location":"guide/basics/#logical","title":"Logical","text":"<p>Rad uses <code>and</code> and <code>or</code> for binary logical operations.</p> <pre><code>print(false and false)  // false\nprint(false and true)   // false\nprint(true  and false)  // false\nprint(true  and true)   // true\n\nprint(false or  false)  // false\nprint(true  or  false)  // true\nprint(false or  true)   // true\nprint(true  or  true)   // true\n</code></pre> <p>And it uses <code>not</code> for logical negation.</p> <pre><code>print(not true)   // false\nprint(not false)  // true\n</code></pre>"},{"location":"guide/basics/#membership","title":"Membership","text":"<p>You can check if an item exists in a collection using the <code>in</code> operator:</p> <pre><code>names = [\"alice\", \"bob\", \"charlie\"]\nprint(\"alice\" in names)     // true\nprint(\"david\" in names)     // false\n</code></pre> <p>The <code>in</code> operator also works with strings to check for substrings:</p> <pre><code>text = \"hello world\"\nprint(\"world\" in text)      // true\nprint(\"goodbye\" in text)    // false\n</code></pre> <p>For maps, <code>in</code> checks if a key exists:</p> <pre><code>scores = { \"alice\": 25, \"bob\": 17 }\nprint(\"alice\" in scores)    // true\nprint(\"charlie\" in scores)  // false\n</code></pre> <p>You can use <code>not in</code> to check for the absence of an item:</p> <pre><code>print(\"david\" not in names)  // true\nprint(\"alice\" not in names)  // false\n</code></pre>"},{"location":"guide/basics/#concatenation","title":"Concatenation","text":"<p>You can concatenate strings with <code>+</code>.</p> <pre><code>first = \"Alice\"\nlast = \"Bobson\"\nprint(first + \" \" + last)\n</code></pre> <pre><code>Alice Bobson\n</code></pre> <p>However, string interpolation is generally more readable:</p> <pre><code>print(\"{first} {last}\")\n</code></pre> <p>You can concatenate strings with non-strings by converting them to strings first using the <code>str</code> function:</p> <pre><code>a = 1\ntext = \". Bullet point one\"\nprint(str(a) + text)\n</code></pre> <pre><code>1. Bullet point one\n</code></pre>"},{"location":"guide/basics/#compound-operators","title":"Compound Operators","text":"<p>Rad also supports compound operators for modifying variables in-place.</p> <pre><code>a = 3\na += 2   // a is now 5\na -= 1   // a is now 4\na *= 3   // a is now 12\na %= 10  // a is now 2\na /= 4   // a is now 0.5\n</code></pre>"},{"location":"guide/basics/#increment-decrement","title":"Increment / Decrement","text":"<p>You can quickly increment and decrement ints and floats using <code>++</code> and <code>--</code> syntax.</p> <pre><code>a = 2\na++\nprint(a)\n\nb = 2.5\nb--\nprint(b)\n</code></pre> <pre><code>3\n1.5\n</code></pre> <p>The increment and decrement operators produce statements, not expressions. This means that <code>a++</code> does not return anything, and so cannot be used inside e.g. a conditional.</p> <p>For example, the following two uses are invalid, because <code>a++</code> doesn't return a value:</p> <pre><code>a = 5\nif a++ &gt; 0:  // invalid, nothing for &gt; to evaluate against on the left side\n    ...\n\nb = a++  // also invalid because a++ doesn't return any value\n</code></pre> <p>Because of that, there's also no reason to support pre-incrementing, and so <code>++a</code> or <code>--a</code> are invalid statements.</p>"},{"location":"guide/basics/#ternary","title":"Ternary","text":"<p>Rad supports <code>? :</code> style ternary operators. </p> <p><code>&lt;condition&gt; ? &lt;true case&gt; : &lt;false case&gt;</code></p> <pre><code>a = 5\nb = a &gt; 0 ? \"larger than 0\" : \"less than 0\"\nprint(b)\n</code></pre> <pre><code>larger than 0\n</code></pre>"},{"location":"guide/basics/#functions","title":"Functions","text":"<p>Rad provides many built-in functions to help you write scripts. Functions can be invoked using a standard syntax:</p> <pre><code>names = [\"Bob\", \"Charlie\", \"Alice\"]\nnum_people = len(names)\nprint(\"There are {num_people} people.\")\n\nsorted_names = sort(names)\nprint(sorted_names)\n</code></pre> <pre><code>There are 3 people.\n[ \"Alice\", \"Bob\", \"Charlie\" ]\n</code></pre> <p>In this example, we use <code>len()</code> to get the list length, <code>sort()</code> to sort it, and <code>print()</code> to display output.</p> <p>You can also define your own custom functions - we'll cover that (and more) in detail in the Functions section. For a complete list of all built-in functions, see the Functions Reference.</p>"},{"location":"guide/basics/#control-flow","title":"Control Flow","text":""},{"location":"guide/basics/#if-statements","title":"If Statements","text":"<p>Rad employs very standard if statements.</p> <p>You are not required to wrap conditions in parentheses <code>()</code>.</p> <pre><code>if units == \"metric\":\n    print(\"That's 10 meters.\")\nelse if units == \"imperial\":\n    print(\"That's almost 33 feet.\")\nelse:\n    print(\"I don't know that measurement system!\")\n</code></pre> <p>Blocks use whitespace &amp; indentation</p> <p>Note that Rad uses whitespace &amp; indentation to denote blocks, instead of braces.</p> <p>As a convention, you can use 4 spaces for indentation. Mixing tabs and spaces is not allowed.</p>"},{"location":"guide/basics/#for-loops","title":"For Loops","text":"<p>Rad allows \"for each\" loops for iterating through collections such as lists.</p> <pre><code>names = [\"Alice\", \"Bob\", \"Charlie\"]\nfor name in names:\n    print(\"Hi {name}!\")\n</code></pre> <pre><code>Hi Alice!\nHi Bob!\nHi Charlie!\n</code></pre> <p>You can also iterate through a range of numbers using the <code>range</code> function, which returns a list of numbers within some specified range.</p> <pre><code>for i in range(5):\n    print(i)\n</code></pre> <pre><code>0\n1\n2\n3\n4\n</code></pre> <p>You can also invoke <code>range</code> with a starting value i.e. <code>range(start, end)</code> and with a step value i.e. <code>range(start, end, step)</code>.</p> <p>If you want to iterate through a list while also having a variable for the item's index, you can do that by adding in an additional variable after the <code>for</code>. The first variable will be the index, and the second the item.</p> <pre><code>names = [\"Alice\", \"Bob\", \"Charlie\"]\nfor i, name in names:\n    print(\"{name} is at index {i}\")\n</code></pre> <pre><code>Alice is at index 0\nBob is at index 1\nCharlie is at index 2\n</code></pre> <p>When iterating through a map, if you have one variable in the loop, then that variable will be the key:</p> <pre><code>colors = { \"alice\": \"blue\", \"bob\": \"green\" }\nfor k in colors:\n    print(k)\n</code></pre> <pre><code>alice\nbob\n</code></pre> <p>If you have two, then the first will be the key, and the second will be the value.</p> <pre><code>colors = { \"alice\": \"blue\", \"bob\": \"green\" }\nfor k, v in colors:\n    print(k, v)\n</code></pre> <pre><code>alice blue\nbob green\n</code></pre> <p>A useful function to know when iterating is <code>zip</code>. It lets you combine parallel lists into a list of lists. To demonstrate:</p> <pre><code>names = [\"alice\", \"bob\", \"charlie\"]\nages = [30, 40, 25]\nzipped = zip(names, ages)\nprint(zipped)  // [ [ \"alice\", 30 ], [ \"bob\", 40 ], [ \"charlie\", 25 ] ]\n</code></pre> <p>These inner lists can then be unpacked by specifying the appropriate number of identifiers in a for loop: </p> <pre><code>names = [\"alice\", \"bob\", \"charlie\"]\nages = [30, 40, 25]\nfor _, name, age in zip(names, ages):\n    print(name, age)\n</code></pre> <pre><code>alice 30\nbob 40\ncharlie 25\n</code></pre> <p>Use of <code>_</code></p> <p>Note the use of <code>_</code> in the above for loop. It technically is the index, previously denoted by <code>i</code>, but by convention, we use <code>_</code> to indicate that a variable is unused.</p>"},{"location":"guide/basics/#breaking-out-of-loops","title":"Breaking Out of Loops","text":"<p>You can exit a loop early using the <code>break</code> statement:</p> <pre><code>numbers = [1, 2, 3, 4, 5]\nfor n in numbers:\n    if n == 3:\n        break\n    print(n)\n</code></pre> <pre><code>1\n2\n</code></pre> <p>The loop stops completely when it reaches <code>3</code>, so numbers after that are never processed.</p>"},{"location":"guide/basics/#skipping-iterations","title":"Skipping Iterations","text":"<p>You can skip to the next iteration using the <code>continue</code> statement:</p> <pre><code>numbers = [1, 2, 3, 4, 5]\nfor n in numbers:\n    if n == 3:\n        continue\n    print(n)\n</code></pre> <pre><code>1\n2\n4\n5\n</code></pre> <p>The number <code>3</code> is skipped, but the loop continues with the remaining numbers.</p>"},{"location":"guide/basics/#while-loops","title":"While Loops","text":"<p>While loops repeat a block of code as long as a condition is true:</p> <pre><code>count = 0\nwhile count &lt; 3:\n    print(\"Count: {count}\")\n    count++\n</code></pre> <pre><code>Count: 0\nCount: 1\nCount: 2\n</code></pre> <p>You can create an infinite loop by omitting the condition:</p> <pre><code>while:\n    print(\"This runs forever!\")\n    // Use break to exit when needed\n</code></pre> <p>The <code>break</code> and <code>continue</code> statements work in while loops just like they do in for loops.</p>"},{"location":"guide/basics/#switch-statements","title":"Switch Statements","text":"<p>Rad has switch statements and switch expressions.</p> <p>You can <code>switch</code> on a value and write cases to match against, including a <code>default</code>.</p> <pre><code>args:\n    a float\n    op string\n    b float\n\nswitch op:\n    case \"add\":\n        result = a + b\n        print(\"added: {result}\")\n    case \"times\":\n        result = a * b\n        print(\"multiplied: {result}\")\n    default:\n        print(\"I don't know how to do that.\")\n</code></pre> <p>Cases can be written as blocks or single-line expressions. For example, the above <code>default</code> could be made into a single line:</p> <pre><code>args:\n    a float\n    op string\n    b float\n\nswitch op:\n    case \"add\":\n        result = a + b\n        print(\"added: {result}\")\n    case \"times\":\n        result = a * b\n        print(\"multiplied: {result}\")\n    default -&gt; print(\"I don't know how to do that.\")\n</code></pre> <p>The above examples are switch statements, because they do not return anything. Switch expressions can be used in assignments.</p> <pre><code>args:\n    object string\n\nsound = switch object:\n    case \"car\" -&gt; \"vroom\"\n    case \"mouse\" -&gt; \"squeak\"\n    default -&gt; \"moo\"  // default to cow\n\nprint(sound)\n</code></pre> <p>The above example cases are all single-line expressions (<code>case ... -&gt; ...</code>). If you want to write a case as a block in a switch expression, you can use the <code>yield</code> keyword to return values.</p> <p>Note also that you can assign and return more than 1 value at a time. To demonstrate:</p> <pre><code>args:\n    object string\n\nsound, plural = switch object:\n    case \"car\" -&gt; \"vroom\", \"cars\"\n    case \"mouse\" -&gt; \"squeak\", \"mice\"\n    default:\n        print(\"Don't know '{object}'; defaulting to cow.\")\n        yield \"moo\", \"cows\"\n\nprint(`{plural} go \"{sound}\"`)\n</code></pre>"},{"location":"guide/basics/#list-comprehensions","title":"List Comprehensions","text":"<p>List comprehensions provide a concise way to create lists by transforming or filtering existing collections. They use familiar for loop syntax but produce a new list as a result.</p>"},{"location":"guide/basics/#basic-syntax","title":"Basic Syntax","text":"<pre><code>numbers = [1, 2, 3, 4, 5]\nsquares = [x * x for x in numbers]\nprint(squares)\n</code></pre> <pre><code>[ 1, 4, 9, 16, 25 ]\n</code></pre> <p>The general pattern is <code>[expression for variable in collection]</code>, which creates a new list by evaluating the expression for each item in the collection.</p>"},{"location":"guide/basics/#using-functions","title":"Using Functions","text":"<p>You can call functions in list comprehensions:</p> <pre><code>words = [\"hello\", \"world\"]\nuppercase = [upper(word) for word in words]\nprint(uppercase)\n</code></pre> <pre><code>[ \"HELLO\", \"WORLD\" ]\n</code></pre>"},{"location":"guide/basics/#iteration-patterns","title":"Iteration Patterns","text":"<p>List comprehensions support the same iteration patterns as for loops:</p> <pre><code>// With index\nitems = [\"a\", \"b\", \"c\"]\nindexed = [\"{i}: {item}\" for i, item in items]\nprint(indexed)\n</code></pre> <pre><code>[ \"0: a\", \"1: b\", \"2: c\" ]\n</code></pre>"},{"location":"guide/basics/#filtering-with-if","title":"Filtering with <code>if</code>","text":"<p>You can add an <code>if</code> clause to filter items while creating a list:</p> <pre><code>numbers = [1, 5, 10, 15, 20, 8]\nsmall_numbers = [x for x in numbers if x &lt; 10]\nprint(small_numbers)\n</code></pre> <pre><code>[ 1, 5, 8 ]\n</code></pre> <p>The filter condition can use any expression, including function calls:</p> <pre><code>words = [\"a\", \"ab\", \"abc\", \"abcd\"]\nshort_words = [w for w in words if len(w) &lt; 3]\nprint(short_words)\n</code></pre> <pre><code>[ \"a\", \"ab\" ]\n</code></pre> <p>You can combine filtering with transformation:</p> <pre><code>numbers = [1, 2, 3, 4, 5, 6]\neven_squares = [x * x for x in numbers if x % 2 == 0]\nprint(even_squares)\n</code></pre> <pre><code>[ 4, 16, 36 ]\n</code></pre> <p>Side Effects in Comprehensions</p> <p>If the expression in a comprehension produces side effects (like calling <code>print()</code>), the comprehension will still execute those side effects but returns an empty list:</p> <pre><code>[print(x) for x in [1, 2, 3]]  // Prints 1, 2, 3 but returns []\n</code></pre>"},{"location":"guide/basics/#truthy-falsy","title":"Truthy / Falsy","text":"<p>Rad supports truthy/falsy logic.</p> <p>This means that, instead of writing the following (as an example):</p> <pre><code>if len(my_list) &gt; 0:\n    print(\"My list has elements!\")\n</code></pre> <p>you can write</p> <pre><code>if my_list:\n    print(\"My list has elements!\")\n</code></pre> <p>Essentially, you can use any type as a condition, and it will resolve to true or false depending on the value.</p> <p>The following table shows which values return false for each type. All other values resolve to true.</p> Type Falsy Description string <code>\"\"</code> Empty strings int <code>0</code> Zero float <code>0.0</code> Zero list <code>[]</code> Empty lists map <code>{}</code> Empty maps <p>Blank strings and <code>null</code></p> <ul> <li>A string which is all whitespace e.g. <code>\" \"</code> is still truthy.</li> <li><code>null</code> is falsy.</li> </ul>"},{"location":"guide/basics/#converting-types","title":"Converting Types","text":"<p>Converting types may involve simple casts, or parsing.</p> <p>When casting, you can use the following functions: <code>str</code>,  <code>int</code>,  <code>float</code></p> <pre><code>print(int(2.1))  // 2\nprint(float(2))  // 2.0\nprint(str(2.2))  // \"2.2\"\n</code></pre> <p>Note that <code>int</code> and <code>float</code> will error on strings. To parse a string, use the following functions: <code>parse_int</code>,  <code>parse_float</code></p> <pre><code>print(parse_int(\"2\"))      // 2\nprint(parse_float(\"2.2\"))  // 2.2\n\nprint(parse_int(\"2.2\"))    // error\nprint(parse_float(\"bob\"))  // error\n</code></pre>"},{"location":"guide/basics/#summary","title":"Summary","text":"<ul> <li>We rapidly covered many basic topics such as assignment, data types, operators, and control flow.</li> <li>Rad has 6 basic types: strings, ints, floats, bools, lists, and maps.</li> <li>Strings and lists support indexing and slicing with the same syntax.</li> <li>Destructuring lets you unpack list values into separate variables: <code>x, y = [10, 20]</code> or simply <code>x, y = 10, 20</code>.</li> <li>Rad has operators such as <code>+ , - , * , / , %</code>. For bool logic, it uses <code>or</code> and <code>and</code>. For membership, <code>in</code> and <code>not in</code>.</li> <li>Rad provides many built-in functions like <code>len()</code>, <code>sort()</code>, <code>upper()</code>, and more. You can also define custom functions.</li> <li>Rad uses a \"for-each\" variety <code>for</code> loop. You always loop through items in a collection (or string).<ul> <li>If you want to increment through a number range, use the <code>range</code> function to generate you a list of ints.</li> <li>Use <code>break</code> to exit loops early and <code>continue</code> to skip to the next iteration.</li> </ul> </li> <li>List comprehensions provide a concise way to create lists: <code>[x * 2 for x in numbers]</code><ul> <li>Support filtering with <code>if</code>: <code>[x for x in numbers if x &lt; 10]</code></li> </ul> </li> <li>Rad also has <code>while</code> loops for repeating code while a condition is true.</li> <li>Rad offers truthy/falsy logic for more concise conditional expressions.</li> <li>Rad has switch statements and expressions. The latter uses <code>yield</code> as a keyword to return values from cases.</li> <li>Rad has functions for casting <code>str</code>, <code>int</code>, <code>float</code> and for parsing <code>parse_int</code>, <code>parse_float</code> values.</li> </ul>"},{"location":"guide/basics/#next","title":"Next","text":"<p>Good job on getting through the basics of the language! </p> <p>Next, let's dive into one of the areas of Rad that make it shine: Args.</p>"},{"location":"guide/defer-errdefer/","title":"Defer & Errdefer","text":"<p>With defer statements, you can specify blocks of code to be run before the script exits.</p> <p>You may wish to use them to clean up or undo operations before exiting.</p>"},{"location":"guide/defer-errdefer/#defer","title":"Defer","text":"<p><code>defer</code> blocks always run before the script exits, regardless of if it's due to an error or not.</p> <p>Here is an example:</p> defer.rad<pre><code>$`mv notes.txt notes-tmp.txt`\ndefer:\n    $`mv notes-tmp.txt notes.txt`\n    print(\"Moved back!\")\n\n$`echo \"hi!\" &gt;&gt; notes.txt`\n$`cat notes.txt`\n</code></pre> <p>Let's say we already have a file <code>notes.txt</code> containing some text. In this script, we take the following steps, largely by invoking shell commands:</p> <ol> <li>Rename <code>notes.txt</code> to <code>notes-tmp.txt</code></li> <li>Define a <code>defer</code> block which will undo the rename, and then print <code>Moved back!</code>.</li> <li>Create a new <code>notes.txt</code> with the contents <code>hi!</code></li> <li>Print the contents <code>notes.txt</code> to show what it contains.</li> </ol> <p>When run:</p> <pre><code>rad defer.rl\n</code></pre> <pre><code>\u26a1\ufe0f Running: mv notes.txt notes-tmp.txt\n\u26a1\ufe0f Running: echo \"hi!\" &gt;&gt; notes.txt\n\u26a1\ufe0f Running: cat notes.txt\nhi!\n\u26a1\ufe0f Running: mv notes-tmp.txt notes.txt\nMoved back!\n</code></pre> <p>Note that despite the <code>Moved back!</code> print statement appearing earlier in the script, it only gets run at the end due to being in a <code>defer</code> block.</p>"},{"location":"guide/defer-errdefer/#errdefer","title":"Errdefer","text":"<p>Sometimes, you only want certain deferred statements to run in the event of a failure. This is useful when your script is working toward a critical step that, once executed, should not be rolled back. However, if the script fails before reaching that step, rollback actions may still be necessary.</p> <p>Below is an example of a version-bumping script. Using <code>sed</code>, this script replaces the version in a file called <code>VERSION</code>, stages the file with git, and commits it. However, if there's a failure in between the <code>sed</code> and <code>commit</code> steps, then we want to undo earlier steps as a cleanup, in order to make the script atomic i.e. it either succeeds entirely or does nothing, leaving no intermediary state changes behind. We accomplish this through <code>errdefer</code> blocks. </p> bump.rad<pre><code>args:\n    version str\n\npath = \"VERSION\"\n\n$`sed -i '' \"s/Version = .*/Version = {version}/\" {path}`\nerrdefer:\n    print(\"Undoing bump...\")\n    $`git checkout -- {path}`\n\nif false:  // failure simulation point 1\n    print(\"Oh no! ERROR!\")\n    exit(1)\n\n$`git add {path}`\nerrdefer:\n    print(\"Resetting {path}...\")\n    _, _ = $`git reset {path}`\n\nif false:  // failure simulation point 2\n    print(\"Bah! ERROR!\")\n    exit(1)\n\n$`git commit -m \"Bump version to {version}\"`\nprint(\"Done!\")\n</code></pre> <p>We include a couple of \"failure points\". We can set their condition to <code>true</code> to have them simulate an error, as the exit code of '1' indicates failure.</p> <p>Before we do that though, we can see an example of this script working correctly. Let's say we define our <code>VERSION</code> file in the same directory as the script as follows:</p> VERSION<pre><code>Version = 1\n</code></pre> <p>If we execute our script, we get the following output:</p> <pre><code>rad bump.rl 2\n</code></pre> <pre><code>\u26a1\ufe0f Running: sed -i '' \"s/Version = .*/Version = 2/\" VERSION\n\u26a1\ufe0f Running: git add VERSION\n\u26a1\ufe0f Running: git commit -m \"Bump version to 2\"\n[main 6ce2ebb] Bump version to 2\n 1 file changed, 1 insertion(+), 1 deletion(-)\nDone!\n</code></pre> <p>We can see the series of commands get run as we expect, including output from git. Notice that none of our <code>errdefer</code> blocks ran, because there were no failures.</p> <p>Now let's say that we activate failure point 1 by setting its condition to <code>true</code>. This means that, after performing the <code>sed</code> command, but before we <code>git add</code>, the script exits, and we trigger just the first <code>errdefer</code> block to 'reset' the <code>VERSION</code> file.</p> <pre><code>rad bump.rl 3\n</code></pre> <pre><code>\u26a1\ufe0f Running: sed -i '' \"s/Version = .*/Version = 3/\" VERSION\nOh no! ERROR!\nUndoing bump...\n\u26a1\ufe0f Running: git checkout -- VERSION\n</code></pre> <p>If you run this locally, you should see with <code>git status</code> that there are no changes to the <code>VERSION</code> file, thanks to our <code>errdefer</code> block rolling back the <code>sed</code> replacement.</p> <p>Next let's try deactivating failure point 1 again and enabling failure point 2, and running our script again. This time, we can expect the <code>git add</code> to run, and our failure will occur after, but before the <code>git commit</code>.</p> <pre><code>rad bump.rl 3\n</code></pre> <pre><code>\u26a1\ufe0f Running: sed -i '' \"s/Version = .*/Version = 3/\" VERSION\n\u26a1\ufe0f Running: git add VERSION\nBah! ERROR!\nResetting VERSION...\n\u26a1\ufe0f Running: git reset VERSION\nUndoing bump...\n\u26a1\ufe0f Running: git checkout -- VERSION\n</code></pre> <p>Here we see a very important detail about defer blocks that applies both to <code>defer</code> and <code>errdefer</code> - if you have multiple, they run in LIFO (last in, first out) order. In other words, the defer blocks defined later run first.</p> <p>This is typically desirable, as this example demonstrates. After we <code>git commit</code>, we need to first <code>git reset</code>, otherwise the <code>git checkout</code> to undo the bump won't work. Thanks to LIFO, our <code>git reset</code> runs first and all is good.</p>"},{"location":"guide/defer-errdefer/#errors-in-defer-blocks","title":"Errors in defer blocks","text":"<p>If a script exits successfully and has multiple <code>defer</code> blocks, and the first one to run encounters an error, the remaining defer blocks still run. This also applies to <code>errdefer</code>. However, the script will exit with a non-0 error code.</p> <p><code>errdefer</code> blocks are only triggered if the main script fails. If the main script runs successfully, but a <code>defer</code> block then errors, that does not trigger <code>errdefer</code> blocks to run.</p>"},{"location":"guide/defer-errdefer/#summary","title":"Summary","text":"<ul> <li>Use <code>defer</code> and <code>errdefer</code> blocks to run operations after your main script ends.</li> <li>They can commonly be used for clean up operations and making your scripts atomic.</li> <li>Defer blocks run in LIFO order - last in, first out.</li> </ul>"},{"location":"guide/error-handling/","title":"Error Handling","text":"<p>Things go wrong in scripts - users provide invalid input, files don't exist, network requests fail. Generally, for smaller CLI scripts, it's okay if we just exit on the spot, and that's also Rad's default behavior. However, if you wish to more gracefully handle these errors or attempt recovery, Rad gives you the tools to do so.</p> <p>In Rad, errors are values. Functions that might fail return either a result or an error, and you can decide how to handle them. This makes error handling explicit, predictable, and easy to reason about.</p> <p>In this section, we'll explore:</p> <ul> <li>Error propagation - how errors bubble up by default (and why scripts exit)</li> <li>The <code>catch:</code> block - handle errors with full control (logging, reassignment, exit)</li> <li>The <code>??</code> operator - shorthand for simple fallback values</li> <li>Creating errors - using <code>error()</code> in your own functions</li> <li>Error type unions - making fallible operations explicit with <code>T|error</code> type annotations</li> </ul>"},{"location":"guide/error-handling/#error-propagation","title":"Error Propagation","text":"<p>Let's start with a simple script that takes a user's age as input:</p> File: age<pre><code>args:\n    age_str str  # User's age as a string\n\nage = parse_int(age_str)\nprint(\"You are {age} years old\")\n</code></pre> <p>In reality, you'd instead declare the arg as an <code>int</code> and let Rad handle input validation, but for the purposes of this guide, we write it as a <code>str</code>.</p> <p>If we run this with a valid number, everything works:</p> <pre><code>rad age 25\n</code></pre> <pre><code>You are 25 years old\n</code></pre> <p>But what happens with invalid input?</p> <pre><code>rad age \"not-a-number\"\n</code></pre> <pre><code>Error at L4:7\n\nage = parse_int(age_str)\n      ^^^^^^^^^^^^^^^^^^ parse_int() failed to parse \"not-a-number\" (RAD20001)\n</code></pre> <p>The script exits immediately with an error code of 1 when <code>parse_int</code> encounters invalid input. What's happening is that <code>parse_int</code> returned an <code>error</code> value, and since we're not handling it, it immediately gets propagated up. Since we're at the root of the script and not nested within any other function call, this triggers a script exit on the spot.</p>"},{"location":"guide/error-handling/#nested-calls","title":"Nested Calls","text":"<p>Errors don't just propagate from built-in functions - they bubble up through your own function calls too. Here's an example:</p> <pre><code>fn calculate_discount(price_str: str) -&gt; float|error:\n    price = parse_float(price_str)  // Error starts here...\n    return price * 0.1\n\nfn process_order(item_price: str) -&gt; str|error:\n    discount = calculate_discount(item_price)  // ...propagates through here...\n    return \"Discount: {discount:.2} USD\"\n\nresult = process_order(\"invalid\")  // ...and exits the script here\nprint(result)\n</code></pre> <pre><code>Error at L2:13\n\n      price = parse_float(price_str)  // Error starts here...\n              ^^^^^^^^^^^^^^^^^^^^^^\n              parse_float() failed to parse \"invalid\" (RAD20002)\n</code></pre> <p>The error originates in <code>parse_float</code>, propagates through <code>calculate_discount</code>, then through <code>process_order</code>, and finally exits at the top level. At any point in this chain, we could choose to handle the error instead of letting it propagate.</p> <p>This sets up the question: how do we handle errors gracefully instead of crashing?</p>"},{"location":"guide/error-handling/#catch-blocks","title":"Catch Blocks","text":"<p>The <code>catch:</code> block gives you full control over error handling. Attach it as a suffix to any expression that might error, and you can inspect the error, log it, provide a fallback value, or decide whether to exit.</p>"},{"location":"guide/error-handling/#basic-error-handling","title":"Basic Error Handling","text":"<p>Here's how to handle our age parsing example gracefully:</p> File: age<pre><code>args:\n    age_str str\n\nage = parse_int(age_str) catch:\n    print_err(\"Invalid age, falling back to 0: {age}\")  // 'age' contains the error value\n    age = 0  // Provide fallback\n\nprint(\"Age: {age}\")\n</code></pre> <p>Now when we run it with invalid input:</p> <pre><code>rad age \"not-a-number\"\n</code></pre> <pre><code>Invalid age, falling back to 0: parse_int() failed to parse \"not-a-number\"\nAge: 0\n</code></pre> <p>The script continues running with our fallback value. Inside the <code>catch:</code> block, the <code>age</code> variable contains the error string, as returned by <code>parse_int</code>, which we can log or inspect. We then reassign <code>age</code> to a sensible default value of <code>0</code>.</p> <p>To summarize:</p> <ul> <li>Suffix form: write <code>... catch:</code> directly after the error-able expression.</li> <li>Binding: the target variable is first bound to the error value; inside the block, interpolating it (e.g. <code>{age}</code>) prints the error\u2019s message.</li> <li>Control: you can log, reassign a fallback, or exit(code).</li> <li>Flow: execution continues after the block unless you exit.</li> </ul>"},{"location":"guide/error-handling/#exiting-on-errors","title":"Exiting on Errors","text":"<p>Sometimes you want to fail fast - handle the error just enough to log a helpful message, then exit:</p> File: readconfig<pre><code>args:\n    config_file str\n\nconfig = read_file(config_file) catch:\n    print_err(\"Failed to read config: {config}\")\n    exit(1)\n\nprint(\"Config loaded successfully\")\n// Continue processing config...\n</code></pre> <p>Running this with a non-existent file:</p> <pre><code>rad readconfig \"missing.txt\"\n</code></pre> <pre><code>Failed to read config: open missing.txt: no such file or directory\n</code></pre> <p>This example is not much better than the default error propagation and exit, but you can imagine providing more useful guidance to users in a more detailed error message.</p>"},{"location":"guide/error-handling/#ignoring-errors-with-pass","title":"Ignoring Errors with <code>pass</code>","text":"<p>Sometimes you want to ignore errors entirely - the operation might fail, but that's perfectly fine and requires no action:</p> <pre><code>// Custom fn to clean up temp file if it exists\ndelete_path(temp_file) catch:\n    pass  // File already doesn't exist, that's fine\n\n// Continue with the rest of the script...\n</code></pre> <p>Here, <code>pass</code> does nothing - it's a way to explicitly say \"I know this might error, but I don't care.\" This is useful for cleanup operations where the failure itself is harmless.</p>"},{"location":"guide/error-handling/#the-operator","title":"The <code>??</code> Operator","text":"<p>For simple cases where you just want a default value without any logging or conditional logic, the <code>??</code> operator provides a concise shorthand:</p> <pre><code>age = parse_int(age_str) ?? 0\ntimeout = parse_int(get_env(\"TIMEOUT\")) ?? 30\nmax_retries = parse_int(config[\"retries\"]) ?? 5\n</code></pre> <p>The <code>??</code> operator uses lazy evaluation - the right side is only evaluated if the left side returns an error. This means you can even call functions on the right:</p> <pre><code>config = read_file(config_path) ?? get_default_config()\n</code></pre>"},{"location":"guide/error-handling/#comparing-and-catch","title":"Comparing <code>??</code> and <code>catch</code>","text":"<p>These two are roughly equivalent:</p> <pre><code>// Using ??\nage = parse_int(age_str) ?? 0\n\n// Using catch:\nage = parse_int(age_str) catch:\n    age = 0\n</code></pre> <p>But <code>catch:</code> lets you log errors or do conditional handling:</p> <pre><code>age = parse_int(age_str) catch:\n    print_err(\"Invalid age '{age_str}': {age}\")\n    age = 0\n</code></pre> <p>When to use which</p> <p>Use <code>??</code> when you just need a default value and don't care about logging or inspecting the error. Use <code>catch:</code> when you need to log the error, perform conditional logic, including whether to exit.</p>"},{"location":"guide/error-handling/#creating-your-own-errors","title":"Creating Your Own Errors","text":"<p>When writing your own functions, you can return errors using the <code>error(str)</code> function. If you're using type annotations, then functions that may return errors should reflect that in its return type: <code>T|error</code>.</p> <pre><code>fn validate_port(port: int) -&gt; int|error:\n    if port &lt; 1 or port &gt; 65535:\n        return error(\"Port must be between 1-65535, got {port}\")\n    return port\n\nfn start_server(port_str: str) -&gt; void:\n    port = parse_int(port_str) ?? 8080\n\n    validated_port = validate_port(port) catch:\n        print_err(\"Invalid port: {validated_port}\")\n        exit(1)\n\n    print(\"Starting server on port {validated_port}\")\n\nstart_server(\"99999\")\n</code></pre> <pre><code>Invalid port: Port must be between 1-65535, got 99999\n</code></pre> <p>Our custom error message provides clear feedback about what went wrong. By returning <code>int|error</code>, the type signature tells you three things:</p> <ol> <li>This function normally returns an <code>int</code></li> <li>It might return an <code>error</code> instead</li> <li>Callers should consider handling the error case (otherwise let it propagate)</li> </ol> <p>This pattern is used throughout Rad's built-in functions:</p> <ul> <li><code>parse_int(str) -&gt; int|error</code></li> <li><code>parse_float(str) -&gt; float|error</code></li> <li><code>read_file(path) -&gt; error|{ \"size_bytes\": int, \"content\": str }</code></li> <li><code>round(num, decimals) -&gt; error|int|float</code></li> </ul> <p>The error union makes your code self-documenting - anyone reading your function signature knows immediately that it can fail.</p> <p>More on Union Types</p> <p>We covered union types in detail in an earlier section: Type Annotations. Error unions are just one application of Rad's union type system.</p>"},{"location":"guide/error-handling/#summary","title":"Summary","text":"<p>Rad's error handling model gives you the tools to write robust scripts that handle failures gracefully:</p> <ul> <li>Errors are values that propagate by default, unless handled</li> <li>Scripts exit if errors propagate up to the root of the script</li> <li><code>catch:</code> blocks provide full error handling control:<ul> <li>Variable contains the error string inside the block</li> <li>You can log errors, provide fallbacks, or call <code>exit()</code></li> <li>Execution continues unless you explicitly exit</li> </ul> </li> <li><code>??</code> operator provides concise fallbacks with lazy evaluation<ul> <li>Use for simple cases without logging</li> <li>Right side only evaluated if left side errors</li> </ul> </li> <li>Create errors with <code>error(\"message\")</code> in your own functions</li> <li>Type unions (<code>T|error</code>) make fallible operations explicit in function signatures</li> </ul>"},{"location":"guide/error-handling/#next","title":"Next","text":"<p>CLI scripts and the shell go hand in hand, and Rad offers first-class support for invoking shell commands and handling its output. We explore this in the next section: Shell Commands.</p>"},{"location":"guide/functions/","title":"Functions","text":"<p>Rad offers a range of built-in functions to help you write your scripts, and also allows you to define your own. In this section, we'll take a look at the syntax and a few examples. For a complete list of built-in functions, see the reference.</p>"},{"location":"guide/functions/#syntax","title":"Syntax","text":"<p>The syntax for invoking functions is pretty standard. Here's a script with some examples:</p> <pre><code>names = [\"Bob\", \"Charlie\", \"Alice\"]\nnum_people = len(names)\nprint(\"There are {num_people} people.\")\n\nsorted_names = sort(names)\nprint(sorted_names)\n</code></pre> <pre><code>There are 3 people.\n[ \"Alice\", \"Bob\", \"Charlie\" ]\n</code></pre> <p>This example uses three different built-in functions <code>len</code>, <code>print</code>, and <code>sort</code>.</p>"},{"location":"guide/functions/#ufcs","title":"UFCS","text":"<p>Rad supports a syntax called Uniform Function Call Syntax (UFCS) that lets you call functions using dot notation. This means you can write:</p> <pre><code>upper(\"hello\")\n\n// ... is the same as ...\n\n\"hello\".upper()\n</code></pre> <p>Both styles work identically, it's just syntactic sugar, but the dot notation really shines when you're chaining multiple function calls together.</p> <p>Compare these two approaches:</p> <pre><code>// Traditional nested calls - hard to read\nresult = upper(trim(text))\n\n// UFCS chaining - reads left to right\nresult = text.trim().upper()\n</code></pre> <p>The chained version is much more readable - you can follow the data flow naturally from left to right.</p> <p>UFCS works with any function where its first parameter matches the type you're calling it on.</p> <p>Encouraged Style</p> <p>You're encouraged to use UFCS, especially when it helps you avoid nested function calls.</p>"},{"location":"guide/functions/#function-arguments","title":"Function Arguments","text":"<p>Rad functions can accept arguments in several different ways. Let's explore each pattern.</p>"},{"location":"guide/functions/#positional-arguments","title":"Positional Arguments","text":"<p>Most functions accept arguments by position - you pass values in a specific order. Here are a few examples:</p> <pre><code>// Single argument\nnum = abs(-5)\nprint(num)  // 5\n\n// Multiple arguments\ntext = \"hello world\".replace(\"world\", \"Rad\")\nprint(text)  // hello Rad\n</code></pre> <p>Many functions also have optional parameters with defaults. For example, <code>join</code> combines list items into a string:</p> <pre><code>numbers = [1, 2, 3]\n\n// Just the list - uses default separator \"\"\nprint(numbers.join())\n\n// Custom separator\nprint(numbers.join(\"... \"))\n\n// Separator and prefix\nprint(numbers.join(\"... \", \"Counting: \"))\n\n// Separator, prefix, and suffix\nprint(numbers.join(\"... \", \"Counting: \", \"!\"))\n</code></pre> <pre><code>123\n1... 2... 3\nCounting: 1... 2... 3\nCounting: 1... 2... 3!\n</code></pre> <p>The function signature for <code>join</code> shows these optional parameters: <code>join(list, sep=\"\", prefix=\"\", suffix=\"\")</code>. You can provide as many or as few as you need.</p> <p>Example using join for url query params</p> <p>The <code>prefix</code> parameter is handy for generating URL query params:</p> <pre><code>url = \"https://api.github.com/repos/amterp/rad/commits\"\nquery_params = [\"path=README.md\", \"per_page=5\"]\nurl += query_params.join(\"&amp;\", \"?\")\nprint(url)\n</code></pre> <p>This produces: <code>https://api.github.com/repos/amterp/rad/commits?path=README.md&amp;per_page=5</code></p>"},{"location":"guide/functions/#named-arguments","title":"Named Arguments","text":"<p>Some functions accept named arguments that you pass using <code>name=value</code> syntax. Named arguments always come after positional arguments and are typically optional.</p> <p>A good example is <code>http_post</code>, which performs HTTP POST requests:</p> <pre><code>// Just the URL (simplest form)\nresponse = url.http_post()\n\n// With custom headers\nmy_headers = {\n    \"Authorization\": \"Bearer {token}\",\n}\nresponse = url.http_post(headers=my_headers)\n\n// With both headers and a body\nresponse = url.http_post(headers=my_headers, body=data)\n</code></pre> <p>Named arguments make it clear what each value represents, especially when a function has many optional parameters.</p>"},{"location":"guide/functions/#variadic-arguments","title":"Variadic Arguments","text":"<p>Some functions accept unlimited arguments. For example, <code>zip</code> can combine any number of lists:</p> <pre><code>names = [\"alice\", \"bob\", \"charlie\"]\nages = [30, 40, 25]\ncities = [\"NYC\", \"LA\", \"Chicago\"]\nscores = [100, 90, 85]\n\n// Combine 2 lists\npairs = zip(names, ages)\nprint(pairs)\n\n// Combine 3 lists\ntriples = zip(names, ages, cities)\nprint(triples)\n\n// Combine 4 lists (or more!)\nquads = zip(names, ages, cities, scores)\nprint(quads)\n</code></pre> <pre><code>[ [ \"alice\", 30 ], [ \"bob\", 40 ], [ \"charlie\", 25 ] ]\n[ [ \"alice\", 30, \"NYC\" ], [ \"bob\", 40, \"LA\" ], [ \"charlie\", 25, \"Chicago\" ] ]\n[ [ \"alice\", 30, \"NYC\", 100 ], [ \"bob\", 40, \"LA\", 90 ], [ \"charlie\", 25, \"Chicago\", 85 ] ]\n</code></pre> <p>Variadic functions can also have named arguments. For example, <code>zip</code> accepts <code>strict=true</code> for ensuring that all lists have the same length.</p>"},{"location":"guide/functions/#mixed-patterns","title":"Mixed Patterns","text":"<p>Some functions combine multiple argument patterns. For example, <code>pick</code> takes positional arguments and a named argument:</p> <pre><code>options = [\"vim\", \"emacs\", \"nano\"]\neditor = pick(options, prompt=\"Choose your editor\")\n</code></pre> <p>When in doubt about how to call a function, check the Functions Reference for complete signature details.</p>"},{"location":"guide/functions/#custom-functions","title":"Custom Functions","text":"<p>Rad lets you define your own functions using the <code>fn</code> keyword. You can create either named functions that you reference by name, or lambdas (anonymous functions) that you assign to variables or pass as arguments.</p>"},{"location":"guide/functions/#named-functions","title":"Named Functions","text":"<p>Named functions include the function name as part of the definition, making them easy to call from anywhere in your code.</p>"},{"location":"guide/functions/#basic-definition","title":"Basic Definition","text":"<p>Here's a simple function that adds two numbers:</p> <pre><code>fn add(x, y):\n    return x + y\n\nresult = add(5, 3)\nprint(result)  // 8\n</code></pre> <p>Functions use the <code>return</code> keyword to send values back. If your function body is a single expression, you can use a more concise syntax:</p> <pre><code>fn add(x, y) x + y\n\nresult = add(5, 3)\nprint(result)  // 8\n</code></pre> <p>Notice there's no colon (<code>:</code>) after the parameters in the single-line form, and no <code>return</code> keyword is needed.</p>"},{"location":"guide/functions/#multiple-return-values","title":"Multiple Return Values","text":"<p>Functions can return multiple values at once using comma separation:</p> <pre><code>fn get_coords():\n    x = 10\n    y = 20\n    return x, y  // equivalent to 'return [x, y]'\n\nx_pos, y_pos = get_coords()\nprint(\"Position: ({x_pos}, {y_pos})\")\n</code></pre> <pre><code>Position: (10, 20)\n</code></pre> <p>This uses destructuring (covered in Basics) to unpack the returned values into separate variables.</p>"},{"location":"guide/functions/#type-annotations","title":"Type Annotations","text":"<p>You can optionally add type annotations to function parameters and return values:</p> <pre><code>fn calculate_area(width: int, height: int) -&gt; int:\n    return width * height\n\narea = calculate_area(5, 10)\nprint(area)  // 50\n</code></pre> <p>There are three benefits to using these.</p> <ol> <li>They serve as documentation (self-documenting code).</li> <li>They are validated at runtime i.e. the above function will error early if a string is passed into <code>calculate_area</code>.</li> <li>They help Rad's static analysis tools reason about your code, making them more useful.</li> </ol> <p>They are covered in detail in a later section: Type Annotations.</p>"},{"location":"guide/functions/#hoisting","title":"Hoisting","text":"<p>Named functions have some special scoping rules worth knowing:</p> <p>At the root level, functions are hoisted - you can call them before they're defined:</p> <pre><code>result = multiply(4, 5)\nprint(result)  // 20\n\nfn multiply(a, b):\n    return a * b\n</code></pre> <p>This works because Rad processes all root-level function definitions before executing the script.</p> <p>Inside blocks, functions are NOT hoisted - you must define them before calling:</p> <pre><code>if true:\n    print(helper())  // Error - can't call before definition\n\n    fn helper():\n        return \"I'm a helper!\"\n\n    print(helper())  // This is okay!\n</code></pre>"},{"location":"guide/functions/#lambdas","title":"Lambdas","text":"<p>Sometimes you need a quick function without giving it a name. That's where lambdas come in - they're anonymous functions you can assign to variables or pass as arguments.</p> <p>Lambdas use the same <code>fn</code> keyword, but without a name:</p> <pre><code>// Single-line lambdas\ndouble = fn(x) x * 2\nadd = fn(x, y) x + y\n\nprint(double(5))  // 10\nprint(add(3, 4))  // 7\n</code></pre> <p>For multi-line logic, use the block style with a colon:</p> <pre><code>calculate = fn(x):\n    result = x * 2 + 10\n    return result\n\nprint(calculate(5))  // 20\n</code></pre> <p>Lambdas are particularly useful for defining once-off operations and passing them as arguments. For example, with <code>map</code>, <code>filter</code>, and <code>flat_map</code>:</p> <pre><code>numbers = [1, 2, 3, 4, 5]\ndoubled = numbers.map(fn(x) x * 2)\nprint(doubled)  // [2, 4, 6, 8, 10]\n\nevens = numbers.filter(fn(x) x % 2 == 0)\nprint(evens)  // [2, 4]\n\n// flat_map is useful for transformations that produce lists\nwords = [\"hello world\", \"foo bar\"]\nall_words = words.flat_map(fn(s) s.split(\" \"))\nprint(all_words)  // [\"hello\", \"world\", \"foo\", \"bar\"]\n</code></pre> <p>Named Functions vs Lambdas</p> <ul> <li>Use named functions (<code>fn add(x, y):</code>) for reusable logic that you'll call from multiple places</li> <li>Use lambdas (<code>fn(x) x * 2</code>) for one-off operations or callbacks</li> </ul>"},{"location":"guide/functions/#reference","title":"Reference","text":"<p>There are a lot of built-in functions. If you want to see what's available and how to use them, refer to the reference.</p>"},{"location":"guide/functions/#summary","title":"Summary","text":"<ul> <li>Function invocation syntax is similar to Python, Java, and other familiar languages</li> <li>UFCS (Uniform Function Call Syntax) lets you chain functions using dot notation: <code>text.trim().upper()</code></li> <li>Functions can accept arguments in several ways:<ul> <li>Positional: passed by order, may have defaults (<code>join(list)</code>, <code>join(list, \"|\")</code>)</li> <li>Named: passed with <code>name=value</code> syntax (<code>http_get(url, headers=my_headers)</code>)</li> <li>Variadic: accept unlimited arguments (<code>zip(list1, list2, list3, ...)</code>)</li> <li>Mixed: combinations of the above patterns</li> </ul> </li> <li>You can define named functions with <code>fn name():</code> for reusable logic<ul> <li>Supports block style (with <code>:</code>) </li> <li>Supports single-line style (without <code>:</code> e.g. <code>fn add(x, y) x + y</code>)</li> <li>Can return multiple values using comma separation</li> <li>Are hoisted at the root of scripts (can be called before definition)</li> <li>Can have optional type annotations</li> </ul> </li> <li>Lambdas are anonymous functions: <code>double = fn(x) x * 2</code><ul> <li>Useful for one-off operations and callbacks - functions like <code>map()</code>, <code>filter()</code>, and <code>flat_map()</code></li> </ul> </li> </ul>"},{"location":"guide/functions/#next","title":"Next","text":"<p>We've already covered the Basics of strings, but there are some more advanced string concepts which are worth covering, such as formatting in string interpolations, raw strings, etc.</p> <p>We'll cover these in the next section: Strings (Advanced)</p>"},{"location":"guide/getting-started/","title":"Getting Started","text":""},{"location":"guide/getting-started/#what-is-rad","title":"What is Rad?","text":"<p>If you want to jump straight to programming, feel free to skip forwards to Installation.</p> <p>Rad is a modern programming language and interpreter designed to make writing CLI scripts delightful. It has a familiar, Python-like syntax with built-in concepts like declarative arguments, JSON handling, first-class shell integration, and user prompts - making common scripting tasks easy and fast to implement.</p> <p>If you've ever written scripts and felt like your tools were fighting you, you're not alone:</p> <p>With Bash, you might find yourself:</p> <ul> <li>Wrestling with <code>while getopts</code> boilerplate just to parse a few arguments</li> <li>Doing <code>curl | jq | awk</code> gymnastics to process JSON</li> <li>Skipping the \"nice-to-haves\" like <code>--help</code> or input validation because they're too painful to implement</li> <li>Delivering scripts that work, but are hard to read and harder to maintain</li> </ul> <p>With Python, you get better syntax, but:</p> <ul> <li>You need argparse boilerplate before you even start solving your problem, or reach for additional libraries</li> <li>Sharing scripts means coordinating runtimes and dependencies (virtualenvs, lockfiles)</li> <li>Simple CLI tasks feel heavier than they should</li> </ul> <p>With Rad, the language is purpose-built for CLI scripting:</p> <ul> <li>Delightful to write - familiar syntax without the footguns</li> <li>Self-documenting - automatic <code>--help</code> generation from your code comments</li> <li>Declarative arguments - type checking, validation, and parsing built into the language</li> <li>Easy to share - batteries included, no external dependencies needed</li> </ul> <p>If you ever write a CLI script, Rad is the language to do it in.</p> <p>Project Status: Rad is in early development but useful today for real scripts. Core features work well, though expect breaking changes between versions as the language evolves. Your feedback directly shapes Rad's future!</p> <p>Let's get into it.</p>"},{"location":"guide/getting-started/#installation","title":"Installation","text":""},{"location":"guide/getting-started/#macos-homebrew","title":"macOS (Homebrew)","text":"<pre><code>brew install amterp/rad/rad\n</code></pre>"},{"location":"guide/getting-started/#go-from-source-all-platforms","title":"Go (from source, all platforms)","text":"<pre><code>go install github.com/amterp/rad@latest\n</code></pre> <p>Note: You will need to run <code>go install</code> yourself to upgrade Rad as new versions are released. For automated updates, use one of the supported package managers that allow it.</p>"},{"location":"guide/getting-started/#binary-downloads","title":"Binary Downloads","text":"<p>Pre-built binaries for macOS, Linux, and Windows: releases page</p>"},{"location":"guide/getting-started/#checking-installation","title":"Checking Installation","text":"<p>After you've installed Rad and ensured it's on your PATH, you can check your installation:</p> <pre><code>rad -h\n</code></pre> <p>If this prints the help string for Rad, you're set!</p>"},{"location":"guide/getting-started/#visual-studio-code-extension","title":"Visual Studio Code Extension","text":"<p>Rad has a VS Code extension here which offers nice syntax highlighting and script validation (including catching syntax errors).</p> <p>Installing it is highly recommended!</p> <p></p>"},{"location":"guide/getting-started/#your-first-rad-script-hello-world","title":"Your First Rad Script - Hello World","text":"<p>Let's write the classic \"Hello, World!\" program. We'll then modify it to give it a bit of a Rad twist, demoing a few features that Rad provides.</p> <p>First, create a file, let's call it simply <code>hello</code>, and give it the following contents:</p> <pre><code>print(\"Hello, World!\") \n</code></pre> <p><code>print()</code></p> <p><code>print()</code> is the go-to function for outputting to stdout. It behaves a lot like <code>print()</code> in Python.</p> <p>You can read more about it in the reference.</p> <p>File Extension</p> <p>If you want to give your Rad scripts an extension, you can use <code>.rad</code> as a convention.</p> <p>Then, run the script from your CLI by invoking <code>rad</code> on it, and you should see it print out like so:</p> <pre><code>&gt; rad hello\n</code></pre> <pre><code>Hello, World!\n</code></pre> <p>Nice! Now, let's spruce it up with a few Rad features.</p>"},{"location":"guide/getting-started/#adding-in-some-rad-features","title":"Adding In Some Rad Features","text":"<p>One of Rad's primary features is its simple, declarative style to defining script arguments.</p> <p>Let's modify the script to greet a name you input from command line.</p> <pre><code>args:\n  name str\n\nprint(\"Hello, {name}!\")\n</code></pre> <p>A couple of things to note here:</p> <ol> <li>We define an \"args block\". Right now it contains just the one line, but you can do lots of things in here.</li> <li>The modified <code>print()</code> utilizes string interpolation. String interpolation in Rad behaves a lot like it does in Python (you'll see this is a pattern).</li> </ol> <p>Now, let's try invoking the script again, and this time, input a name:</p> <pre><code>&gt; rad hello Alex\n</code></pre> <pre><code>Hello, Alex!\n</code></pre> <p>Cool! What happens if we invoke without a name?</p> <pre><code>&gt; rad hello\n</code></pre> <pre><code>Usage:\n  hello &lt;name&gt;\n\nScript args:\n      --name str\n</code></pre> <p>If you run a Rad script without providing any args to a script which expects at least one, Rad will print out the script usage, interpreting your invocation as if you had passed <code>--help</code>.</p> <p>Positional vs Flag Arguments</p> <p>Arguments can be passed positionally or via flags. For example, both <code>./hello Alice</code> and <code>./hello --name Alice</code> work identically. The help text shows both forms: <code>&lt;name&gt;</code> for positional usage and <code>--name str</code> for the flag form.</p> <p>This shows a little of the automatic script usage that Rad generates for you. Let's explore that a bit more.</p>"},{"location":"guide/getting-started/#improving-the-script-usage-string","title":"Improving The Script Usage String","text":"<p>Rad facilitates writing well-documented and easy-to-use scripts, in part through unique syntax. Let's use a couple of those now.</p> <p>First, we'll add a file header to your script.</p> <pre><code>---\nPrints a polite greeting using an input name.\n---\nargs:\n  name str\n\nprint(\"Hello, {name}!\")\n</code></pre> <p>File Headers</p> <p>File headers, as the name suggests, go at the top of Rad scripts (with the exception of shebangs, to be covered later).  They allow you to write a description for your script in between two <code>---</code> lines. The contents will get printed as part of the script's usage string.</p> <p>A couple of ideas on what to cover in your file headers:</p> <ul> <li>A brief description of what the script does and how it works</li> <li>Examples of valid invocations and what they do.</li> </ul> <p>Second, we can add comments to args that a script declares. Let's do that too:</p> <pre><code>---\nPrints a polite greeting using an input name.\n---\nargs:\n  name str  # The name of someone to greet.\n\nprint(\"Hello, {name}!\")\n</code></pre> <p>Note on <code>#</code> vs. <code>//</code></p> <p>Rad uses <code>#</code> to denote arg comments. <code>#</code> comments are special and do get passed to Rad's parser and can affect script behavior (namely in this case, adding information to the script usage string). </p> <p>Standard code comments in Rad use <code>//</code>, similar to Java or C/C++, and don't impact script behavior.</p> <p>Now, when someone reads the script, it's pretty clear what the script does and what the expected arguments are.</p> <p>But it gets better! Let's try invoking the script's usage string again (this time let's try using the <code>-h</code> flag explicitly, though it's not necessary):</p> <pre><code>&gt; rad hello -h\n</code></pre> <pre><code>Prints a polite greeting using an input name.\n\nUsage:\n  hello &lt;name&gt;\n\nScript args:\n      --name str   The name of someone to greet.\n</code></pre> <p>Not only is the script now easier to maintain for developers, it's also easier for users to understand!</p>"},{"location":"guide/getting-started/#shebang","title":"Shebang","text":"<p>Needing to manually invoke <code>rad</code> each time you want to run a Rad script can be a little cumbersome. Thankfully, Unix kernels provide a mechanism known as a \"shebang\".</p> <p>Let's add one to our script. It has to go on the very first line.</p> <pre><code>#!/usr/bin/env rad\n---\nPrints a polite greeting using an input name.\n---\nargs:\n  name str  # The name of someone to greet.\n\nprint(\"Hello, {name}!\")\n</code></pre> <p>Then, make the script executable using the following command:</p> <pre><code>chmod +x ./hello\n</code></pre> <p>Now, you can invoke the script directly:</p> <pre><code>&gt; ./hello Bob\n</code></pre> <pre><code>Hello, Bob!\n</code></pre> <p>When you invoke an executable script this way, the kernel scans for a shebang (<code>#!</code>) in the first line. If it finds a path to an interpreter (in this case, it will find <code>rad</code>, if set up correctly in your <code>PATH</code>), then it will invoke said interpreter on the script (equivalent to <code>rad hello</code> like we were doing before).</p> <p>rad new</p> <p>Rad has a command <code>rad new &lt;script&gt;</code> which saves you repeating these steps. It creates a ready-to-edit executable file with a <code>rad</code> shebang on the top.</p>"},{"location":"guide/getting-started/#a-complete-example","title":"A Complete Example","text":"<p>Now that you've seen the basics, let's skip ahead a little with our example, to get a better idea of what Rad can really do. Don't worry - we'll cover everything in detail in later sections. For now, just observe what Rad gives you for free.</p> <p>Update your <code>hello</code> script to this:</p> <pre><code>#!/usr/bin/env rad\n---\nPrints a polite greeting using an input name.\n---\nargs:\n  name str                # The name of someone to greet.\n  times t int = 1         # How many times to greet them.\n  style s str = \"normal\"  # Greeting style.\n\n  times range (0, 10]\n  style enum [\"normal\", \"excited\", \"formal\"]\n\ngreeting = switch style:\n  case \"excited\" -&gt; \"HEY\"\n  case \"formal\" -&gt; \"Good day\"\n  default -&gt; \"Hello\"\n\nfor i in range(times):\n  print(\"{greeting}, {name}!\")\n</code></pre> <p>What we added:</p> <ul> <li>Two more arguments with default values (<code>times</code> and <code>style</code>)</li> <li>Short flag aliases (<code>-t</code> and <code>-s</code>) for convenience</li> <li>Argument constraints<ul> <li><code>times</code> must be greater than 0, and max 10 (inclusive)</li> <li><code>style</code> must be one of three values</li> </ul> </li> <li>A switch expression to map style to greeting text</li> <li>A for loop to repeat the greeting</li> </ul> <p>All of this in ~20 lines, with zero validation boilerplate.</p>"},{"location":"guide/getting-started/#try-it-out","title":"Try it out","text":"<p>Normal usage with short flags:</p> <pre><code>&gt; ./hello Alice -t 3 -s excited\n</code></pre> <pre><code>HEY, Alice!\nHEY, Alice!\nHEY, Alice!\n</code></pre> <p>Check the automatically generated help:</p> <pre><code>&gt; ./hello -h\n</code></pre> <pre><code>Prints a polite greeting using an input name.\n\nUsage:\n  hello &lt;name&gt; [times] [style] [OPTIONS]\n\nScript args:\n      --name str    The name of someone to greet.\n  -t, --times int   How many times to greet them. Range: (0, 10] (default 1)\n  -s, --style str   Greeting style. Valid values: [normal, excited, formal] (default normal)\n</code></pre> <p>Note how the constraints appear in the help automatically.</p>"},{"location":"guide/getting-started/#what-about-invalid-input","title":"What about invalid input?","text":"<p>Try providing an invalid range:</p> <pre><code>&gt; ./hello Bob -t 15\n</code></pre> <pre><code>'times' value 15 is &gt; maximum 10\n</code></pre> <p>Try an invalid enum value:</p> <pre><code>&gt; ./hello Bob -s casual\n</code></pre> <pre><code>Invalid 'style' value: casual (valid values: normal, excited, formal)\n</code></pre> <p>You didn't write any of this validation code. Rad enforced the constraints you declared and generated helpful error messages automatically.</p>"},{"location":"guide/getting-started/#summary","title":"Summary","text":"<p>In this section, we were introduced to several key features:</p> <ul> <li>String interpolation with <code>{variable}</code> syntax for readable output</li> <li>args blocks for declarative argument definitions</li> <li>File headers and arg comments for self-documenting scripts</li> <li>Shebangs to make scripts more convenient to run</li> <li>Argument constraints (range, enum) with automatic validation - no manual validation needed</li> <li>Short flag aliases for better user experience</li> <li>Automatic <code>--help</code> generation from your code comments</li> </ul> <p>Features you'd normally skip in Bash, or need external dependencies for in other languages, come built-in with Rad's declarative syntax. \ud83e\udd19</p> <p>Note on Rad script content ordering</p> <p>Rad expects a certain order between shebangs, file headers, arg blocks, and the rest of your code.</p> <p>It's important to adhere to the following ordering in Rad scripts, or you'll see errors:</p> <p>1) Shebang (if present)</p> <p>2) File header (if present)</p> <p>3) Args block (if present)</p> <p>4) Rest of the file</p>"},{"location":"guide/getting-started/#next","title":"Next","text":"<p>Great job on getting this far! You've gotten a small peek at what Rad has to offer.</p> <p>From here, you have a couple of options:</p> <ol> <li> <p>Continue your Rad journey: dive into more details with the next section: Basics.</p> </li> <li> <p>If you'd like to see additional unique Rad features, here are some sections you can jump to:</p> <ul> <li>Args</li> <li>Rad Blocks</li> <li>Shell Commands</li> <li>Example: brewi</li> </ul> </li> </ol>"},{"location":"guide/global-flags/","title":"Global Flags","text":"<p>Rad offers a range of global flags that are available with every Rad script. We'll explore some of them in this section.</p>"},{"location":"guide/global-flags/#help","title":"<code>help</code>","text":"<p>The most basic global flag is <code>--help</code> or <code>-h</code>. All Rad scripts automatically generate a usage string that can be displayed by invoking this flag.</p> <p><code>--help</code> also prints available global flags:</p> <pre><code>Global flags:\n  -h, --help                   Print usage string.\n  -d, --debug                  Enables debug output. Intended for Rad script developers.\n      --rad-debug              Enables Rad debug output. Intended for Rad developers.\n      --color mode             Control output colorization. Valid values: [auto, always, never]. (default auto)\n  -q, --quiet                  Suppresses some output.\n      --shell                  Outputs shell/bash exports of variables, so they can be eval'd\n  -v, --version                Print rad version information.\n      --stdin script-name      Enables reading Rad from stdin, and takes a string arg to be treated as the 'script name'.\n      --confirm-shell          Confirm all shell commands before running them.\n      --src                    Instead of running the target script, just print it out.\n      --src-tree               Instead of running the target script, print out its syntax tree.\n      --mock-response string   Add mock response for json requests (pattern:filePath)\n</code></pre> <p>Note that, outside of <code>help</code>, all the global flags are ALL CAPS.</p>"},{"location":"guide/global-flags/#debug","title":"<code>debug</code>","text":"<p><code>debug</code> is an built-in function which behaves exactly like <code>print</code>, except that it only prints if the global flag <code>--debug</code> is enabled. You can use them in your script for debugging as desired.</p> <p>For example, given this example:</p> debug.rad<pre><code>print(\"1\")\ndebug(\"2\")\nprint(\"3\")\n</code></pre> <p>the following invocations will give the respective outputs:</p> <pre><code>rad debug.rad\n</code></pre> <pre><code>1\n3\n</code></pre> <pre><code>rad debug.rad -d\n</code></pre> <pre><code>1\nDEBUG: 2\n3\n</code></pre>"},{"location":"guide/global-flags/#quiet","title":"<code>quiet</code>","text":"<p>Use <code>--quiet</code> or <code>-q</code> to suppress some outputs, including print statements and errors. Some outputs still get printed e.g. shell command outputs.</p>"},{"location":"guide/global-flags/#color","title":"<code>color</code>","text":"<pre><code>--color mode\n    Control output colorization.\n    Valid values: [auto, always, never].\n    (default auto)\n</code></pre> <p>A lot of Rad's outputs have colors e.g. <code>pick</code> interaction or <code>pprint</code> JSON formatted output. By default (<code>auto</code>), Rad checks your terminal to detect if it's appropriate to enable colors or not. Things like piping or redirecting output will disable coloring.</p> <p>However, you can override the automatic detection by explicitly setting <code>--color=always</code> or <code>--color=never</code> to force having colors, or force not having colors, respectively. </p>"},{"location":"guide/global-flags/#mock-response","title":"<code>mock-response</code>","text":"<p>You might be writing a script which hits a JSON API and uses its output e.g. formatting it into a table using a <code>rad</code> block.</p> <p>In writing said script, you may wish to test it against certain responses that the live API isn't giving you at the moment, perhaps because the server is down. To accomplish this, you can use the <code>mock-response</code> flag.</p> <p><code>mock-response</code> takes an argument in a <code>&lt;url regex&gt;:&lt;file path&gt;</code> format. In other words, you can mock responses based on a regex match of the queried URL, and make them return the contents of a specified file.</p> <p>For example, if you wanted to mock a response from GitHub's API, you could define an example response in a file:</p> commits.json<pre><code>[\n  {\n    \"sha\": \"306f3a4ddb3b09747d61a5eab264c3d72fbbc36e\",\n    \"commit\": {\n      \"author\": {\n        \"name\": \"Alice Smith\",\n        \"date\": \"2025-01-11T04:15:06Z\"\n      }\n    }\n  },\n  {\n    \"sha\": \"2b642c482b32e4d87924839b2f5a9592670dee69\",\n    \"commit\": {\n      \"author\": {\n        \"name\": \"Charlie Johnson\",\n        \"date\": \"2025-01-10T12:21:03Z\"\n      }\n    }\n  }\n]\n</code></pre> <p>And then define it as the mock response with the following example invocation:</p> <pre><code>rad commits.rl --mock-response \"api.github.*:commits.json\"\n</code></pre> <p>Before executing the HTTP request, Rad checks for defined mock responses and if there's a regex match against the URL, it will short circuit, avoiding the HTTP request, and simply returning the contents of the mocked response.</p> <p>Match all URLs with .*</p> <p>It's common for scripts to perform just one API query, in which case the regex filter doesn't need to be specific. Instead, you can just write <code>.*</code> e.g. <code>.*:commits.json</code>.</p>"},{"location":"guide/global-flags/#additional-commands","title":"Additional Commands","text":"<p>There are more global flags - see the reference for a complete coverage of what's available.</p>"},{"location":"guide/global-flags/#summary","title":"Summary","text":"<ul> <li>Rad provides several global flags that can be used across all Rad scripts.</li> <li>Use <code>mock-response</code> to test your scripts.</li> </ul> <p>Script args can shadow global flags</p> <p>If a script defines an arg such as <code>debug</code>, conflicting with an existing global flag, then the script arg will shadow the global flag.</p> <p>This means that the global flag's functionality is effectively disabled for the script. It gets removed from the script's usage string, and the script itself defines the behavior of the flag.</p>"},{"location":"guide/global-flags/#next","title":"Next","text":"<p>Sometimes you may wish to run commands before your script ends, either normally or via an error, such as cleanups. Rad provides a way to do this that we will explore in the next section: Defer &amp; Errdefer.</p>"},{"location":"guide/json-paths-advanced/","title":"Json paths advanced","text":"<p>TBC (placeholder 2025-10-27)</p>"},{"location":"guide/rad-blocks/","title":"Rad Blocks","text":"<p>Working with JSON APIs is a common scripting task. You might need to query GitHub for repository info, check the status of your cloud services, or pull data from internal APIs. Typically, this involves making HTTP requests, parsing JSON responses, extracting the fields you care about, and formatting everything for display.</p> <p>Rad makes this entire workflow concise and declarative with rad blocks - a special syntax that lets you query JSON APIs and display results as formatted tables in just a few lines of code. Instead of writing imperative parsing logic, you declare what you want, and Rad handles the rest.</p>"},{"location":"guide/rad-blocks/#basic-example","title":"Basic Example","text":"<p>This concept will become clearer with an example.</p> <p>Below is a simple script capable of querying a given GitHub repo (leveraging GitHub's public API) for information about its latest commits.</p> File: commits<pre><code>args:\n    repo str        # The repo to query. Format: user/project\n    limit int = 20  # The max commits to return.\n\nurl = \"https://api.github.com/repos/{repo}/commits?per_page={limit}\"\n\nTime = json[].commit.author.date\nAuthor = json[].commit.author.name\nSHA = json[].sha\n\nrad url:\n    fields Time, Author, SHA\n</code></pre> <p>And running it looks something like this:</p> <pre><code>rad commits amterp/rad 5\n</code></pre> <pre><code>Querying url: https://api.github.com/repos/amterp/rad/commits?per_page=5\nTime                  Author          SHA\n2025-01-11T04:15:06Z  Alexander Terp  306f3a4ddb3b09747d61a5eab264c3d72fbbc36e\n2025-01-11T03:07:56Z  Alexander Terp  304a914644dfd73a59b85a191481f9c429b4d25e\n2025-01-11T01:00:42Z  Alexander Terp  7171ec92ae729f9d04e224e16272c9b888dffe41\n2025-01-10T12:11:08Z  Alexander Terp  4b64f585d08d9a5ee40549b6b9624530ac713eb1\n2025-01-09T11:34:51Z  Alexander Terp  abfcf2d940a18b819f7ae9e9040550a9644e5120\n</code></pre> <p>This is a simple example, but it demonstrates the ability to query GitHub's API (which returns JSON), extracting fields we're interested in (commits' time, author, and SHA).</p> <p>And that's with just a few lines of code! Let's break it down piece by piece.</p>"},{"location":"guide/rad-blocks/#arg-block","title":"Arg Block","text":"<pre><code>args:\n    repo str        # The repo to query. Format: user/project\n    limit int = 20  # The max commits to return.\n\nurl = \"https://api.github.com/repos/{repo}/commits?per_page={limit}\"\n</code></pre> <p>Here we have an args block where we declare a <code>repo</code> string and a <code>limit</code> int with a default of 20. After the args block, we create a <code>url</code> string using string interpolation to fill in the repo name, and the limit for how many commits we want GitHub to give us.</p>"},{"location":"guide/rad-blocks/#json-paths","title":"Json Paths","text":"<pre><code>Time = json[].commit.author.date\nAuthor = json[].commit.author.name\nSHA = json[].sha\n</code></pre> <p>This is where things get more interesting. The above definitions correspond to expected paths in the JSON response i.e. a series of keys to look up.</p> <p>In Rad nomenclature, we refer to these as json path definitions.</p> <p>If you query GitHub's API and take a look at the JSON response, you can see how these paths correspond to the data. Example URL if you want to see for yourself:</p> <p>https://api.github.com/repos/amterp/rad/commits?per_page=2</p> <p>Here's a simplified example response with two commits, showing the structure we're interested in:</p> <pre><code>[\n  {\n    \"sha\": \"306f3a4ddb3b09747d61a5eab264c3d72fbbc36e\",\n    \"commit\": {\n      \"author\": {\n        \"name\": \"Alexander Terp\",\n        \"date\": \"2025-01-11T04:15:06Z\"\n      }\n    }\n  },\n  {\n    \"sha\": \"2b642c482b32e4d87924839b2f5a9592670dee69\",\n    \"commit\": {\n      \"author\": {\n        \"name\": \"Alexander Terp\",\n        \"date\": \"2025-01-10T12:21:03Z\"\n      }\n    }\n  }\n]\n</code></pre> <p>You can see how the path for <code>Author = json[].commit.author.name</code> corresponds to a final value of \"Alexander Terp\".</p> <p>Json paths leverage a special syntax that Rad offers. They always start with <code>json</code>. <code>json</code> can be thought of as representing the JSON blob as a whole, or its root, if you want to think of the JSON data as a tree.</p> <p>The <code>[]</code> after <code>json</code> tells Rad that you expect the <code>json</code> blob to be a list, and to \"unwrap\" it and dig into individual items in that list for the remainder of the path. <code>commit</code> then tells it to look up a key of that name (literally <code>commit</code>), and to then look up <code>author</code> next, and then finally <code>name</code>.</p>"},{"location":"guide/rad-blocks/#basic-path-syntax-summary","title":"Basic Path Syntax Summary","text":"<p>The examples above demonstrate the core JSON path patterns you'll use most often:</p> <ul> <li>Dot notation: <code>json.field</code> or <code>json.commit.author.name</code> for nested fields</li> <li>Array unwrapping: <code>json[]</code> tells Rad to iterate through a list</li> <li>Combined: <code>json[].field.nested</code> extracts nested data from each array item</li> </ul> <p>Advanced JSON Path Features</p> <p>The JSON path syntax supports additional powerful features like wildcards (<code>json[].*</code>), indexed access (<code>json[0]</code>, <code>json.items[2]</code>), and multiple levels of array unwrapping (<code>json[].items[][].related[]</code>). We'll cover these in a later section: JSON Paths (Advanced).</p> <p>When a json path declaration is executed, its variable (<code>Author</code> for example) is initialized as an empty list. It's a \"special\" list though, as it has a json field definition tied to it, which can be used in a rad block, let's look at that one next.</p>"},{"location":"guide/rad-blocks/#rad-block","title":"Rad Block","text":"<pre><code>rad url:\n    fields Time, Author, SHA\n</code></pre> <p>Why 'rad'?</p> <p>The project name Rad comes from its original core use case: Request And Display. This workflow - querying data from APIs and displaying it in readable tables - is exactly what <code>rad</code> blocks are designed for. It's not just the project name, it's what the keyword does!</p> <p><code>rad</code> is a keyword that executes a \"Request And Display\" workflow.</p> <p>Following the <code>rad</code> keyword, we provide the <code>url</code> variable which will get used to execute an <code>HTTP GET</code> request. Then, inside the rad block itself, using the keyword <code>fields</code>, we specify the earlier json fields that we defined. Listing them here will tell the rad block to extract data from the resulting JSON blob according to the json field paths that you defined. The ordering in which the fields are listed also controls the ordering of columns in the ensuing table that gets printed.</p> <p>When run, this will print the table we saw earlier; here it is again for reference (with a limit of 3).</p> <pre><code>Time                  Author          SHA\n2025-01-11T04:15:06Z  Alexander Terp  306f3a4ddb3b09747d61a5eab264c3d72fbbc36e\n2025-01-11T03:07:56Z  Alexander Terp  304a914644dfd73a59b85a191481f9c429b4d25e\n2025-01-11T01:00:42Z  Alexander Terp  7171ec92ae729f9d04e224e16272c9b888dffe41\n</code></pre> <p>Note that the variable names we choose for the json field definitions become the header names in the table.</p>"},{"location":"guide/rad-blocks/#additional-rad-block-options","title":"Additional Rad Block Options","text":"<p>Rad blocks include options to control the resulting table.</p>"},{"location":"guide/rad-blocks/#sorting","title":"Sorting","text":"<p>By default, the rows in your table are sorted by their original order in the JSON blob. However, you can control this.</p> <p>Let's say we have the following table by default:</p> <pre><code>City         Country  Population\nLos Angeles  USA      3800000\nLondon       England  8800000\nHouston      USA      2300000\nCopenhagen   Denmark  640000\n</code></pre> <p>The simplest sorting option is alphabetically, across the whole row.</p> <pre><code>rad url:\n    fields City, Country, Population\n    sort\n</code></pre> <pre><code>City         Country  Population\nCopenhagen   Denmark  640000\nHouston      USA      2300000\nLondon       England  8800000\nLos Angeles  USA      3800000\n</code></pre> <p>What if we wanted to sort by Country, though? And then break ties with City? We can do that:</p> <pre><code>rad url:\n    fields City, Country, Population\n    sort Country, City\n</code></pre> <pre><code>City         Country  Population\nCopenhagen   Denmark  640000\nLondon       England  8800000\nHouston      USA      2300000\nLos Angeles  USA      3800000\n</code></pre> <p>If we wanted to sort by descending population, you can add <code>desc</code> after the name of the column:</p> <pre><code>rad url:\n    fields City, Country, Population\n    sort Population desc\n</code></pre> <pre><code>City         Country  Population\nLondon       England  8800000\nLos Angeles  USA      3800000\nHouston      USA      2300000\nCopenhagen   Denmark  640000\n</code></pre> <p>'asc' is the default</p> <p><code>sort City</code> and <code>sort City asc</code> are both valid and identical in functionality - you can include it if you want to be explicit.</p>"},{"location":"guide/rad-blocks/#mapping","title":"Mapping","text":"<p>You can also transform a column's values before it gets printed.</p> <p>For example, let's say you wanted the 'Population' column in the above example to be in millions, and to display one decimal place, you can do that with a <code>map</code> column modifier:</p> <pre><code>rad url:\n    fields City, Country, Population\n    Population:\n        map fn(p) \"{p/1e6:.1}\"\n</code></pre> <p>The syntax here is <code>map &lt;lambda&gt;</code>. In this example, the lambda is <code>fn(p) \"{p/1e6:.1}\"</code>.</p> <p>You can read about lambdas in an earlier section here: Functions: Lambdas.</p> <p>If we run this, you'll see the change:</p> <pre><code>City         Country  Population\nLos Angeles  USA      3.8\nLondon       England  8.8\nHouston      USA      2.3\nCopenhagen   Denmark  0.6\n</code></pre> <p>Let's break down this syntax more. After declaring the fields:</p> <pre><code>Population:\n    map fn(p) \"{p/1e6:.1}\"\n</code></pre> <p><code>Population:</code> begins a column modifier block. The identifier prior to the colon is expected to be one of the fields. Inside one of these blocks, you can apply modifiers on that column, such as <code>map</code> or <code>color</code>.</p> <p><code>map</code> is considered a keyword in the context of rad blocks. After <code>map</code>, a lambda expression is expected, which you can think of as a mini-function.</p> <p>In this case, we've written <code>fn(p) \"{p/1e6:.1}\"</code>. The lambda takes a variable <code>p</code> (name could be any valid identifier). This will represent an individual value in the <code>Population</code> list. The expression that follows is what will get evaluated and decide the final value in each cell. It is the output of your lambda mini-function. In this example, we turn it into a string, created using string interpolation.</p> <p>Inside the string interpolation expression, we first divide it by one million (<code>p/1e6</code>, using scientific notation), and then use formatting syntax (right of the colon) to specify that we want the resulting float to be stringified with one decimal place (<code>.1</code>).</p> <p>Modifier Execution Order</p> <p>Field modifiers execute in a specific order: filter \u2192 sort \u2192 map</p> <ul> <li>Filter first: Removes unwanted rows before sorting</li> <li>Sort middle: Sorts the filtered data in its original form</li> <li>Map last: Transforms values for display only</li> </ul> <p>This means sorting and filtering see the original extracted values, not the transformed display values from <code>map</code>.</p>"},{"location":"guide/rad-blocks/#filtering","title":"Filtering","text":"<p>You can also filter rows based on conditions. This is useful when you only want to display data that matches certain criteria.</p> <p>For example, let's say you're querying an API that returns users, but you only want to see active users over 18 years old:</p> <pre><code>rad url:\n    fields Name, Age, Status\n    Age:\n        filter fn(age) age &gt;= 18\n    Status:\n        filter fn(s) s == \"active\"\n</code></pre> <p>The syntax is <code>filter &lt;function&gt;</code>. The function receives each value from that column and returns a boolean (or truthy value). If it returns true, that row is kept. If false, the entire row is discarded.</p> <p>In this example, we're applying two filters:</p> <ul> <li><code>Age</code>: Keep only rows where age is 18 or greater</li> <li><code>Status</code>: Keep only rows where status equals \"active\"</li> </ul> <p>When multiple fields have filters, a row must pass all filters to be displayed (AND logic). In our example, both the age and status filters must pass.</p> <p>Let's see this in action with some mock data:</p> <pre><code>Ages = [25, 15, 30, 20, 12]\nNames = [\"Alice\", \"Bob\", \"Charlie\", \"Diana\", \"Eve\"]\nStatus = [\"active\", \"active\", \"inactive\", \"active\", \"active\"]\n\ndisplay:\n    fields Names, Ages, Status\n    Ages:\n        filter fn(a) a &gt;= 18\n    Status:\n        filter fn(s) s == \"active\"\n</code></pre> <pre><code>Names   Ages  Status\nAlice   25    active\nDiana   20    active\n</code></pre> <p>Notice that Charlie doesn't appear (age &gt;= 18 but status is inactive), Bob doesn't appear (active but age &lt; 18), and Eve doesn't appear (active but age &lt; 18).</p> <p>Like with sorting and mapping, the filter predicate can be a lambda expression or a function reference:</p> <pre><code>display:\n    fields Name, Age\n    Age:\n        filter is_adult\n\nfn is_adult(age):\n    return age &gt;= 18\n</code></pre> <p>Execution Order: filter \u2192 sort \u2192 map</p> <p>Filtering happens before sorting and mapping. This means: - Filters see the original extracted values (not transformed by <code>map</code>) - Sorting operates on already-filtered data - Mapping transforms the final filtered+sorted values for display</p> <p>This order ensures your filters work on raw data and your sorts only process rows that will actually be displayed.</p>"},{"location":"guide/rad-blocks/#color","title":"Color","text":"<p>Another column modifier uses the keyword <code>color</code>. You can tell Rad to color a cell's value depending on its contents by using a regex.</p> <p>For example:</p> <pre><code>rad url:\n    fields City, Country, Population\n    Country:\n        color \"pink\" \".*\"\n        color \"red\" \"Denmark\"\n        color \"blue\" \"USA\"\n</code></pre> <p>The syntax is <code>color &lt;color&gt; &lt;regex&gt;</code>. You can apply multiple rules, and later rules override earlier ones.  For example, here we start off by coloring everything pink. Then, we add three more rules: any sequence \"Denmark\" should be colored red, and \"USA\" should be colored blue.</p> <p></p> <p>This screenshot from a terminal demonstrates the colors. England is colored pink because the initial <code>.*</code> rule is the only regex that matched it.</p> <p>Note that the specific colors that appear varies between terminals and user settings.</p> <p>See the reference for a list of valid colors.</p>"},{"location":"guide/rad-blocks/#multi-column-modifiers","title":"Multi-Column Modifiers","text":"<p>You can apply the same modifiers to multiple columns at once by listing them together:</p> <pre><code>rad url:\n    fields Status, Priority, Assignee, DueDate\n    Status, Priority:\n        color \"green\" \"complete|high\"\n        color \"red\" \"blocked|low\"\n    Status, Priority, Assignee:\n        map fn(s) upper(s)\n</code></pre> <p>This example applies color rules to both <code>Status</code> and <code>Priority</code>, then transforms three columns to uppercase with a single <code>map</code> block. This is much more concise than writing separate modifier blocks for each column.</p> <p>Any column modifier (<code>filter</code>, <code>map</code>, <code>color</code>) can be applied to multiple columns this way.</p>"},{"location":"guide/rad-blocks/#if-statements","title":"If Statements","text":"<p>Rad blocks can contain if statements, so if you want slightly different behavior for your rad block based on some condition, you don't need to copy and paste the whole block into two separate if blocks.</p> <p>Let's say your script had a flag for sorting by population or not. Here's an example of how that could look:</p> <pre><code>args:\n    sort_by_population p bool  # Enable to sort by population.\n\n// ... some script stuff here\n\nrad url:\n    fields City, Country, Population\n    if sort_by_population:\n        sort Population desc\n    else:\n        sort\n</code></pre> <p>If the flag is enabled, we sort by descending population, otherwise we sort rows alphabetically.</p> <p>You can put any rad block statements into these if blocks, including <code>fields</code>, column modifiers, etc.</p>"},{"location":"guide/rad-blocks/#other-block-types","title":"Other Block Types","text":"<p>So far we've seen the <code>rad</code> block, which performs an HTTP request, extracts data, and displays it as a table. Rad also offers two variants that give you more control over this workflow: request blocks and display blocks.</p>"},{"location":"guide/rad-blocks/#request-no-display","title":"request: No Display","text":"<p>A request block is like a <code>rad</code> block, but it doesn't print a table. It performs the HTTP request and extracts fields into lists, then stops. This is useful when you want to process the data further before displaying it, or use it for something other than display.</p> <pre><code>request url:\n    fields City, Country, Population\n    sort Population desc\n\n// From here, the field lists are populated and sorted\n// City[0] is now the city with the largest population\nlargest_city = City[0]\nprint(\"The largest city is {largest_city}\")\n</code></pre> <p>Note that <code>filter</code>, <code>sort</code>, and <code>map</code> all work in request blocks since they modify the underlying data. However, <code>color</code> is display-only and has no effect since nothing gets displayed.</p>"},{"location":"guide/rad-blocks/#display-no-request","title":"display: No Request","text":"<p>A display block takes already-populated data and formats it as a table. It's the opposite of request blocks - no HTTP request is made, just formatting and display.</p> <p>Display with manual data:</p> <pre><code>Nums = [1, 2]\nWords = [\"hi\", \"hello\"]\ndisplay:\n    fields Nums, Words\n</code></pre> <pre><code>Nums  Words\n1     hi\n2     hello\n</code></pre> <p>Display with a data source:</p> <p>Display blocks can also take a variable containing JSON data (like the response from <code>http_get</code>). This is particularly useful when you need custom headers or authentication:</p> <pre><code>// Fetch data with custom headers\nresp = http_get(url, headers=my_headers)\n\n// Define JSON paths\nName = json[].name\nAge = json[].age\n\n// Display the data\ndisplay resp.body:\n    fields Name, Age\n    sort Age desc\n</code></pre>"},{"location":"guide/rad-blocks/#when-to-use-each","title":"When to Use Each","text":"<ul> <li><code>rad</code>: When you want to query and display in one step (most common case)</li> <li><code>request</code>: When you need to process data before displaying or use it for non-display purposes</li> <li><code>display</code>: When you have data from manual sources, <code>http_get()</code> with custom headers, or derived from <code>request</code> blocks</li> </ul> <p>Modifier Mutation Across Block Types</p> <p>Field modifiers like (<code>filter</code>, <code>sort</code>, <code>map</code>) may or may not mutate underlying data depending on the block type:</p> <ul> <li>In <code>rad</code> and <code>request</code> blocks: Permanently modify the field arrays</li> <li>In <code>display</code> blocks: Applied for rendering, but does not change underlying data.</li> </ul> <p>This means you can use <code>request</code> blocks to filter, sort, or transform data for further processing, while <code>display</code> blocks let you format data for viewing without altering the original values.</p>"},{"location":"guide/rad-blocks/#understanding-http-requests","title":"Understanding HTTP Requests","text":"<p>When you write <code>rad</code> or <code>request</code> blocks, Rad automatically performs an HTTP GET request to the URL and expects a JSON response. This happens behind the scenes - you don't need to explicitly call any HTTP functions.</p>"},{"location":"guide/rad-blocks/#headers-and-authentication","title":"Headers and Authentication","text":"<p>Currently, <code>rad</code> and <code>request</code> blocks don't support custom headers or authentication directly. If you need to add headers (for example, to authenticate with an API), use the <code>http_get</code> or <code>http_post</code> functions first, then pass the result to a <code>display</code> block:</p> <pre><code>args:\n    token str  # API authentication token\n\nheaders = {\n    \"Authorization\": \"Bearer {token}\",\n    \"Accept\": \"application/json\"\n}\n\nurl = \"https://api.github.com/user/repos\"\nresp = http_get(url, headers=headers)\n\n// Define JSON paths for the response\nName = json[].name\nStars = json[].stargazers_count\n\n// Display the data we fetched\ndisplay resp.body:\n    fields Name, Stars\n    sort Stars desc\n</code></pre> <p>This pattern gives you full control over the HTTP request while still leveraging rad blocks for data extraction and display.</p>"},{"location":"guide/rad-blocks/#summary","title":"Summary","text":"<ul> <li>Rad blocks make working with JSON APIs concise and declarative - request, extract, and display data in just a few lines</li> <li>Three block types serve different needs:<ul> <li><code>rad url:</code> - Request and display in one step</li> <li><code>request url:</code> - Request and extract data without displaying</li> <li><code>display:</code> - Display already-populated data as a table</li> </ul> </li> <li>JSON field definitions use special path syntax to extract data from JSON responses<ul> <li>Basic patterns: <code>json.field</code>, <code>json[]</code>, <code>json[].nested.path</code></li> <li>Advanced features exist (wildcards, indexing) for complex extraction needs</li> </ul> </li> <li>Table customization options:<ul> <li>Filtering: Remove rows based on conditions</li> <li>Sorting: <code>sort</code>, <code>sort Field</code>, <code>sort Field desc</code></li> <li>Transforming: Map functions to modify column values</li> <li>Styling: Color cells based on regex patterns</li> <li>Multi-column: Apply same modifiers to multiple columns at once</li> <li>Conditional: Use <code>if</code> statements for dynamic behavior</li> <li>Execution order: filter \u2192 sort \u2192 map</li> </ul> </li> <li>HTTP control: rad blocks perform GET automatically; use <code>http_get()</code>/<code>http_post()</code> with <code>display</code> for more advanced queries (e.g. requiring headers/auth)</li> </ul>"},{"location":"guide/rad-blocks/#next","title":"Next","text":"<p>Next, we'll cover an important concept for keeping your scripts maintainable: Type Annotations.</p>"},{"location":"guide/resources/","title":"Resources","text":"<p>Depending on your script, you may wish to look up values at some point, such as URL endpoints depending on your input. Rad offers a function for this, <code>pick_from_resource</code>, but before we dive into it, we'll first cover a couple of related functions.</p>"},{"location":"guide/resources/#pick","title":"<code>pick</code>","text":"<p><code>pick</code> is an in-built function which allows you to choose one value from a list of inputs, using some filter. If the filter has several matches, Rad will enter an interactive mode which allows the user to pick a single value to continue with.</p> <p>You can try it yourself with this example:</p> <pre><code>options = [\"chicken burger\", \"chicken sandwich\", \"ham sandwich\"]\noutput = pick(options, \"sandwich\")\nprint(\"You chose: {output}\")\n</code></pre> <p>When you initially run this, the <code>sandwich</code> filter should exclude <code>chicken burger</code> and ask you to select between two remaining options:</p> <pre><code>\u2503 Pick an option\n\u2503 &gt; chicken sandwich\n\u2503   ham sandwich\n</code></pre> <p>After you choose, you get the final output:</p> <pre><code>You chose: chicken sandwich\n</code></pre>"},{"location":"guide/resources/#pick_kv","title":"<code>pick_kv</code>","text":"<p>A similar function is <code>pick_kv</code>. However, instead of the values you're filtering and picking between also being the output, <code>pick_kv</code> performs the filtering/picking on a list of keys, each which map to a value that will get output from the function if its associated key is picked. For example:</p> <pre><code>keys = [\"chicken burger\", \"chicken sandwich\", \"ham sandwich\"]\nvalues = [\"CHICKEN\", \"CHICKEN\", \"HAM\"]\n\noutput = pick_kv(keys, values)\n\nprint(\"We'll need {output}!\")\n</code></pre> <p>In this example, we leave out the filter, as it's optional, which will launch us into an interactive select between all the key values:</p> <pre><code>\u2503 Pick an option\n\u2503   chicken burger\n\u2503   chicken sandwich\n\u2503 &gt; ham sandwich\n</code></pre> <p>If we pick this third option, this is the final output of the script:</p> <pre><code>We'll need HAM!\n</code></pre> <p>Notice that the function did not output the key <code>ham sandwich</code> that was selected, but instead the value <code>HAM</code> that it mapped to.</p>"},{"location":"guide/resources/#pick_from_resource","title":"<code>pick_from_resource</code>","text":"<p>Now we'll look at actually using what this section is about - resources. <code>pick_from_resource</code> allows you to pre-define a resource file (using JSON) which contains a range of key-value pairs. When invoked, it will behave similarly to the two previous <code>pick</code> functions i.e. it lets you apply an optional filter, and will launch into an interactive picking mode to narrow down a single choice, if needed.</p> <p>Let's do a simple example. As mentioned, a resource file is simply a JSON file. We'll create an example where we look up a url based on user input:</p> websites.json<pre><code>{\n  \"options\": [\n    {\n      \"keys\": [\"gl\", \"lab\"],\n      \"values\": [\"gitlab.com\", \"GitLab\"]\n    },\n    {\n      \"keys\": [\"gh\", \"hub\"],\n      \"values\": [\"github.com\", \"GitHub\"]\n    }\n  ]\n}\n</code></pre> <p>You may see some similarity here to what we did with <code>pick_kv</code>. We're defining two options: one which can get matched by either <code>gl</code> or <code>lab</code>, and one which gets matched by <code>gh</code> or <code>hub</code>. In the first case, if chosen, <code>pick_from_resource</code> will return two values: <code>gitlab.com</code> and <code>GitLab</code>. Similarly it will return <code>github.com</code> and <code>GitHub</code> for the latter.</p> <p>Let's create a Rad script to use this resource:</p> example.rad<pre><code>args:\n    website str = \"\"\n\nurl, name = pick_from_resource(\"./resources/websites.json\", website)\nprint(\"url: {url}, name: {name}\")\n</code></pre> <p>Note that the first argument to <code>pick_from_resource</code> is a path to a resource file. This path is relative to the script's path. This allows you to store your resources with your scripts. In this example, we'll place our files like so:</p> <pre><code>.\n\u251c\u2500\u2500 example.rad\n\u2514\u2500\u2500 resources\n    \u2514\u2500\u2500 websites.json\n</code></pre> <p>This means that it doesn't matter where on your computer you invoke your script from including if it's on your PATH - the script will consistently look in the same spot for resource files.</p> <p>TBC</p>"},{"location":"guide/resources/#summary","title":"Summary","text":"<ul> <li><code>pick</code> and <code>pick_kv</code> are built-in functions that allow users to select one option from many, allowing for an optional filter.</li> <li><code>pick_from_resource</code> is similar, but uses a pre-defined resource file to define the options.</li> <li>The resource file is defined in JSON.</li> <li>The resource file path can be defined relative to the script's path.</li> </ul>"},{"location":"guide/resources/#next","title":"Next","text":"<p>The shell offers a ton of useful utilities, and Rad allows you to leverage them from within your scripts.</p> <p>We'll look at that in the next section: Shell Commands.</p>"},{"location":"guide/script-commands/","title":"Script Commands","text":"<p>When you think of powerful CLI tools - <code>git</code>, <code>docker</code>, <code>kubectl</code> - they all share a common pattern: they're organized around commands. You don't just run <code>git</code> with flags; you run <code>git commit</code>, <code>git push</code>, <code>git branch</code> - each a distinct operation with its own arguments.</p> <p>Rad lets you build tools like this through first-class command support. You can define multiple commands in a single script, each with their own arguments and implementation.</p>"},{"location":"guide/script-commands/#basic-syntax","title":"Basic Syntax","text":"<p>Let's start with a very simple example:</p> <pre><code>#!/usr/bin/env rad\n\ncommand greet:\n    name str\n    calls greet_user\n\nfn greet_user():\n    print(\"Hello, {name}!\")\n</code></pre> <p>This script defines a single command called <code>greet</code> that takes a <code>name</code> argument.</p> <p>Invoke it by specifying the command name followed by its arguments:</p> <pre><code>&gt; ./script.rad greet Alice\n</code></pre> <pre><code>Hello, Alice!\n</code></pre> <p>Let's break down the syntax:</p> <ol> <li><code>command greet:</code> - Defines a command named <code>greet</code></li> <li><code>name str</code> - The command takes one required string argument called <code>name</code></li> <li><code>calls greet_user</code> - Specifies which function to execute when this command runs</li> <li><code>fn greet_user():</code> - Defines the function that implements the command logic (defined after commands)</li> </ol> <p>Command arguments (like <code>name</code>) become script-wide variables, accessible throughout your script.</p>"},{"location":"guide/script-commands/#multiple-commands","title":"Multiple Commands","text":"<p>The power of commands emerges when you define several in one script. Let's create a simple deployment tool:</p> <pre><code>#!/usr/bin/env rad\n\ncommand deploy:\n    env str\n    calls do_deploy\n\ncommand status:\n    env str\n    calls do_status\n\nfn do_deploy():\n    print(\"Deploying to {env}...\".yellow())\n    print(\"Deployment complete!\".green())\n\nfn do_status():\n    print(\"Checking status of {env}...\".yellow())\n    print(\"Environment {env} is healthy\".green())\n</code></pre> <p>Now you can invoke either command:</p> <pre><code>&gt; ./tool.rad deploy staging\n</code></pre> <pre><code>Deploying to staging...\nDeployment complete!\n</code></pre> <pre><code>&gt; ./tool.rad status production\n</code></pre> <pre><code>Checking status of production...\nEnvironment production is healthy\n</code></pre> <p>Each command has its own arguments and implementation, but they live in the same script and can share code.</p>"},{"location":"guide/script-commands/#adding-descriptions","title":"Adding Descriptions","text":"<p>Commands should include descriptions to make your tool self-documenting. Use the familiar <code>--- ... ---</code> header syntax:</p> <pre><code>#!/usr/bin/env rad\n\ncommand deploy:\n    ---\n    Deploy the application to an environment\n    ---\n    env str\n    calls do_deploy\n\ncommand status:\n    ---\n    Check the health of an environment\n    ---\n    env str\n    calls do_status\n\nfn do_deploy():\n    print(\"Deploying to {env}...\".yellow())\n\nfn do_status():\n    print(\"Environment {env} is healthy\".green())\n</code></pre> <p>These descriptions appear in the help output:</p> <pre><code>&gt; ./tool.rad -h\n</code></pre> <pre><code>Usage:\n  tool.rad [command] [OPTIONS]\n\nCommands:\n  deploy    Deploy the application to an environment\n  status    Check the health of an environment\n</code></pre> <p>Notice how Rad automatically generates a usage string listing all available commands.</p> <p>Multi-line descriptions</p> <p>Just like script headers, command descriptions can span multiple lines:</p> <pre><code>command deploy:\n    ---\n    Deploy the application to an environment.\n    This will build, test, and deploy your application.\n    ---\n</code></pre> <p>Important: The first line appears in the script's overall help output, so keep it concise. Additional lines only appear when you request help for that specific command (<code>./tool.rad deploy -h</code>).</p>"},{"location":"guide/script-commands/#command-arguments","title":"Command Arguments","text":"<p>Each command can define its own arguments using the same syntax you learned in Args. Let's expand our deployment tool:</p> <pre><code>#!/usr/bin/env rad\n\ncommand deploy:\n    ---\n    Deploy the application to an environment\n    ---\n    env str              # Environment to deploy to\n    branch str = \"main\"  # Branch to deploy from\n    skip_tests bool      # Skip running tests before deploy\n    calls do_deploy\n\nfn do_deploy():\n    if skip_tests:\n        print(\"\u26a0\ufe0f  Skipping tests\".yellow())\n    else:\n        print(\"Running tests...\".yellow())\n\n    print(\"Deploying {branch} to {env}...\".yellow())\n    print(\"\u2705 Deployment complete!\".green())\n</code></pre> <p>The arguments work exactly as they do in the <code>args:</code> block - you can use defaults, optional types, constraints, and comments for help text.</p> <p>Invoke with positional arguments:</p> <pre><code>&gt; ./tool.rad deploy staging feature-branch\n</code></pre> <pre><code>Running tests...\nDeploying feature-branch to staging...\n\u2705 Deployment complete!\n</code></pre> <p>Or use flags (especially for booleans):</p> <pre><code>&gt; ./tool.rad deploy --env=production --skip-tests\n</code></pre> <pre><code>\u26a0\ufe0f  Skipping tests\nDeploying main to production...\n\u2705 Deployment complete!\n</code></pre>"},{"location":"guide/script-commands/#shared-args","title":"Shared Args","text":"<p>Often you want arguments that apply to all commands - like a <code>--verbose</code> flag or a <code>--config</code> path. Define these in an <code>args:</code> block to share them across commands:</p> <pre><code>#!/usr/bin/env rad\n\nargs:\n    verbose v bool   # Enable verbose output\n    config str = \"~/.config/tool.yaml\"\n\ncommand deploy:\n    ---\n    Deploy the application\n    ---\n    env str\n    calls do_deploy\n\ncommand status:\n    ---\n    Check environment status\n    ---\n    env str\n    calls do_status\n\nfn do_deploy():\n    if verbose:\n        print(\"Config: {config}\".yellow())\n        print(\"Deploying to {env}...\".yellow())\n    print(\"\u2705 Deployed!\".green())\n\nfn do_status():\n    if verbose:\n        print(\"Config: {config}\".yellow())\n        print(\"Checking {env}...\".yellow())\n    print(\"Environment healthy\".green())\n</code></pre> <p>Shared args are available to all commands:</p> <pre><code>&gt; ./tool.rad deploy staging --verbose\n</code></pre> <pre><code>Config: ~/.config/tool.yaml\nDeploying to staging...\n\u2705 Deployed!\n</code></pre> <pre><code>&gt; ./tool.rad status production --verbose\n</code></pre> <pre><code>Config: ~/.config/tool.yaml\nChecking production...\nEnvironment healthy\n</code></pre> <p>Shared args are flag-only</p> <p>When commands exist, shared args can only be passed as flags (like <code>--verbose</code>, <code>-v</code>, or <code>--config=value</code>), not positionally. This keeps the invocation clear: the first positional argument is always the command name.</p> <p>Both long form (<code>--verbose</code>) and short form (<code>-v</code>) work for shared args.</p> <p>Command-specific args can be positional or flags, just like regular script args.</p>"},{"location":"guide/script-commands/#command-callbacks","title":"Command Callbacks","text":"<p>We've been using function references (<code>calls on_deploy</code>), which is the recommended approach for most commands. However, for very short implementations, you can also use inline lambdas:</p> <pre><code>#!/usr/bin/env rad\n\ncommand deploy:\n    ---\n    Deploy the application\n    ---\n    env str\n    calls on_deploy\n\ncommand rollback:\n    ---\n    Rollback a deployment\n    ---\n    env str\n    calls fn():\n        print(\"Rolling back {env}...\".yellow())\n        print(\"\u2705 Rollback complete!\".green())\n\nfn on_deploy():\n    print(\"Deploying to {env}...\".yellow())\n    print(\"\u2705 Done!\".green())\n</code></pre>"},{"location":"guide/script-commands/#shared-logic","title":"Shared Logic","text":"<p>You can write code after all command blocks that runs before any callback is invoked. This is useful for setup logic that all commands need:</p> <pre><code>#!/usr/bin/env rad\n\ncommand deploy:\n    env str\n    calls on_deploy\n\ncommand rollback:\n    env str\n    calls on_rollback\n\n// This runs before any callback\nprint(\"Initializing...\".yellow())\nconfig = read_file(\"config.yaml\")\nprint(\"Config loaded\".green())\n\nfn on_deploy():\n    // config is available here\n    print(\"Deploying to {env} using config...\")\n\nfn on_rollback():\n    // config is available here too\n    print(\"Rolling back {env}...\")\n</code></pre> <p>When you run <code>./script.rad deploy staging</code>, the flow is:</p> <ol> <li>Parse arguments</li> <li>Run shared logic (lines 12-14)</li> <li>Run the callback (<code>on_deploy</code>)</li> </ol> <p>This pattern is useful for loading configuration files, setting up connections, or validating preconditions that apply to all commands.</p>"},{"location":"guide/script-commands/#getting-help","title":"Getting Help","text":"<p>Rad automatically generates help documentation for your commands. There are two levels of help:</p> <p>Script-level help shows all available commands:</p> <pre><code>&gt; ./tool.rad -h\n</code></pre> <pre><code>Usage:\n  tool.rad [command] [OPTIONS]\n\nCommands:\n  deploy      Deploy the application\n  rollback    Rollback a deployment\n  status      Check environment status\n</code></pre> <p>Command-level help shows arguments for a specific command:</p> <pre><code>&gt; ./tool.rad deploy -h\n</code></pre> <pre><code>Deploy the application\n\nUsage:\n  deploy &lt;env&gt; [branch] [OPTIONS]\n\nCommand args:\n      --env str       Environment to deploy to\n      --branch str    Branch to deploy from (default \"main\")\n      --skip-tests    Skip running tests before deploy\n  -v, --verbose       Enable verbose output\n      --config str    (default \"~/.config/tool.yaml\")\n</code></pre> <p>Notice how the help includes:</p> <ul> <li>The command description</li> <li>Required and optional arguments</li> <li>Default values</li> <li>Shared args (like <code>--verbose</code> and <code>--config</code>)</li> <li>Help text from <code>#</code> comments</li> </ul>"},{"location":"guide/script-commands/#practical-example","title":"Practical Example","text":"<p>Here's a concise, realistic example that demonstrates the \"dev script\" pattern - a common use case for replacing messy <code>Makefile</code>s or complex <code>package.json</code> script sections with a single, readable CLI entry point.</p>"},{"location":"guide/script-commands/#dev-script","title":"Dev Script","text":"<p>Instead of remembering different commands for building, testing, and running your project, you can wrap them in a single <code>dev.rad</code> script. This demonstrates shared arguments, boolean flags, and how to pass arguments down to underlying tools:</p> <pre><code>#!/usr/bin/env rad\n---\nFacilitates working with this repo's project.\n---\n\nargs:\n    verbose v bool   # Enable verbose output\n\ncommand start:\n    ---\n    Start the local development server\n    ---\n    port int = 3000    # Port to listen on\n    detach d bool      # Run in background\n    calls on_start\n\ncommand test:\n    ---\n    Run the test suite\n    ---\n    grep str?      # Filter tests by name\n    watch w bool   # Re-run on file changes\n    calls on_test\n\ncommand build:\n    ---\n    Compile for production\n    ---\n    calls on_build\n\n// Shared setup logic runs before any callback\nif verbose:\n    print(\"Checking project structure...\".yellow())\n\nif not path_exists(\"package.json\"):\n    print_err(\"Error: package.json not found\".red())\n    print_err(\"Run this script from the project root\".yellow())\n    exit(1)\n\nfn on_start():\n    print(\"\ud83d\ude80 Starting server on http://localhost:{port}...\")\n\n    cmd = \"npm start -- --port {port}\"\n\n    if detach:\n        $`{cmd} &amp;`\n        print(\"Server started in background\".green())\n    else:\n        $`{cmd}`\n\nfn on_test():\n    opts = \"\"\n    if watch:\n        opts = \"{opts} --watch\"\n    if grep: \n        opts = \"{opts} -t '{grep}'\"\n\n    if verbose:\n        print(\"Running: pytest {opts}\".yellow())\n\n    print(\"\ud83e\uddea Running tests...\")\n    $`pytest {opts}` catch:\n        print_err(\"Tests failed!\".red())\n        exit(1)\n\nfn on_build():\n    print(\"\ud83d\udce6 Building for production...\".yellow())\n\n    $`rm -rf ./dist`\n    $`npm run build` catch:\n        print_err(\"Build failed\".red())\n        exit(1)\n\n    print(\"\u2705 Build complete in ./dist\".green())\n</code></pre> <p>Usage:</p> <pre><code>&gt; ./dev.rad start\n\ud83d\ude80 Starting server on http://localhost:3000...\n\n&gt; ./dev.rad start --port 8080 --detach\n\ud83d\ude80 Starting server on http://localhost:8080...\nServer started in background\n\n&gt; ./dev.rad test --grep \"login_flow\" --watch\n\ud83e\uddea Running tests...\n\n&gt; ./dev.rad build\n\ud83d\udce6 Building for production...\n\u2705 Build complete in ./dist\n</code></pre> <p>Notice how this example uses:</p> <ul> <li>Shared args (<code>--verbose</code>) available to all commands</li> <li>Command-specific arguments with defaults (<code>port</code>, <code>detach</code>, <code>grep</code>, <code>watch</code>)</li> <li>Shared logic that runs before any callback</li> <li>Function references for callbacks (<code>calls on_start</code>, etc.)</li> <li>Integration with shell commands to wrap existing tools</li> <li>Clear, self-documenting help text</li> </ul>"},{"location":"guide/script-commands/#summary","title":"Summary","text":"<ul> <li>Script commands partition scripts into operations using <code>command name:</code> blocks</li> <li>Each command has:<ul> <li>Its own arguments (using standard <code>args</code> syntax)</li> <li>A description block (<code>--- ... ---</code>)</li> <li>A callback implementation (function reference or inline lambda)</li> </ul> </li> <li>Shared args (from <code>args:</code> block) are available to all commands<ul> <li>Must be passed as flags when commands exist</li> </ul> </li> <li>Shared logic runs before any callback. Write code after command blocks for setup that all commands need.</li> <li>Help is automatic:<ul> <li><code>./script -h</code> lists available commands</li> <li><code>./script command -h</code> shows command-specific help</li> </ul> </li> <li>Callbacks:<ul> <li>Function references: <code>calls function_name</code> (recommended)</li> <li>Inline lambdas: <code>calls fn():</code> (for short implementations)</li> </ul> </li> <li>Use script commands to build CLI tools, not just scripts</li> </ul>"},{"location":"guide/script-commands/#next","title":"Next","text":"<p>Rad provides a powerful system for looking up values from predefined resource files, which is particularly useful for building interactive tools.</p> <p>We'll explore this in the next section: Resources.</p>"},{"location":"guide/shell-commands/","title":"Shell Commands","text":"<p>The shell offers a wide range of utilities and is essential for CLI scripting - from file operations to invoking installed programs like git, make, or docker.</p> <p>Rad has rich built-in functionality (<code>http_get</code>, <code>read_file</code>, <code>write_file</code>, etc.), but sometimes you need to invoke system tools or installed programs. Rad makes this safe and ergonomic through first-class shell command support.</p>"},{"location":"guide/shell-commands/#invoking-commands","title":"Invoking Commands","text":"<p>Shell commands are invoked by prefixing a string with <code>$</code>:</p> <pre><code>$`ls -la`\n</code></pre> <p>You can also pre-define the command as a string variable:</p> <pre><code>cmd = `ls -la`\n$cmd\n</code></pre> <p>By default, the stdout/stderr will be printed directly to the user's terminal as if they had invoked it directly themselves.</p> <p>Prefer backticks for shell command strings</p> <p>Shell commands often use 'single' and \"double\" quotes, so backticks minimize delimiter conflicts. However, you can use any string delimiter.</p>"},{"location":"guide/shell-commands/#capturing-output","title":"Capturing Output","text":"<p>Shell commands return three values: exit code, stdout, and stderr. You can capture anywhere from zero to all three of these values, depending on what you need.</p>"},{"location":"guide/shell-commands/#capture-modes","title":"Capture Modes","text":"<p>There are four levels of capture:</p> <p>1. No capture - output goes to terminal</p> <p>When you don't assign any variables, all output goes to the terminal:</p> <pre><code>$`ls -la`\n</code></pre> <p>2. Capture exit code only</p> <p>Assign to one variable to capture just the exit code:</p> <pre><code>code = $`make test`\n</code></pre> <p>The exit code is captured as an <code>int</code>, but stdout and stderr still go to the terminal.</p> <p>3. Capture exit code + stdout</p> <p>Assign to two variables to capture the exit code and stdout:</p> <pre><code>code, stdout = $`git show 0dd21e6`\n</code></pre> <p>The exit code and stdout are captured as an <code>int</code> and <code>str</code> respectively. Stderr still goes to the terminal. Important: When you capture stdout, it doesn't print to the terminal - it's redirected to your variable.</p> <p>4. Capture all three</p> <p>Assign to three variables to capture everything:</p> <pre><code>code, stdout, stderr = $`npm install`\n</code></pre> <p>All three values are captured. Nothing is printed to the terminal automatically.</p>"},{"location":"guide/shell-commands/#named-assignment","title":"Named Assignment","text":"<p>Rad supports a special form of assignment when working with shell commands. When all your variables are named exactly <code>code</code>, <code>stdout</code>, or <code>stderr</code>, then assignment happens by name rather than by position. This means the order doesn't matter:</p> <pre><code>// Named assignment - order independent\nstdout, code = $`echo hi`           // code=0, stdout=\"hi\\n\"\nstderr = $`bad-command`             // Just capture stderr\ncode, stderr = $`make format`       // code=1, stderr=\"\"\nstderr, stdout, code = $`ls`        // All three, any order\n</code></pre> <p>This improves readability - you can capture exactly what you need with clear, self-documenting variable names.</p> <p>The rule: If ALL variables use exactly <code>code</code>, <code>stdout</code>, or <code>stderr</code>, assignment is by name. Otherwise, it's positional:</p> <pre><code>// Positional - 'output' isn't a special name\ncode, output = $`echo hi`           // output = stdout (by position)\nexit_code, out, err = $`ls`         // Assigned in order\n</code></pre> <p>This lets you write clear code like <code>stderr = $cmd</code> instead of <code>_, _, stderr = $cmd</code>.</p> <p>Silencing outputs</p> <p>You can use <code>_</code> to ignore specific outputs: <code>code, _ = $cmd</code> captures the code and ignores stdout. For silent execution, capture everything: <code>_, _, _ = $cmd</code> - nothing will print to the terminal.</p>"},{"location":"guide/shell-commands/#error-handling","title":"Error Handling","text":"<p>Now that you understand how to capture output, let's talk about error handling.</p> <p>When a shell command exits with a non-zero exit code, it triggers error propagation - just like functions that return errors. This means you can handle potential failures using <code>catch:</code> blocks:</p> <pre><code>// Handle errors with catch block\n$`make build` catch:\n    print_err(\"Build failed!\".red())\n    exit(1)\n\n// Or ignore failures\n$`make build` catch:\n    pass  // Continue on failure\n</code></pre> <p>You can combine capturing with error handling. When the <code>catch:</code> block runs, your variables are already assigned their actual values, so you can inspect them:</p> <pre><code>// Capture the exit code AND handle errors\ncode = $`make test` catch:\n    print_err(\"Command failed to run. Error code {code}\")\n    exit(1)\n\nprint(\"Tests passed!\")\n</code></pre> <p>This works with any capture pattern:</p> <pre><code>code, stdout = $`git tag --list` catch:\n    print_err(\"Failed to get tags\")\n    exit(1)\n\nversion = stdout.trim()\n</code></pre> <p>This uses the same error model covered in Error Handling - errors propagate by default, so you need <code>catch:</code> blocks to handle them.</p>"},{"location":"guide/shell-commands/#string-interpolation","title":"String Interpolation","text":"<p>You can build commands dynamically using string interpolation:</p> <pre><code>args:\n    version str\n    message str\n\n// Interpolate variables into commands\n$`git tag v{version}` catch:\n    print_err(\"Failed to create tag\")\n    exit(1)\n\n$`git commit -m \"{message}\"` catch:\n    print_err(\"Commit failed\")\n    exit(1)\n</code></pre> <p>This is particularly useful for constructing commands based on script arguments or other runtime values.</p>"},{"location":"guide/shell-commands/#modifiers","title":"Modifiers","text":"<p>Rad provides two modifiers that can be applied to shell commands.</p>"},{"location":"guide/shell-commands/#the-quiet-modifier","title":"The <code>quiet</code> Modifier","text":"<p>By default, Rad announces each shell command with a \u26a1\ufe0f prefix. For example, this command:</p> <pre><code>$`touch hello.txt` catch:\n    print_err(\"Failed to create file\")\n    exit(1)\n</code></pre> <p>Shows in the terminal:</p> <pre><code>\u26a1\ufe0f touch hello.txt\n</code></pre> <p>To suppress this announcement, use the <code>quiet</code> modifier:</p> <pre><code>quiet $`touch hello.txt` catch:\n    print_err(\"Failed to create file\")\n    exit(1)\n</code></pre> <pre><code>(no output - unless there's an error)\n</code></pre> <p>This is useful for scripts that run many commands or when you want minimal output.</p>"},{"location":"guide/shell-commands/#the-confirm-modifier","title":"The <code>confirm</code> Modifier","text":"<p>The <code>confirm</code> modifier prompts the user before running a command:</p> <pre><code>confirm $`rm -rf node_modules`\n</code></pre> <p>This is particularly useful for destructive operations.</p>"},{"location":"guide/shell-commands/#practical-examples","title":"Practical Examples","text":"<p>Let's look at some real-world patterns that combine these features.</p>"},{"location":"guide/shell-commands/#development-workflow","title":"Development Workflow","text":"<p>Here's a script inspired by a typical development workflow:</p> <pre><code>---\nValidates code, checks git status, and optionally pushes changes.\n---\nargs:\n    push p bool  # Push changes after validation\n\n// Run validation steps\nsteps = [\"go mod tidy\", \"make format\", \"make build\", \"make test\"]\n\nfor step in steps:\n    $step catch:\n        print_err(\"\u274c {step} failed\".red())\n        exit(1)\n    print(\"\u2705 {step} passed\".green())\n\nif push:\n    // Check for uncommitted changes\n    stdout = $`git status --porcelain` catch:\n        print_err(\"Failed to check git status\")\n        exit(1)\n\n    if stdout.trim() != \"\":\n        print_err(\"Working directory has uncommitted changes!\")\n        print_err(\"Commit your changes before pushing.\")\n        exit(1)\n\n    // Get current branch and push\n    stdout = $`git branch --show-current` catch:\n        print_err(\"Failed to get current branch\")\n        exit(1)\n\n    branch = stdout.trim()\n    print(\"Pushing to {branch}...\".yellow())\n\n    $`git push origin {branch}` catch:\n        print_err(\"Push failed\")\n        exit(1)\n\n    print(\"\u2705 Pushed to {branch}\".green())\n\nprint(\"\u2705 Done!\".green())\n</code></pre>"},{"location":"guide/shell-commands/#conditional-construction","title":"Conditional Construction","text":"<p>Building commands dynamically based on script arguments:</p> <pre><code>args:\n    verbose v bool\n    output o str?\n\ncmd = \"docker build .\"\n\nif verbose:\n    cmd += \" --progress=plain\"\n\nif output:\n    cmd += \" -t {output}\"\n\n$`{cmd}` catch:\n    print_err(\"Docker build failed\")\n    exit(1)\n\nprint(\"Docker image built successfully\".green())\n</code></pre>"},{"location":"guide/shell-commands/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>Verifying that required tools are installed:</p> <pre><code>tools = [\"git\", \"docker\", \"make\"]\n\nfor tool in tools:\n    _, _, _ = $`which {tool}` catch:\n        print_err(\"Required tool not found: {tool}\")\n        print_err(\"Please install {tool} before running this script\")\n        exit(1)\n\nprint(\"All prerequisites installed \u2705\".green())\n</code></pre>"},{"location":"guide/shell-commands/#summary","title":"Summary","text":"<ul> <li>Shell commands use the <code>$</code> prefix and follow the same error model as functions</li> <li>Error handling: Non-zero exit codes propagate errors unless handled with <code>catch:</code> blocks</li> <li>Capture modes:<ul> <li>None: output goes to terminal</li> <li>Code only: <code>code = $cmd</code> (stdout/stderr to terminal)</li> <li>Code + stdout: <code>code, stdout = $cmd</code> (stderr to terminal)</li> <li>All three: <code>code, stdout, stderr = $cmd</code> (nothing to terminal)</li> </ul> </li> <li>Assignment semantics:<ul> <li>Named when ALL variables are <code>code</code>, <code>stdout</code>, or <code>stderr</code> (order-independent)</li> <li>Positional otherwise (order matters)</li> </ul> </li> <li>Output routing: Captured values don't print to the terminal (they're redirected to variables)</li> <li>String interpolation works in commands for dynamic construction</li> <li>Backticks are preferred for shell command strings to avoid delimiter conflicts</li> </ul>"},{"location":"guide/shell-commands/#next","title":"Next","text":"<p>Shell commands let you invoke external programs, but what if you want to organize your script into multiple operations - like <code>git commit</code>, <code>docker build</code>, or <code>kubectl apply</code>?</p> <p>That's where commands come in. We'll explore them in the next section: Script Commands.</p>"},{"location":"guide/strings-advanced/","title":"Strings (Advanced)","text":"<p>Strings are everywhere in scripting - from building messages to formatting output. In the Basics section, we covered simple string operations, but Rad offers much more powerful features for working with text.</p> <p>In this section, we'll explore:</p> <ul> <li>String interpolation - embed expressions directly in strings</li> <li>Formatting - control how values are displayed (padding, precision, thousands separators)</li> <li>Multiline strings - work with text spanning multiple lines</li> <li>Raw strings - disable interpolation and escaping when you need literal text</li> <li>Escape sequences - include special characters like newlines and tabs</li> <li>String attributes - add color, bold, and other terminal styling</li> </ul> <p>These features make it easy to generate well-formatted output, build complex strings, and create polished CLI experiences.</p>"},{"location":"guide/strings-advanced/#string-interpolation","title":"String Interpolation","text":"<p>Rad allows embedding expressions inside your strings that will get evaluated and replaced to produce the 'final' string.</p> <p>Some examples:</p> <pre><code>name = \"Alice\"\nprint(\"Hi, {name}!\")\n\nprint(\"Uppercase: {name.upper()}\")\n\nprint(\"Conditions: {name.len() &gt; 5 ? 'long name' : 'short name'}!\")\n</code></pre> <pre><code>Hi, Alice!\nUppercase: ALICE\nConditions: short name!\n</code></pre> <p>String interpolation expressions can be as simple as just an identifier, or can involve function calls, math, list comprehensions, etc (though you should consider extracting complex expressions into named variables beforehand for the sake of clarity).</p> <p>Note the use of single quote <code>'</code> strings inside the last line of the above example. Using double quotes would've closed the \"outer\" string prematurely, but using another delimiter allows us to avoid that without also needing to escape anything.</p>"},{"location":"guide/strings-advanced/#formatting","title":"Formatting","text":"<p>You can format expression results while doing string interpolation. To do so, follow your expression with a colon <code>:</code> and then the relevant syntax for the formatting you want to do. We'll demonstrate through some examples:</p> <pre><code>pi = 3.14159265359\n\nprint(\"Pi: {pi}_\")       // no formatting\nprint(\"Pi: {pi:20}_\")    // left-pad to 20 places (default)\nprint(\"Pi: {pi:&lt;20}_\")   // right-pad to 20 places\nprint(\"Pi: {pi:.3}_\")    // print to 3 decimal places\nprint(\"Pi: {pi:10.2}_\")  // left-pad to 10 places, including 2 decimal places\n</code></pre> <pre><code>Pi: 3.14159265359_\nPi:             3.141593_\nPi: 3.141593            _\nPi: 3.142_\nPi:       3.14_\n</code></pre>"},{"location":"guide/strings-advanced/#thousands-separator","title":"Thousands Separator","text":"<p>For large numbers, you can add comma separators using <code>,</code> in your formatting:</p> <pre><code>population = 1234567\nprice = 1234.56\n\nprint(\"Population: {population:,}\")\nprint(\"Price: {price:,.2}\")\nprint(\"Large: {population:20,.0}\")  // combine padding, comma, and precision\n</code></pre> <pre><code>Population: 1,234,567\nPrice: 1,234.56\nLarge:            1,234,567\n</code></pre>"},{"location":"guide/strings-advanced/#number-vs-string-formatting","title":"Number vs String Formatting","text":"<p>Decimal place formatting (<code>.X</code>) and thousands separators (<code>,</code>) only work on numbers. Using them on strings will cause an error:</p> <pre><code>name = \"Alice\"\nprint(\"{name:.2}\")   // Error: cannot format string with decimal places\nprint(\"{name:,}\")    // Error: cannot format string with thousands separator\n</code></pre> <p>However, padding works on both numbers and strings:</p> <pre><code>print(\"{name:10}\")   // \"     Alice\" (left-padded to 10 chars)\nprint(\"{42:5}\")      // \"   42\" (left-padded to 5 chars)\n</code></pre>"},{"location":"guide/strings-advanced/#multiline-strings","title":"Multiline Strings","text":"<p>Sometimes you want to write strings that contain several lines. These strings may themselves also contain string delimiters e.g. <code>\"</code> or <code>'</code>. For these scenarios, Rad offers <code>\"\"\"</code> multiline string syntax. To demonstrate:</p> <pre><code>text = \"\"\"\nThis is an\nexample of text\nthat \"may contain quotes\"!\nIt also supports interpolation:\nOne plus one equals {1 + 1}\n\"\"\"\nprint(text)\n</code></pre> <pre><code>This is an\nexample of text\nthat \"may contain quotes\"!\nOne plus one equals 2\n</code></pre> <p>Multiline strings must follow some rules:</p> <ol> <li>The opening <code>\"\"\"</code> must not be followed by any non-comment tokens on the same line.</li> <li>The newline after the opening <code>\"\"\"</code> is excluded from the contents of the string. Contents begin on the next line.</li> <li>The closing <code>\"\"\"</code> must not be preceded by any non-whitespace characters on that same line.</li> <li>Whitespace preceding the closing <code>\"\"\"</code> will get removed from the front of each line in the string block.<ul> <li>In other words, you can use the indentation of the closing <code>\"\"\"</code> to control the desired indentation of your contents.</li> <li>If the closing <code>\"\"\"</code> is preceded by more whitespace than exists on any line of string contents, that means we cannot remove that amount of whitespace from the line, leading to an error.</li> </ul> </li> </ol> <p>Below, we demonstrate the 4th point. Note that to make the \"whitespaces\" more visible, I've replaced them with dots, but keep in mind they do represent spaces:</p> <pre><code>text = \"\"\"\n....This is an\n.....example of text\n..that \"may contain quotes\"!\n..\"\"\"  // &lt; 2 preceding spaces. will get removed from each line in the contents.\nprint(text)\n</code></pre> <pre><code>..This is an\n...example of text\nthat \"may contain quotes\"!\n</code></pre>"},{"location":"guide/strings-advanced/#raw-strings","title":"Raw Strings","text":"<p>Rad also supports raw strings. Raw strings don't perform string interpolation and do not allow any escaping (including the delimiter used to create them). Use them when you want your contents to remain as \"raw\" and unprocessed as possible.</p> <p>To use them, just prefix the delimiter of your choice (single/double quotes or backticks) with <code>r</code>.</p> <pre><code>text = r\"Hello\\n{name}\"\nprint(text)\n</code></pre> <pre><code>Hello\\n{name}\n</code></pre> <p>Notice the printed string is exactly as written in code - the newline character and string interpolation are left as-is.</p> <p>You can use any of the string delimiters for raw strings, including multiline <code>\"\"\"</code>:</p> <pre><code>text = r\"Hello\\n{name}\"\ntext = r'Hello\\n{name}'\ntext = r`Hello\\n{name}`\ntext = r\"\"\"\nHello\\n{name}\n\"\"\"\n</code></pre> <p>Common uses for raw strings</p> <p>Raw strings can be quite handy for file paths, especially Windows-style ones that use backslashes:</p> <pre><code>path = r\"C:\\Users\\Documents\\notes.txt\"\n</code></pre> <p>They can also be useful for text containing lots of braces <code>{}</code>, in order to disable string interpolation:</p> <pre><code>json_str = r\"{ 'my_key': { 'my_key2' : 3 } }\"\n</code></pre>"},{"location":"guide/strings-advanced/#escape-sequences","title":"Escape Sequences","text":"<p>When you need special characters in your strings, you can use backslash <code>\\</code> to escape them:</p> <pre><code>print(\"Line 1\\nLine 2\")      // newline\nprint(\"Col1\\tCol2\")          // tab\nprint(\"Path: C:\\\\Users\")     // backslash\nprint(\"She said \\\"Hi!\\\"\")    // quote (though prefer using a different delimiter, or raw strings)\n</code></pre> <pre><code>Line 1\nLine 2\nCol1    Col2\nPath: C:\\Users\nShe said \"Hi!\"\n</code></pre> <p>Available escape sequences:</p> <ul> <li><code>\\n</code> - newline</li> <li><code>\\t</code> - tab</li> <li><code>\\\\</code> - literal backslash</li> <li><code>\\\"</code> <code>\\'</code> <code>\\`</code> - the delimiter itself (though prefer using a different delimiter)</li> <li><code>\\{</code> - literal brace (prevents interpolation, but consider using raw strings)</li> </ul>"},{"location":"guide/strings-advanced/#string-attributes","title":"String Attributes","text":"<p>Strings in Rad can carry attributes like color, bold, italic, and underline. These attributes are preserved through string interpolation and concatenation:</p> <pre><code>name = \"Alice\".green()\nprint(\"Hello, {name}!\")  // \"Alice\" appears green in terminal\nprint(\"Status: \" + \"ACTIVE\".bold())  // \"ACTIVE\" appears bold\n</code></pre> <p>You can apply multiple attributes by chaining function calls:</p> <pre><code>title = \"Important\".underline().bold()\nwarning = \"WARNING\".bold().red()\nprint(title)\nprint(warning)\n</code></pre> <p>Rad provides color functions (<code>red</code>, <code>green</code>, <code>blue</code>, <code>yellow</code>, etc.), style functions (<code>bold</code>, <code>italic</code>, <code>underline</code>), and the <code>hyperlink</code> function for creating clickable terminal links. See the functions reference.</p> <p>When Attributes Are Preserved</p> <ul> <li>Preserved: Interpolation, concatenation, and index lookup maintain attributes</li> <li>Not preserved: Most string functions like <code>replace()</code>, <code>split()</code>, <code>upper()</code>, and <code>lower()</code> return plain strings</li> </ul> <p>We intend to preserve attributes in more situations in future versions of Rad.</p> <p>String Manipulation Functions</p> <p>In addition to the syntax features covered here, Rad provides many built-in functions for working with strings. Use UFCS (dot notation) for cleaner, more readable code:</p> <ul> <li><code>text.upper()</code>, <code>text.lower()</code> - change case</li> <li><code>text.replace(old, new)</code>, <code>text.split(sep)</code>, <code>items.join(sep)</code> - transform and combine strings</li> <li><code>text.trim()</code>, <code>text.trim_prefix()</code>, <code>text.trim_suffix()</code> - remove whitespace or characters</li> <li><code>text.starts_with(prefix)</code>, <code>text.ends_with(suffix)</code> - check string prefixes/suffixes</li> <li><code>text.count(substr)</code> - count substring occurrences</li> <li>And many more!</li> </ul> <p>See the Functions Reference for the complete list with examples.</p>"},{"location":"guide/strings-advanced/#summary","title":"Summary","text":"<ul> <li>We learned about escape sequences like <code>\\n</code>, <code>\\t</code>, and <code>\\{</code> for including special characters in strings.</li> <li>We covered string interpolation, which lets us put expressions directly into strings for evaluation.</li> <li>We saw how to format interpolated expressions using e.g. padding, precision, etc. Example: <code>{num:&lt;20,.3}</code>.</li> <li>We explored multiline strings using <code>\"\"\"</code> syntax, which support both quotes and interpolation.</li> <li>We learned about raw strings (prefixed with <code>r</code>) that prevent interpolation and escaping.</li> <li>We covered string attributes like color and bold that are preserved through interpolation and concatenation.</li> <li>Rad also provides many built-in string manipulation functions covered in the Functions Reference.</li> </ul>"},{"location":"guide/strings-advanced/#next","title":"Next","text":"<p>Next, let's look at another Rad feature which makes it uniquely suited to certain types of scripting: Rad Blocks.</p>"},{"location":"guide/type-annotations/","title":"Type Annotations","text":"<p>As your scripts grow beyond quick one-offs, type annotations become increasingly valuable. They help catch errors early, make your code self-documenting, and keep scripts maintainable as they evolve or get shared with others.</p> <p>In the Functions section, we briefly introduced type annotations for function parameters and return values. Now let's explore Rad's complete type system - from basic primitives to advanced types like unions, structs, and function signatures.</p>"},{"location":"guide/type-annotations/#the-basics","title":"The Basics","text":"<p>Type annotations let you declare what types of values your function parameters accept and what type of value your function returns. The syntax follows a pattern you may recognize from TypeScript or Python's type hints:</p> <pre><code>fn calculate_area(width: int, height: int) -&gt; int:\n    return width * height\n\narea = calculate_area(5, 10)\nprint(area)  // 50\n</code></pre> <p>Here, <code>width: int</code> and <code>height: int</code> specify that both parameters must be integers, and <code>-&gt; int</code> declares that the function returns an integer.</p>"},{"location":"guide/type-annotations/#why-use-type-annotations","title":"Why Use Type Annotations?","text":"<p>Type annotations provide three key benefits:</p> <ol> <li>Self-documenting code - The function signature clearly communicates what types it expects and returns</li> <li>Runtime validation - Rad checks types at runtime and produces helpful error messages when types don't match</li> <li>Tooling support - IDEs and linters can provide better autocomplete and catch errors before you run your code</li> </ol> <p>Let's see runtime validation in action:</p> <pre><code>fn greet(name: str) -&gt; str:\n    return \"Hello, {name}!\"\n\nmessage = greet(42)  // Error!\nprint(message)\n</code></pre> <pre><code>Error at L4:17\n\nmessage = greet(42)  // Error!\n                ^^ Value '42' (int) is not compatible with expected type 'str'\n</code></pre> <p>The error message clearly identifies the problem - we passed an integer when the function expects a string.</p>"},{"location":"guide/type-annotations/#basic-primitive-types","title":"Basic Primitive Types","text":"<p>Rad supports the standard primitive types you'd expect: <code>str</code>, <code>int</code>, <code>float</code>, and <code>bool</code></p> <pre><code>fn process_data(\n    name: str,\n    age: int,\n    salary: float,\n    is_active: bool\n) -&gt; str:\n    status = is_active ? \"active\" : \"inactive\"\n    return \"{name} ({age}) earns ${salary:.2} - {status}\"\n\nresult = process_data(\"Alice\", 30, 75000.50, true)\nprint(result)\n</code></pre> <pre><code>Alice (30) earns $75000.50 - active\n</code></pre>"},{"location":"guide/type-annotations/#special-types-void-and-null","title":"Special Types: void and null","text":"<p>Two additional types appear throughout Rad but work differently from the primitives:</p> <p><code>void</code>: Indicates a function returns nothing. Functions marked <code>-&gt; void</code> don't return a value, and attempting to return a value is an error:</p> <pre><code>fn log_message(msg: str) -&gt; void:\n    print(msg)                 // OK\n\nfn log_message(msg: str) -&gt; void:\n    return msg                 // Error: can't return values\n</code></pre> <p><code>null</code>: The single value representing \"no value\" or \"absence.\" Important: <code>null</code> is only a valid value for optional types marked with <code>?</code>:</p> <pre><code>fn get_name() -&gt; str:\n    return null          // Error: can't return null from str function\n\nfn get_name() -&gt; str?:\n    return null          // OK: str? can return null\n</code></pre> <p>Think of <code>null</code> as belonging exclusively to optional types - it's the way to represent \"this optional value is absent.\"</p>"},{"location":"guide/type-annotations/#collection-types","title":"Collection Types","text":"<p>Rad also lets you specify collection types, with their contents being either typed or untyped.</p>"},{"location":"guide/type-annotations/#typed-lists","title":"Typed Lists","text":"<p>You can specify what type of values a list contains using the <code>&lt;type&gt;[]</code> syntax:</p> <pre><code>fn sum_numbers(nums: int[]) -&gt; int:\n    total = 0\n    for num in nums:\n        total += num\n    return total\n\nresult = sum_numbers([1, 2, 3, 4, 5])\nprint(result)  // 15\n</code></pre> <p>The <code>int[]</code> annotation means \"a list of integers\". Like with other type annotations, if you try to pass a list containing non-integers, you'll get a runtime error.</p> <p>More examples with different types:</p> <pre><code>fn join_words(words: str[]) -&gt; str:\n    return words.join(\" \")\n\nfn average(numbers: float[]) -&gt; float:\n    return sum(numbers) / len(numbers)\n\nsentence = join_words([\"Hello\", \"from\", \"Rad\"])\nprint(sentence)\n</code></pre> <pre><code>Hello from Rad\n</code></pre>"},{"location":"guide/type-annotations/#typed-maps","title":"Typed Maps","text":"<p>Maps can also be typed, specifying both key and value types using <code>{ &lt;key type&gt;: &lt;value type&gt; }</code> syntax:</p> <pre><code>fn count_words(text: str) -&gt; { str: int }:\n    words = text.split(\" \")\n    counts = {}\n    for word in words:\n        if word in counts:\n            counts[word] += 1\n        else:\n            counts[word] = 1\n    return counts\n\nresult = count_words(\"hello world hello\")\nprint(result)\n</code></pre> <pre><code>{ \"hello\": 2, \"world\": 1 }\n</code></pre> <p>The <code>{ str: int }</code> annotation means \"a map with string keys and integer values\".</p>"},{"location":"guide/type-annotations/#generic-collections","title":"Generic Collections","text":"<p>When you don't want to specify what's inside a collection, use the generic forms:</p> <pre><code>fn print_items(items: list) -&gt; void:\n    for item in items:\n        print(item)\n\nfn lookup(data: map, key: str) -&gt; any:\n    return data[key]\n</code></pre> <p>Here, <code>list</code> accepts a list with any types of values, and <code>map</code> accepts a map with any keys and values.</p> <p>The <code>any</code> type means \"any type of value\" - it's the most permissive type and accepts strings, numbers, booleans, lists, maps, or any other value.</p> <p>Generic collections are useful when your types are mixed or you don't wish to overcomplicate your type annotations unnecessarily.</p>"},{"location":"guide/type-annotations/#nested-collections","title":"Nested Collections","text":"<p>Types can be nested for complex data structures:</p> <pre><code>fn organize_by_category(items: str[]) -&gt; { str: str[] }:\n    categories = {}\n    for item in items:\n        category = item[0].upper()  // First letter\n        if category not in categories:\n            categories[category] = []\n        categories[category] += [item]\n    return categories\n\nitems = [\"apple\", \"banana\", \"apricot\", \"blueberry\"]\nresult = organize_by_category(items)\nprint(result)\n</code></pre> <pre><code>{ \"A\": [ \"apple\", \"apricot\" ], \"B\": [ \"banana\", \"blueberry\" ] }\n</code></pre> <p>The return type <code>{ str: str[] }</code> describes a map where each key is a string and each value is a list of strings.</p>"},{"location":"guide/type-annotations/#optional-types","title":"Optional Types","text":"<p>Sometimes a parameter might not always be needed. Rad's optional type syntax with <code>?</code> makes parameters completely optional - you can pass a value, pass <code>null</code>, or omit the parameter entirely:</p> <pre><code>fn greet(name: str, title: str?) -&gt; str:\n    if title == null:\n        return \"Hello, {name}!\"\n    else:\n        return \"Hello, {title} {name}!\"\n\nprint(greet(\"Alice\", \"Dr.\"))     // Pass a value\nprint(greet(\"Bob\", null))        // Explicitly pass null\nprint(greet(\"Charlie\"))          // Omit the parameter entirely\n</code></pre> <pre><code>Hello, Dr. Alice!\nHello, Bob!\nHello, Charlie!\n</code></pre> <p>The <code>str?</code> annotation means \"an optional string parameter\". When omitted or explicitly set to <code>null</code>, the parameter will be <code>null</code> inside the function. This makes it clear that the <code>title</code> parameter is optional and the function knows how to handle its absence.</p> <p>Optional types work with any type:</p> <pre><code>fn find_user(id: int, users: map[]) -&gt; map?:\n    for user in users:\n        if user[\"id\"] == id:\n            return user\n    return null\n\nusers = [{\"id\": 1, \"name\": \"Alice\"}, {\"id\": 2, \"name\": \"Bob\"}]\nuser = find_user(1, users)\nprint(user)  // {\"id\": 1, \"name\": \"Alice\"}\n\nmissing = find_user(999, users)\nprint(missing)  // null\n</code></pre> <p>The <code>map?</code> return type indicates the function might return a map or might return null if no user is found.</p>"},{"location":"guide/type-annotations/#defaults","title":"Defaults","text":"<p>Parameters can have default values, making them optional to provide when calling the function. This works whether or not the parameter is marked with <code>?</code>:</p> <pre><code>fn greet(name: str, greeting: str = \"Hello\") -&gt; str:\n    return \"{greeting}, {name}!\"\n\nprint(greet(\"Alice\"))                // Uses default \"Hello\"\nprint(greet(\"Bob\", \"Hi\"))            // Uses provided \"Hi\"\n</code></pre> <pre><code>Hello, Alice!\nHi, Bob!\n</code></pre> <p>The <code>greeting</code> parameter has a default value of <code>\"Hello\"</code>. When you omit it, the default is used. Note that <code>greeting</code> is not marked with <code>?</code> - it always has a string value, never <code>null</code>.</p>"},{"location":"guide/type-annotations/#defaults-optionals","title":"Defaults &amp; Optionals","text":"<p>When you combine defaults with optional types (<code>?</code>), you can choose whether the default should be <code>null</code> or something else:</p> <pre><code>fn format_price(amount: float, currency: str? = \"USD\") -&gt; str:\n    if currency == null:\n        return \"${amount:.2}\"\n    return \"{amount:.2} {currency}\"\n\nprint(format_price(19.99))           // Uses default \"USD\"\nprint(format_price(19.99, \"EUR\"))    // Uses provided \"EUR\"\nprint(format_price(19.99, null))     // Explicitly passes null\n</code></pre> <pre><code>19.99 USD\n19.99 EUR\n$19.99\n</code></pre> <p>With <code>str?</code> alone, omitting the parameter means it defaults to <code>null</code>. With <code>str? = \"USD\"</code>, you can provide a non-null default value, but callers can still explicitly pass <code>null</code> if they want.</p>"},{"location":"guide/type-annotations/#union-types","title":"Union Types","text":"<p>Sometimes a function can accept or return multiple different types. Union types express this with the <code>|</code> operator:</p> <pre><code>fn to_string(val: int|float|str) -&gt; str:\n    return str(val)\n\nprint(to_string(42))\nprint(to_string(3.14))\nprint(to_string(\"hello\"))\n</code></pre> <pre><code>42\n3.14\nhello\n</code></pre> <p>The <code>int|float|str</code> annotation means \"accepts an int, float, or string\" - any of these three types is valid.</p>"},{"location":"guide/type-annotations/#error-union-types","title":"Error Union Types","text":"<p>A common union pattern in Rad is combining <code>error</code> with another type to represent operations that might fail:</p> <pre><code>fn divide(a: float, b: float) -&gt; float|error:\n    if b == 0:\n        return error(\"Cannot divide by zero\")\n    return a / b\n\nresult = divide(10, 2)\nprint(result)  // 5\n</code></pre> <p>The <code>float|error</code> return type signals that this function returns either a float (on success) or an error value (on failure).</p> <p>Error Handling in Rad</p> <p>Rad has a comprehensive error handling model. We'll cover error handling in detail in a later section: Error Handling.</p>"},{"location":"guide/type-annotations/#advanced-types","title":"Advanced Types","text":"<p>Rad's type system includes several advanced features for expressing complex data structures and constraints.</p>"},{"location":"guide/type-annotations/#enum-types","title":"Enum Types","text":"<p>When a value should be restricted to specific strings, use enum types:</p> <pre><code>fn set_log_level(level: [\"debug\", \"info\", \"warn\", \"error\"]) -&gt; str:\n    return \"Log level set to: {level}\"\n\nprint(set_log_level(\"info\"))\n// set_log_level(\"trace\")  // Error: \"trace\" not in enum\n</code></pre> <pre><code>Log level set to: info\n</code></pre> <p>The <code>[\"debug\", \"info\", \"warn\", \"error\"]</code> annotation restricts the parameter to exactly these four string values. Any other string will cause a runtime type error.</p> <p>This is particularly useful for configuration options, status values, and other cases where only certain strings are valid:</p> <pre><code>fn create_connection(\n    host: str,\n    protocol: [\"http\", \"https\", \"ws\", \"wss\"] = \"https\"\n) -&gt; str:\n    return \"{protocol}://{host}\"\n\nurl = create_connection(\"api.example.com\")\nprint(url)\n</code></pre> <pre><code>https://api.example.com\n</code></pre>"},{"location":"guide/type-annotations/#structured-maps","title":"Structured Maps","text":"<p>For maps with specific named fields, use the struct syntax with quoted keys:</p> <pre><code>fn create_user(name: str, age: int, email: str) -&gt;\n        { \"name\": str, \"age\": int, \"email\": str, \"id\": int }:\n    return {\n        \"name\": name,\n        \"age\": age,\n        \"email\": email,\n        \"id\": rand_int(1000, 9999)\n    }\n\nuser = create_user(\"Alice\", 30, \"alice@example.com\")\nprint(user)\n</code></pre> <pre><code>{ \"name\": \"Alice\", \"age\": 30, \"email\": \"alice@example.com\", \"id\": 7234 }\n</code></pre> <p>The <code>{ \"name\": str, \"age\": int, \"email\": str, \"id\": int }</code> annotation describes a map with exactly these four fields, each with a specific type. Notice the quoted keys - this distinguishes named fields from the typed map syntax we saw earlier.</p>"},{"location":"guide/type-annotations/#optional-fields-in-structs","title":"Optional Fields in Structs","text":"<p>Fields can be marked as optional with <code>?</code>:</p> <pre><code>fn get_user_profile(id: int) -&gt;\n        { \"name\": str, \"age\": int, \"bio\"?: str, \"avatar\"?: str }:\n    // Fetch user... in this example, we'll return mock data\n    return {\n        \"name\": \"Bob\",\n        \"age\": 25,\n        \"bio\": \"Software engineer\"\n        // avatar field is omitted\n    }\n\nprofile = get_user_profile(123)\nprint(profile)\n</code></pre> <pre><code>{ \"name\": \"Bob\", \"age\": 25, \"bio\": \"Software engineer\" }\n</code></pre> <p>The <code>\"bio\"?: str</code> and <code>\"avatar\"?: str</code> fields are optional - the map might or might not contain them.</p>"},{"location":"guide/type-annotations/#nested-structures","title":"Nested Structures","text":"<p>Struct types can be nested for complex data:</p> <pre><code>fn fetch_article() -&gt; {\n    \"title\": str,\n    \"author\": { \"name\": str, \"id\": int },\n    \"metadata\": { \"views\": int, \"likes\": int },\n}:\n    return {\n        \"title\": \"Getting Started with Rad\",\n        \"author\": {\"name\": \"Alice\", \"id\": 1},\n        \"metadata\": {\"views\": 1234, \"likes\": 56}\n    }\n\narticle = fetch_article()\nprint(\"Article: {article.title} by {article.author.name}\")\nprint(\"Stats: {article.metadata.views} views, {article.metadata.likes} likes\")\n</code></pre> <pre><code>Article: Getting Started with Rad by Alice\nStats: 1234 views, 56 likes\n</code></pre>"},{"location":"guide/type-annotations/#function-types","title":"Function Types","text":"<p>Functions themselves can be typed, which is especially useful when passing functions as parameters:</p> <pre><code>fn apply_to_list(items: str[], transform: fn(str) -&gt; str) -&gt; str[]:\n    result = []\n    for item in items:\n        result += [transform(item)]\n    return result\n\nwords = [\"hello\", \"world\"]\nupper_words = apply_to_list(words, upper)\nprint(upper_words)\n</code></pre> <pre><code>[ \"HELLO\", \"WORLD\" ]\n</code></pre> <p>The <code>fn(str) -&gt; str</code> annotation describes a function that takes a string parameter and returns a string.</p> <p>Other examples of valid function type annotations:</p> <pre><code>fn() -&gt; int\nfn(str, str) -&gt; str\nfn(str[]) -&gt; void\n</code></pre>"},{"location":"guide/type-annotations/#variadic-and-named-parameters","title":"Variadic and Named Parameters","text":"<p>Type annotations work seamlessly with Rad's parameter patterns, as seen earlier in Functions.</p>"},{"location":"guide/type-annotations/#variadic-parameters","title":"Variadic Parameters","text":"<p>When a function accepts unlimited arguments, you can type the variadic parameter:</p> <pre><code>fn sum_all(*numbers: int) -&gt; int:\n    total = 0\n    for num in numbers:\n        total += num\n    return total\n\nresult = sum_all(1, 2, 3, 4, 5)\nprint(result)\n</code></pre> <pre><code>15\n</code></pre> <p>The <code>*numbers: int</code> annotation means \"zero or more integer arguments\". All arguments passed to this variadic parameter must be integers.</p>"},{"location":"guide/type-annotations/#named-only-parameters","title":"Named-Only Parameters","text":"<p>Named-only parameters (those after <code>*</code>) can also be typed:</p> <pre><code>fn format_text(\n    text: str,\n    *,\n    uppercase: bool = false,\n    prefix: str = \"\",\n    suffix: str = \"\"\n) -&gt; str:\n    result = prefix + text + suffix\n    return uppercase ? upper(result) : result\n\noutput = format_text(\"hello\", uppercase=true, prefix=\"&gt;&gt;&gt; \")\nprint(output)\n</code></pre> <pre><code>&gt;&gt;&gt; HELLO\n</code></pre>"},{"location":"guide/type-annotations/#combining-everything","title":"Combining Everything","text":"<p>Here's a function that combines positional, variadic, and named-only parameters with types:</p> <pre><code>fn create_report(\n    title: str,\n    *data_points: int|float,\n    *,\n    format: [\"text\", \"html\", \"json\"] = \"text\",\n    include_summary: bool = true\n) -&gt; str:\n    total = sum(data_points)\n    avg = total / len(data_points)\n\n    report = \"=== {title} ===\\n\"\n    report += \"Data: {data_points.join(', ')}\\n\"\n\n    if include_summary:\n        report += \"Total: {total}, Average: {avg:.2}\"\n\n    return report\n\noutput = create_report(\n    \"Q4 Sales\",\n    100, 150, 200, 175,\n    format=\"text\",\n    include_summary=true\n)\nprint(output)\n</code></pre> <pre><code>=== Q4 Sales ===\nData: 100, 150, 200, 175\nTotal: 625, Average: 156.25\n</code></pre> <p>This example demonstrates:</p> <ul> <li>A required positional parameter (<code>title: str</code>)</li> <li>A typed variadic parameter accepting multiple numeric values (<code>*data_points: int|float</code>)</li> <li>Named-only parameters with enum and boolean types</li> <li>A clear, self-documenting function signature</li> </ul>"},{"location":"guide/type-annotations/#summary","title":"Summary","text":"<p>Type annotations are an optional but powerful tool for keeping your Rad scripts maintainable and self-documenting, especially as they grow in complexity or get reused across projects.</p> <p>Key takeaways:</p> <ul> <li>Syntax: Parameter types use <code>param: &lt;type&gt;</code>, return types use <code>-&gt; &lt;type&gt;</code></li> <li>Benefits: Self-documenting code, runtime validation, better tooling support</li> <li>Primitive types: <code>str</code>, <code>int</code>, <code>float</code>, <code>bool</code> for basic values</li> <li>Special types: <code>void</code> (function returns nothing), <code>null</code> (only valid for optional types marked with <code>?</code>)</li> <li>Collection types:<ul> <li><code>T[]</code> for typed lists (e.g., <code>str[]</code>, <code>int[]</code>, <code>float[]</code>)</li> <li><code>{ &lt;key type&gt;: &lt;value type&gt; }</code> for typed maps (e.g., <code>{ str: int }</code>)</li> <li><code>list</code> and <code>map</code> for generic collections (any contents)</li> <li>Nested collections like <code>int[][]</code> and <code>{ str: str[] }</code></li> </ul> </li> <li>Optional types: <code>T?</code> for nullable values (e.g., <code>str?</code>, <code>int?</code>)</li> <li>Union types: <code>T|U</code> for multiple acceptable types (e.g., <code>int|float</code>, <code>str|list</code>)</li> <li>Advanced types:<ul> <li>Enums: <code>[\"value1\", \"value2\", \"value3\"]</code> for restricted string values</li> <li>Structs: <code>{ \"field1\": type1, \"field2\"?: type2 }</code> for structured maps with named fields (quoted keys) and optional fields</li> <li>Function types: <code>fn(&lt;param_type&gt;) -&gt; &lt;return_type&gt;</code> for function parameters and variables</li> <li>Nested structures: Complex combinations of the above</li> </ul> </li> <li>Special parameters: Work with variadic (<code>*param: &lt;type&gt;</code>) and named-only parameters</li> </ul> <p>Type annotations make your code clearer to both humans and tools, catching errors early and making your intentions explicit.</p>"},{"location":"guide/type-annotations/#next","title":"Next","text":"<p>We've briefly seen <code>error|T</code> union types in this section - functions that return either a value or an error.</p> <p>In the next section, we'll explore Rad's comprehensive error handling model in depth: Error Handling.</p>"},{"location":"reference/args/","title":"Args","text":""},{"location":"reference/args/#basics","title":"Basics","text":"<pre><code>args:\n    argVar \"alias\"? shorthand? type = default? # Description?\n</code></pre> <pre><code>args:\n    name n str # A required arg 'name' which can be specified positionally or also with -n.\n    is_employee \"is-employee\" bool # Variable for script is is_employee, but users will see it as is-employee.\n\nif is_employee:\n    print(\"{name} is an employee.\")\nelse:\n    print(\"{name} is not an employee.\") \n</code></pre> <pre><code>args:\n    name string\n    age_years \"age-years\" int\n    height float # Height in meters\n    is_employee \"is-employee\" e bool\n    friends string[] # Specified as e.g. Alice,Bob\n    nationality n string = \"Australian\" # Defaults to this if not specified.\n</code></pre> <p>Example usage:</p> <pre><code>script Charlie 30 -e --friends David,Eve -h 1.86\n</code></pre>"},{"location":"reference/args/#constraint-statements","title":"Constraint Statements","text":""},{"location":"reference/args/#enum","title":"Enum","text":"<pre><code>args:\n    name string\n    name enum [\"alice\", \"bob\", \"charlie\"]\n</code></pre> <pre><code>// valid!\nmyscript alice\n\n// invalid, will print error\nmyscript david\n</code></pre>"},{"location":"reference/assignment/","title":"Assignment","text":"<p>Generally speaking, multi-assignments are only legal for switch expressions, or single operations (e.g. functions) that return multiple values.</p>"},{"location":"reference/assignment/#legal-assignments","title":"Legal Assignments","text":"<pre><code>a = 1\na, b = pick_from_resoure(...)\na, b = switch ...\na, b = parse_int(text)\n\nmyMap[\"key\"] = 2\nmyList[1] = 3\n</code></pre>"},{"location":"reference/assignment/#illegal-assignments","title":"Illegal Assignments","text":"<pre><code>a, b = 1, 2\nmyMap[\"key\"], myMap[\"key2\"] = 2, 3\nmyList[1], myList[2] = 3, 4\n</code></pre>"},{"location":"reference/defer/","title":"Defer & Errdefer","text":"<ul> <li><code>defer</code> and <code>errdefer</code> run in LIFO order, each kind being part of the same one queue.</li> <li>If there are several defer statements, and one fails, further defer statements will still attempt to run.</li> <li>Rad's error code will become an error if the main script succeeded but a defer statement failed.</li> <li>errdefers will not get triggered if the main script succeeded but a <code>defer</code> or <code>errdefer</code> statement failed.</li> </ul>"},{"location":"reference/defer/#defer","title":"<code>defer</code>","text":"defer Example<pre><code>defer:\n    print(1)\n    print(2)\ndefer:\n    print(3)\n    print(4)\nprint(\"Hello!\")\n</code></pre> defer Example Output<pre><code>Hello!\n3\n4\n1\n2\n</code></pre>"},{"location":"reference/defer/#errdefer","title":"<code>errdefer</code>","text":"errdefer Example 1<pre><code>defer:\n    print(1)\n    print(2)\nerrdefer:\n    print(3)\n    print(4)\ndefer:\n    print(5)\n    print(6)\nerrdefer:\n    print(7)\n    print(8)\nprint(\"Hello!\")\nexit(0)  // successful script run\n</code></pre> errdefer Example 1 Output<pre><code>Hello!\n5\n6\n1\n2\n</code></pre> errdefer Example 2<pre><code>defer:\n    print(1)\n    print(2)\nerrdefer:\n    print(3)\n    print(4)\ndefer:\n    print(5)\n    print(6)\nerrdefer:\n    print(7)\n    print(8)\nprint(\"Hello!\")\nexit(1)  // perceived as error!\n</code></pre> errdefer Example 2 Output<pre><code>Hello!\n7\n8\n5\n6\n3\n4\n1\n2\n</code></pre>"},{"location":"reference/errors/","title":"Errors","text":""},{"location":"reference/errors/#codes","title":"Codes","text":""},{"location":"reference/errors/#rad1xxxx-syntax-errors","title":"RAD1xxxx - Syntax Errors","text":"<p>None currently exist.</p>"},{"location":"reference/errors/#rad2xxxx-runtime-errors","title":"RAD2xxxx - Runtime Errors","text":""},{"location":"reference/errors/#rad20001","title":"RAD20001","text":"<p><code>parse_int</code> failed to parse the input.</p>"},{"location":"reference/errors/#rad20002","title":"RAD20002","text":"<p><code>parse_float</code> failed to parse the input.</p>"},{"location":"reference/errors/#rad20003","title":"RAD20003","text":"<p>Failed to read the specified file.</p>"},{"location":"reference/errors/#rad20004","title":"RAD20004","text":"<p>Did not have permission to read the specified file.</p>"},{"location":"reference/errors/#rad20005","title":"RAD20005","text":"<p>Could not read the specified file, as it did not exist.</p>"},{"location":"reference/errors/#rad20006","title":"RAD20006","text":"<p>Failed to write to the specified file.</p>"},{"location":"reference/functions/","title":"Functions","text":"<p>This page aims to concisely document all in-built Rad functions.</p>"},{"location":"reference/functions/#how-to-read-this-document","title":"How to Read This Document","text":""},{"location":"reference/functions/#function-signatures","title":"Function Signatures","text":"<p>You'll see notation like this for function signatures (below are not real functions in Rad; just examples):</p> <pre><code>greet(name: str, times: int = 10) -&gt; string\n</code></pre> <p>This means the function <code>greet</code> takes one required string argument <code>name</code>, and an optional int argument <code>times</code> which defaults to 10 if not specified. It returns a string.</p> <pre><code>greet_many(names: list[string] | ...string) -&gt; none\n</code></pre> <p>This means that <code>greet_many</code> can be called in two ways: either with a single argument that is a list of strings, or <code>|</code> a variable number of string arguments. In both cases, the function returns nothing.</p> <pre><code>do_something(input: any, log: string?) -&gt; any, error?!\n</code></pre> <p>This means the function <code>do_something</code> takes a required argument <code>input</code> which can be of any type. It also has an optional argument <code>log</code> which will default to <code>null</code> if left unspecified.</p> <p>The values it returns depends on how the function is called. If it's being assigned to two variables e.g.</p> <pre><code>foo, bar = do_something(myvar)\n</code></pre> <p>then it will return some <code>any</code> value for <code>foo</code>, and it returns a nullable <code>error</code> for <code>bar</code>.</p> <p>The exclamation point <code>!</code> signifies that, if the call is only assigned to one variable e.g.</p> <pre><code>foo = do_something(myvar)\n</code></pre> <p>and the function fails i.e. would return a non-<code>null</code> <code>error</code> value, then it will instead panic and exit the script with said error.</p>"},{"location":"reference/functions/#error","title":"<code>error</code>","text":"<p><code>error</code> may be referenced as a return type for some functions. <code>error</code> is really a <code>map</code> with the following keys:</p> <ul> <li><code>code: string</code> - An error code indicating the type of error.</li> <li><code>msg: string</code> - A description of the error.</li> </ul> <p>Lastly, you may also see <code>number</code> referenced as a type -- this just means <code>int | float</code>, i.e. any numeric type.</p>"},{"location":"reference/functions/#output","title":"Output","text":""},{"location":"reference/functions/#print","title":"print","text":"<p>Prints zero or more items to stdout, separated by a delimiter.</p> <pre><code>print(*_items: any, *, sep: str = \" \", end: str = \"\\n\") -&gt; void\n</code></pre> <pre><code>print(\"Hello!\")                    // -&gt; Hello!\nprint()                            // -&gt; (just newline)\nprint(\"Hello\", \"world\")            // -&gt; Hello world\nprint(1, 2, 3, sep=\", \")           // -&gt; 1, 2, 3\nprint(\"No newline\", end=\"\")        // -&gt; No newline\n</code></pre>"},{"location":"reference/functions/#print_err","title":"print_err","text":"<p>Behaves like <code>print</code> but outputs to stderr instead of stdout.</p> <pre><code>print_err(*_items: any, *, sep: str = \" \", end: str = \"\\n\") -&gt; void\n</code></pre>"},{"location":"reference/functions/#pprint","title":"pprint","text":"<p>Pretty prints data in JSON format with indentation and colors.</p> <pre><code>pprint(_item: any?) -&gt; void\n</code></pre> <pre><code>item = { \"name\": \"Alice\", \"age\": 30 }\npprint(item)\n// Output:\n// {\n//   \"name\": \"Alice\", \n//   \"age\": 30\n// }\n</code></pre>"},{"location":"reference/functions/#debug","title":"debug","text":"<p>Behaves like <code>print</code> but only outputs when debug mode is enabled via <code>--debug</code> flag.</p> <pre><code>debug(*_items: any, *, sep: str = \" \", end: str = \"\\n\") -&gt; void\n</code></pre>"},{"location":"reference/functions/#misc","title":"Misc","text":""},{"location":"reference/functions/#sleep","title":"sleep","text":"<p>Pauses execution for the specified duration.</p> <pre><code>sleep(_duration: int|float|str, *, title: str?) -&gt; void\n</code></pre> <p>Integer and float values are treated as seconds. String values support Go duration format like \"2h45m\", \"1.5s\", \"500ms\". If <code>title</code> is provided, it's printed before sleeping.</p> <p>Duration string suffixes:</p> Suffix Description <code>h</code> Hours <code>m</code> Minutes <code>s</code> Seconds <code>ms</code> Milliseconds <code>us</code> or <code>\u00b5s</code> Microseconds <code>ns</code> Nanoseconds <p>Examples:</p> <pre><code>sleep(2.5)              // -&gt; Sleep for 2.5 seconds\nsleep(\"1h30m\")          // -&gt; Sleep for 1 hour 30 minutes  \nsleep(\"500ms\")          // -&gt; Sleep for 500 milliseconds\nsleep(5, title=\"Waiting...\") // -&gt; Prints \"Waiting...\" then sleeps 5 seconds\n</code></pre>"},{"location":"reference/functions/#len","title":"len","text":"<p>Returns the length of a string, list, or map.</p> <pre><code>len(input: str|list|map) -&gt; int\n</code></pre> <pre><code>len(\"hello\")        // -&gt; 5\nlen([1, 2, 3, 4])   // -&gt; 4\nlen({\"a\": 1, \"b\": 2}) // -&gt; 2\n</code></pre>"},{"location":"reference/functions/#range","title":"range","text":"<p>Generates a list of numbers in a specified range. Useful in for loops.</p> <pre><code>range(_arg1: float|int, _arg2: float?|int?, _step: float|int = 1) -&gt; list[float|int]\n</code></pre> <p>Single argument generates 0 to <code>_arg1</code> (exclusive). Two arguments generate <code>_arg1</code> to <code>_arg2</code> (exclusive). Step cannot be zero. Returns float list if any argument is float, otherwise int list.</p> <p>Examples:</p> <pre><code>range(5)            // -&gt; [0, 1, 2, 3, 4]\nrange(2, 5)         // -&gt; [2, 3, 4]\nrange(0.5, 3)       // -&gt; [0.5, 1.5, 2.5]\nrange(10, 5, -2)    // -&gt; [10, 8, 6]\n</code></pre>"},{"location":"reference/functions/#join","title":"join","text":"<p>Joins a list into a string with separator, prefix, and suffix.</p> <pre><code>join(_list: list, *, sep: str = \"\", prefix: str = \"\", suffix: str = \"\") -&gt; str\n</code></pre> <pre><code>join([1, 2, 3], sep=\", \")           // -&gt; \"1, 2, 3\"\njoin([\"a\", \"b\"], prefix=\"[\", suffix=\"]\")  // -&gt; \"[ab]\"\njoin([\"x\", \"y\", \"z\"], sep=\"-\", prefix=\"(\", suffix=\")\")  // -&gt; \"(x-y-z)\"\n</code></pre>"},{"location":"reference/functions/#zip","title":"zip","text":"<p>Combines multiple lists into a list of lists, pairing elements by index.</p> <pre><code>zip(*lists: list, *, strict: bool = false, fill: any?) -&gt; list[list]|error\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>*lists</code> <code>list</code> Variable number of lists to zip together <code>strict</code> <code>bool = false</code> If true, error on different list lengths <code>fill</code> <code>any?</code> Value to fill shorter lists (optional) <ul> <li>By default, truncates to the shortest list length</li> <li>Cannot use <code>strict=true</code> with <code>fill</code> parameter (mutually exclusive)</li> <li>Returns error if <code>strict=true</code> and lists have different lengths</li> </ul> <p>Examples:</p> <pre><code>// Basic usage\nzip([1, 2, 3], [\"a\", \"b\", \"c\"])           // -&gt; [[1, \"a\"], [2, \"b\"], [3, \"c\"]]\nzip([1, 2, 3, 4], [\"a\", \"b\"])             // -&gt; [[1, \"a\"], [2, \"b\"]]\n\n// With fill value for unequal lengths\nzip([1, 2, 3, 4], [\"a\", \"b\"], fill=\"-\")   // -&gt; [[1, \"a\"], [2, \"b\"], [3, \"-\"], [4, \"-\"]]\n\n// Strict mode (errors on length mismatch)  \nzip([1, 2, 3], [\"a\", \"b\"], strict=true)   // -&gt; Error: Lists must have the same length\n</code></pre>"},{"location":"reference/functions/#unique","title":"unique","text":"<p>Returns a list with duplicate values removed, preserving first occurrence order.</p> <pre><code>unique(_list: list[any]) -&gt; list[any]\n</code></pre> <pre><code>unique([2, 1, 2, 3, 1, 3, 4])  // -&gt; [2, 1, 3, 4]\nunique([\"a\", \"b\", \"a\", \"c\"])    // -&gt; [\"a\", \"b\", \"c\"]\n</code></pre>"},{"location":"reference/functions/#sort","title":"sort","text":"<p>Sorts a list or string. When multiple lists are provided, performs parallel sorting where additional lists are reordered to match the primary list's sort permutation.</p> <pre><code>sort(_primary: list|str) -&gt; list|str\nsort(_primary: list|str, *_others: list, *, reverse: bool = false) -&gt; list[list]\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>_primary</code> <code>list\\|str</code> Primary data to sort (determines sort order) <code>*_others</code> <code>list</code> Additional lists to reorder in parallel <code>reverse</code> <code>bool = false</code> Sort in descending order <p>Parallel Sorting Behavior:</p> <ul> <li>The first list (<code>_primary</code>) determines the sort order</li> <li>All other lists are reordered to match the same permutation</li> <li>All lists must be the same length</li> <li>Returns a list containing all sorted lists: <code>[sorted_primary, sorted_other1, sorted_other2, ...]</code></li> </ul> <p>Examples:</p> <pre><code>// Basic sorting\nsort([3, 4, 2, 1])                    // -&gt; [1, 2, 3, 4]\nsort([3, 4, 2, 1], reverse=true)      // -&gt; [4, 3, 2, 1]\nsort([3, 4, \"2\", 1, true])            // -&gt; [true, 1, 3, 4, \"2\"]\nsort(\"hello\")                         // -&gt; \"ehllo\"\n\n// Parallel sorting\nnumbers = [2, 1, 4, 3]\nletters = [\"a\", \"b\", \"c\", \"d\"] \nbools = [true, false, true, false]\nsorted_nums, sorted_letters, sorted_bools = sort(numbers, letters, bools)\n// -&gt; [1, 2, 3, 4], [\"b\", \"a\", \"d\", \"c\"], [false, true, false, true]\n</code></pre>"},{"location":"reference/functions/#type_of","title":"type_of","text":"<p>Returns the type of a value as a string.</p> <pre><code>type_of(_var: any) -&gt; str\n</code></pre> <pre><code>type_of(\"hi\")    // -&gt; \"str\"\ntype_of([2])     // -&gt; \"list\" \ntype_of(42)      // -&gt; \"int\"\ntype_of(3.14)    // -&gt; \"float\"\ntype_of({\"a\": 1}) // -&gt; \"map\"\n</code></pre>"},{"location":"reference/functions/#str","title":"str","text":"<p>Converts any value to a string representation.</p> <pre><code>str(_var: any) -&gt; str\n</code></pre> <pre><code>str(42)        // -&gt; \"42\"\nstr(3.14)      // -&gt; \"3.14\"\nstr([1, 2])    // -&gt; \"[1, 2]\"\nstr(true)      // -&gt; \"true\"\n</code></pre>"},{"location":"reference/functions/#int","title":"int","text":"<p>Converts a value to an integer. Does not work on strings - use <code>parse_int</code> for string parsing.</p> <pre><code>int(_var: any) -&gt; int|error\n</code></pre> <pre><code>int(3.14)     // -&gt; 3\nint(true)     // -&gt; 1\nint(false)    // -&gt; 0\nint(\"42\")     // -&gt; Error: cannot convert string\n</code></pre>"},{"location":"reference/functions/#float","title":"float","text":"<p>Converts a value to a float. Does not work on strings - use <code>parse_float</code> for string parsing.</p> <pre><code>float(_var: any) -&gt; float|error\n</code></pre> <pre><code>float(42)      // -&gt; 42.0\nfloat(true)    // -&gt; 1.0\nfloat(false)   // -&gt; 0.0  \nfloat(\"3.14\")  // -&gt; Error: cannot convert string\n</code></pre>"},{"location":"reference/functions/#is_defined","title":"is_defined","text":"<p>Checks if a variable with the given name exists in the current scope.</p> <pre><code>is_defined(_var: str) -&gt; bool\n</code></pre> <pre><code>name = \"Alice\"\nis_defined(\"name\")     // -&gt; true\nis_defined(\"age\")      // -&gt; false\n</code></pre>"},{"location":"reference/functions/#map","title":"map","text":"<p>Applies a function to every element of a list or entry of a map.</p> <pre><code>map(_coll: list|map, _fn: fn(any) -&gt; any | fn(any, any) -&gt; any) -&gt; list|map\n</code></pre> <p>For lists, function receives <code>fn(value)</code>. For maps, function receives <code>fn(key, value)</code>.</p> <p>Examples:</p> <pre><code>map([1, 2, 3], fn(x) x * 2)              // -&gt; [2, 4, 6]\nmap({\"a\": 1, \"b\": 2}, fn(k, v) v * 10)   // -&gt; {\"a\": 10, \"b\": 20}\n</code></pre>"},{"location":"reference/functions/#filter","title":"filter","text":"<p>Applies a predicate function to filter elements of a list or map. Keeps only elements where the function returns true.</p> <pre><code>filter(_coll: list|map, _fn: fn(any) -&gt; bool | fn(any, any) -&gt; bool) -&gt; list|map\n</code></pre> <p>For lists, function receives <code>fn(value)</code>. For maps, function receives <code>fn(key, value)</code>.</p> <p>Examples:</p> <pre><code>filter([1, 2, 3, 4], fn(x) x % 2 == 0)      // -&gt; [2, 4]\nfilter({\"a\": 1, \"b\": 2}, fn(k, v) v &gt; 1)    // -&gt; {\"b\": 2}\n</code></pre>"},{"location":"reference/functions/#flat_map","title":"flat_map","text":"<p>Flattens a list of lists, or applies a mapping function that returns lists and flattens the results.</p> <pre><code>flat_map(_coll: list|map, _fn: any?) -&gt; list\n</code></pre> <p>For lists without function: All elements must be lists. Flattens one level.</p> <p>With function: The function must return a list. Results are flattened.</p> <p>For lists, function receives <code>fn(value)</code>. For maps, function receives <code>fn(key, value)</code> and is required.</p> <p>Examples:</p> <pre><code>// Flatten list of lists (all elements must be lists)\n[[1, 2], [3, 4]].flat_map()              // -&gt; [1, 2, 3, 4]\n[[], [1], []].flat_map()                 // -&gt; [1]\n\n// Only one level\n[[[1]], [[2]]].flat_map()                // -&gt; [[1], [2]]\n\n// Map then flatten (function must return a list)\n[\"a-b\", \"c-d\"].flat_map(fn(e) e.split(\"-\"))  // -&gt; [\"a\", \"b\", \"c\", \"d\"]\n[1, 2].flat_map(fn(x) [x, x * 10])           // -&gt; [1, 10, 2, 20]\n[1, 2].flat_map(fn(x) range(x))              // -&gt; [0, 0, 1]\n\n// Map collection - function required, must return list\n{\"a\": [1, 2], \"b\": [3, 4]}.flat_map(fn(k, v) v)  // -&gt; [1, 2, 3, 4]\n{\"a\": 1, \"b\": 2}.flat_map(fn(k, v) [k, v])       // -&gt; [\"a\", 1, \"b\", 2]\n\n// Errors:\n// [1, [2], 3].flat_map()           // Error: element 0 is not a list\n// [1, 2].flat_map(fn(x) x * 2)     // Error: function must return a list\n</code></pre>"},{"location":"reference/functions/#load","title":"load","text":"<p>Loads a value into a map using lazy evaluation. If key exists, returns cached value; otherwise runs loader function.</p> <pre><code>load(_map: map, _key: any, _loader: fn() -&gt; any) -&gt; any|error\nload(_map: map, _key: any, _loader: fn() -&gt; any, *, reload: bool = false) -&gt; any|error\nload(_map: map, _key: any, _loader: fn() -&gt; any, *, override: any?) -&gt; any|error\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>_map</code> <code>map</code> Map to store/retrieve cached values <code>_key</code> <code>any</code> Key to lookup in the map <code>_loader</code> <code>fn() -&gt; any</code> Function to call if key doesn't exist <code>reload</code> <code>bool = false</code> Force reload even if key exists <code>override</code> <code>any?</code> Use this value instead of calling loader <p>If key doesn't exist, <code>_loader</code> is called and result is cached. Cannot use <code>reload=true</code> with <code>override</code> (mutually exclusive).</p> <p>Examples:</p> <pre><code>cache = {}\nload(cache, \"data\", fn() expensive_calculation())    // -&gt; Runs loader, caches result\nload(cache, \"data\", fn() expensive_calculation())    // -&gt; Returns cached value\n\n// Force reload\nload(cache, \"data\", fn() new_calculation(), reload=true)\n\n// Override with specific value  \nload(cache, \"data\", fn() ignored(), override=\"forced\")\n</code></pre>"},{"location":"reference/functions/#input","title":"Input","text":""},{"location":"reference/functions/#input_1","title":"input","text":"<p>Gets a line of text input from the user with optional prompt, default, hint, and secret mode.</p> <pre><code>input(prompt: str = \"&gt; \") -&gt; str|error\ninput(prompt: str = \"&gt; \", *, hint: str = \"\", default: str = \"\", secret: bool = false) -&gt; str|error\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>prompt</code> <code>str = \"&gt; \"</code> The text prompt to display to the user <code>hint</code> <code>str = \"\"</code> Placeholder text shown in input field <code>default</code> <code>str = \"\"</code> Default value if user doesn't enter anything <code>secret</code> <code>bool = false</code> If true, hides input (useful for passwords) <p>If <code>secret</code> is true, input is hidden (useful for passwords). The <code>hint</code> parameter has no effect when <code>secret</code> is enabled.</p> <p>Examples:</p> <pre><code>// Basic input\nname = input(\"What's your name? \")                    // -&gt; Prompts and waits for input\n\n// With default value\ncolor = input(\"Favorite color? \", default=\"blue\")     // -&gt; Returns \"blue\" if user presses enter\n\n// With hint text\nemail = input(\"Email: \", hint=\"user@example.com\")     // -&gt; Shows placeholder text\n\n// Hidden input for passwords\npassword = input(\"Password: \", secret=true)           // -&gt; Hides typed characters\n</code></pre>"},{"location":"reference/functions/#confirm","title":"confirm","text":"<p>Gets a boolean confirmation from the user (y/n prompt).</p> <pre><code>confirm(prompt: str = \"Confirm? [y/n] &gt; \") -&gt; bool|error\n</code></pre> <pre><code>if confirm():                        // -&gt; Uses default \"Confirm? [y/n] &gt; \" prompt\n    print(\"Confirmed!\")\n\nif confirm(\"Delete file? [y/n] \"):   // -&gt; Custom prompt\n    print(\"File deleted\")\n</code></pre>"},{"location":"reference/functions/#parsing","title":"Parsing","text":""},{"location":"reference/functions/#parse_int","title":"parse_int","text":"<p>Parses a string to an integer.</p> <pre><code>parse_int(_str: str) -&gt; int|error\n</code></pre> <pre><code>parse_int(\"42\")    // -&gt; 42\nparse_int(\"3.14\")  // -&gt; Error: invalid syntax\nparse_int(\"abc\")   // -&gt; Error: invalid syntax\n</code></pre>"},{"location":"reference/functions/#parse_float","title":"parse_float","text":"<p>Parses a string to a float.</p> <pre><code>parse_float(_str: str) -&gt; float|error\n</code></pre> <pre><code>parse_float(\"3.14\")  // -&gt; 3.14\nparse_float(\"42\")    // -&gt; 42.0\nparse_float(\"abc\")   // -&gt; Error: invalid syntax\n</code></pre>"},{"location":"reference/functions/#parse_json","title":"parse_json","text":"<p>Parses a JSON string into Rad data structures.</p> <pre><code>parse_json(_str: str) -&gt; any|error\n</code></pre> <pre><code>parse_json('{\"name\": \"Alice\", \"age\": 30}')  // -&gt; {\"name\": \"Alice\", \"age\": 30}\nparse_json('[1, 2, 3]')                     // -&gt; [1, 2, 3]\nparse_json('invalid json')                  // -&gt; Error: invalid JSON\n</code></pre>"},{"location":"reference/functions/#text","title":"Text","text":""},{"location":"reference/functions/#upper","title":"upper","text":"<p>Converts a string to uppercase. Preserves color attributes.</p> <pre><code>upper(_val: str) -&gt; str\n</code></pre> <pre><code>upper(\"hello\")          // -&gt; \"HELLO\"\nupper(\"Hello World\")    // -&gt; \"HELLO WORLD\"\n</code></pre>"},{"location":"reference/functions/#lower","title":"lower","text":"<p>Converts a string to lowercase. Preserves color attributes.</p> <pre><code>lower(_val: str) -&gt; str\n</code></pre> <pre><code>lower(\"HELLO\")          // -&gt; \"hello\"\nlower(\"Hello World\")    // -&gt; \"hello world\"\n</code></pre>"},{"location":"reference/functions/#replace","title":"replace","text":"<p>Replaces text using regex patterns. Does not preserve string color attributes.</p> <pre><code>replace(_original: str, _find: str, _replace: str) -&gt; str\n</code></pre> <p>The <code>_find</code> parameter is a regex pattern. The <code>_replace</code> parameter can use regex capture groups like <code>$1</code>.</p> <p>Examples:</p> <pre><code>replace(\"hello world\", \"world\", \"Rad\")        // -&gt; \"hello Rad\"\nreplace(\"Name: Charlie Brown\", \"Charlie (.*)\", \"Alice $1\")  // -&gt; \"Name: Alice Brown\"\nreplace(\"abc123def\", \"\\\\d+\", \"XXX\")           // -&gt; \"abcXXXdef\"\n</code></pre>"},{"location":"reference/functions/#starts_with","title":"starts_with","text":"<p>Checks if a string starts with a given substring.</p> <pre><code>starts_with(_val: str, _start: str) -&gt; bool\n</code></pre> <pre><code>starts_with(\"hello world\", \"hello\")  // -&gt; true\nstarts_with(\"hello world\", \"world\")  // -&gt; false\n</code></pre>"},{"location":"reference/functions/#ends_with","title":"ends_with","text":"<p>Checks if a string ends with a given substring.</p> <pre><code>ends_with(_val: str, _end: str) -&gt; bool\n</code></pre> <pre><code>ends_with(\"hello world\", \"world\")    // -&gt; true\nends_with(\"hello world\", \"hello\")    // -&gt; false\n</code></pre>"},{"location":"reference/functions/#truncate","title":"truncate","text":"<p>Truncates a string to a maximum length. Returns error if length is negative.</p> <pre><code>truncate(_str: str, _len: int) -&gt; str|error\n</code></pre> <pre><code>truncate(\"hello world\", 5)   // -&gt; \"hello\"\ntruncate(\"short\", 10)        // -&gt; \"short\"\ntruncate(\"test\", -1)         // -&gt; Error: Requires a non-negative int\n</code></pre>"},{"location":"reference/functions/#split","title":"split","text":"<p>Splits a string using regex pattern as delimiter. Does not preserve string color attributes.</p> <pre><code>split(_val: str, _sep: str) -&gt; list[str]\n</code></pre> <p>The <code>_sep</code> parameter is treated as a regex pattern if valid, otherwise as literal string.</p> <pre><code>split(\"a,b,c\", \",\")            // -&gt; [\"a\", \"b\", \"c\"]\nsplit(\"word1 word2\", \"\\\\s+\")   // -&gt; [\"word1\", \"word2\"]\nsplit(\"abc123def\", \"\\\\d+\")     // -&gt; [\"abc\", \"def\"]\n</code></pre>"},{"location":"reference/functions/#count","title":"count","text":"<p>Counts the number of non-overlapping instances of substring in string.</p> <pre><code>count(_str: str, _substr: str) -&gt; int\n</code></pre> <pre><code>count(\"hello world\", \"l\")     // -&gt; 3\ncount(\"banana\", \"na\")         // -&gt; 2\ncount(\"test\", \"xyz\")          // -&gt; 0\n</code></pre>"},{"location":"reference/functions/#trim","title":"trim","text":"<p>Trims characters from both the start and end of a string.</p> <pre><code>trim(_subject: str, _to_trim: str = \" \\t\\n\") -&gt; str\n</code></pre> <pre><code>trim(\"  hello  \")            // -&gt; \"hello\"\ntrim(\"***hello***\", \"*\")     // -&gt; \"hello\"\ntrim(\"abcHELLOabc\", \"abc\")   // -&gt; \"HELLO\"\n</code></pre>"},{"location":"reference/functions/#trim_prefix","title":"trim_prefix","text":"<p>Trims characters from only the start of a string.</p> <pre><code>trim_prefix(_subject: str, _to_trim: str = \" \\t\\n\") -&gt; str\n</code></pre> <pre><code>trim_prefix(\"  hello  \")         // -&gt; \"hello  \"\ntrim_prefix(\"***hello***\", \"*\")  // -&gt; \"hello***\"\n</code></pre>"},{"location":"reference/functions/#trim_suffix","title":"trim_suffix","text":"<p>Trims characters from only the end of a string.</p> <pre><code>trim_suffix(_subject: str, _to_trim: str = \" \\t\\n\") -&gt; str\n</code></pre> <pre><code>trim_suffix(\"  hello  \")         // -&gt; \"  hello\"\ntrim_suffix(\"***hello***\", \"*\")  // -&gt; \"***hello\"\n</code></pre>"},{"location":"reference/functions/#reverse","title":"reverse","text":"<p>Reverses a string or list.</p> <pre><code>reverse(_val: str|list) -&gt; str|list\n</code></pre> <pre><code>reverse(\"hello\")           // -&gt; \"olleh\"\nreverse([1, 2, 3, 4])      // -&gt; [4, 3, 2, 1]\nreverse(\"racecar\")         // -&gt; \"racecar\"\n</code></pre>"},{"location":"reference/functions/#hyperlink","title":"hyperlink","text":"<p>Creates a clickable hyperlink in supporting terminals.</p> <pre><code>hyperlink(_val: any, _link: str) -&gt; str\n</code></pre> <p>Converts text into a terminal hyperlink that can be clicked in supported terminals.</p> <pre><code>hyperlink(\"Visit Google\", \"https://google.com\")    // -&gt; Clickable \"Visit Google\" link\nhyperlink(\"localhost\", \"http://localhost:3000\")    // -&gt; Clickable \"localhost\" link\nhyperlink(42, \"https://example.com\")               // -&gt; Clickable \"42\" link\n</code></pre>"},{"location":"reference/functions/#colors-attributes","title":"Colors &amp; Attributes","text":"<p>Rad offers several functions to format text with colors and style attributes. All functions follow the same pattern:</p> <pre><code>color_or_style(_item: any) -&gt; str\n</code></pre> <pre><code>red(\"Hello\")           // -&gt; \"Hello\" (in red)\nblue(42)               // -&gt; \"42\" (in blue) \nbold(\"Important\")      // -&gt; \"Important\" (in bold)\n</code></pre> <p>Available colors:</p> <ul> <li><code>plain</code>, <code>black</code>, <code>red</code>, <code>green</code>, <code>yellow</code>, <code>blue</code>, <code>magenta</code>, <code>cyan</code>, <code>white</code>, <code>orange</code>, <code>pink</code></li> </ul> <p>Available style attributes:</p> <ul> <li><code>bold</code>, <code>italic</code>, <code>underline</code></li> </ul>"},{"location":"reference/functions/#color_rgb","title":"color_rgb","text":"<p>Applies RGB coloring to input text. RGB values must be in range [0, 255]. Not all terminals support this.</p> <pre><code>color_rgb(_val: any, *, red: int, green: int, blue: int) -&gt; str|error\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>_val</code> <code>any</code> Value to apply color to <code>red</code> <code>int</code> Red component (0-255) <code>green</code> <code>int</code> Green component (0-255) <code>blue</code> <code>int</code> Blue component (0-255) <p>RGB values must be in range [0, 255]. Not all terminals support this.</p> <pre><code>color_rgb(\"Hello\", red=255, green=0, blue=0)     // -&gt; \"Hello\" (in bright red)\ncolor_rgb(42, red=0, green=255, blue=128)        // -&gt; \"42\" (in green-cyan)\ncolor_rgb(\"test\", red=300, green=0, blue=0)      // -&gt; Error: RGB values must be [0, 255]\n</code></pre>"},{"location":"reference/functions/#colorize","title":"colorize","text":"<p>Assigns consistent colors to values from a set of possible values. The same value always gets the same color within the same set.</p> <pre><code>colorize(_val: any, _enum: any[], *, skip_if_single: bool = false) -&gt; str\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>_val</code> <code>any</code> Value to colorize <code>_enum</code> <code>any[]</code> Set of possible values for consistent coloring <code>skip_if_single</code> <code>bool = false</code> Don't colorize if only one value in set <p>Useful for automatically coloring table data or distinguishing values in lists.</p> <p>Examples:</p> <pre><code>names = [\"Alice\", \"Bob\", \"Charlie\"]\ncolorize(\"Alice\", names)     // -&gt; \"Alice\" (in consistent color)\ncolorize(\"Bob\", names)       // -&gt; \"Bob\" (in different consistent color)\n\n// In display blocks\nnames = [\"Alice\", \"Bob\", \"Charlie\", \"David\"]\ndisplay:\n    fields names\n    names:\n        map fn(n) colorize(n, names)\n</code></pre>"},{"location":"reference/functions/#maps","title":"Maps","text":""},{"location":"reference/functions/#keys","title":"keys","text":"<p>Returns all keys from a map as a list.</p> <pre><code>keys(_map: map) -&gt; list[any]\n</code></pre> <pre><code>keys({\"a\": 1, \"b\": 2, \"c\": 3})  // -&gt; [\"a\", \"b\", \"c\"]\nkeys({})                        // -&gt; []\n</code></pre>"},{"location":"reference/functions/#values","title":"values","text":"<p>Returns all values from a map as a list.</p> <pre><code>values(_map: map) -&gt; list[any]\n</code></pre> <pre><code>values({\"a\": 1, \"b\": 2, \"c\": 3})  // -&gt; [1, 2, 3]\nvalues({})                         // -&gt; []\n</code></pre>"},{"location":"reference/functions/#get_default","title":"get_default","text":"<p>Gets the value for a key in a map, or returns the default value if the key doesn't exist.</p> <pre><code>get_default(_map: map, key: any, default: any) -&gt; any\n</code></pre> <pre><code>data = {\"name\": \"Alice\", \"age\": 30}\nget_default(data, \"name\", \"Unknown\")     // -&gt; \"Alice\"\nget_default(data, \"city\", \"Unknown\")     // -&gt; \"Unknown\"\nget_default(data, \"age\", 0)              // -&gt; 30\n</code></pre>"},{"location":"reference/functions/#random","title":"Random","text":""},{"location":"reference/functions/#rand","title":"rand","text":"<p>Returns a random float between 0.0 (inclusive) and 1.0 (exclusive).</p> <pre><code>rand() -&gt; float\n</code></pre> <pre><code>rand()     // -&gt; 0.7394832\nrand()     // -&gt; 0.2847293\n</code></pre>"},{"location":"reference/functions/#rand_int","title":"rand_int","text":"<p>Returns a random integer in a specified range.</p> <pre><code>rand_int(_arg1: int = 9223372036854775807, _arg2: int?) -&gt; int\n</code></pre> <p>With one argument, returns random int from 0 to <code>_arg1</code> (exclusive). With two arguments, returns random int from <code>_arg1</code> to <code>_arg2</code> (exclusive). Min must be less than max.</p> <pre><code>rand_int(10)        // -&gt; Random int from 0-9\nrand_int(5, 15)     // -&gt; Random int from 5-14\nrand_int(10, 5)     // -&gt; Error: min (10) must be less than max (5)\n</code></pre>"},{"location":"reference/functions/#seed_random","title":"seed_random","text":"<p>Seeds the random number generator used by <code>rand</code> and <code>rand_int</code>.</p> <pre><code>seed_random(_seed: int) -&gt; void\n</code></pre> <pre><code>seed_random(42)\nrand()              // -&gt; Same sequence every time with seed 42\nrand_int(10)        // -&gt; Same sequence every time with seed 42\n</code></pre>"},{"location":"reference/functions/#uuid_v4","title":"uuid_v4","text":"<p>Generates a random V4 UUID.</p> <pre><code>uuid_v4() -&gt; str\n</code></pre> <pre><code>uuid_v4()  // -&gt; \"f47ac10b-58cc-4372-a567-0e02b2c3d479\"\n</code></pre>"},{"location":"reference/functions/#uuid_v7","title":"uuid_v7","text":"<p>Generates a random V7 UUID (time-ordered).</p> <pre><code>uuid_v7() -&gt; str\n</code></pre> <pre><code>uuid_v7()  // -&gt; \"01234567-89ab-7def-8123-456789abcdef\"\n</code></pre>"},{"location":"reference/functions/#gen_fid","title":"gen_fid","text":"<p>Generates a random flex ID (fid) - a time-ordered, URL-safe identifier.</p> <pre><code>gen_fid() -&gt; str|error\ngen_fid(*, alphabet: str?, tick_size_ms: int?, num_random_chars: int?) -&gt; str|error\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>alphabet</code> <code>str? = \"[0-9][A-Z][a-z]\"</code> Characters to use (base-62 by default) <code>tick_size_ms</code> <code>int? = 100</code> Time precision in milliseconds <code>num_random_chars</code> <code>int? = 5</code> Number of random characters to append <p>Defaults: <code>alphabet</code> is base-62 (<code>[0-9][A-Z][a-z]</code>), <code>tick_size_ms</code> is 100ms, <code>num_random_chars</code> is 5.</p> <pre><code>gen_fid()                                    // -&gt; \"1a2b3c4d5e\"\ngen_fid(alphabet=\"0123456789\")               // -&gt; \"1234567890\"\ngen_fid(num_random_chars=3)                  // -&gt; \"1a2b3c\"\n</code></pre>"},{"location":"reference/functions/#picking","title":"Picking","text":""},{"location":"reference/functions/#pick","title":"pick","text":"<p>Presents an interactive menu for selecting from a list of options.</p> <pre><code>pick(_options: list[str], _filter: str?|list[str]?, *, prompt: str = \"Pick an option\") -&gt; str\n</code></pre> <p>Shows a fuzzy-searchable menu. Filter can be a string or list of strings to pre-filter options.</p> <pre><code>pick([\"apple\", \"banana\", \"cherry\"])           // -&gt; Interactive menu\npick([\"red\", \"green\", \"blue\"], \"r\")           // -&gt; Pre-filtered to \"red\", \"green\"\npick([\"one\", \"two\", \"three\"], prompt=\"Choose:\")  // -&gt; Custom prompt\n</code></pre>"},{"location":"reference/functions/#pick_kv","title":"pick_kv","text":"<p>Presents an interactive menu showing keys but returns corresponding values.</p> <pre><code>pick_kv(keys: list[str], values: list[any], _filter: str?|list[str]?, *, prompt: str = \"Pick an option\") -&gt; any\n</code></pre> <p>Displays keys in the menu but returns the value at the same index when selected.</p> <pre><code>names = [\"Alice\", \"Bob\", \"Charlie\"]\nages = [25, 30, 35]\npick_kv(names, ages)                    // -&gt; Shows names, returns age\npick_kv([\"Red\", \"Green\"], [\"#ff0000\", \"#00ff00\"])  // -&gt; Shows colors, returns hex\n</code></pre>"},{"location":"reference/functions/#pick_from_resource","title":"pick_from_resource","text":"<p>Loads options from a resource file and presents an interactive menu.</p> <pre><code>pick_from_resource(path: str, _filter: str?, *, prompt: str = \"Pick an option\") -&gt; any\n</code></pre> <p>Loads data from a JSON/YAML file and presents it as selectable options. Returns the selected item(s).</p> <pre><code>pick_from_resource(\"servers.json\")                    // -&gt; Menu from file\npick_from_resource(\"configs.yaml\", \"prod\")            // -&gt; Pre-filtered options\npick_from_resource(\"data.json\", prompt=\"Select:\")     // -&gt; Custom prompt\n</code></pre>"},{"location":"reference/functions/#multipick","title":"multipick","text":"<p>Presents an interactive menu for selecting multiple options from a list.</p> <pre><code>multipick(_options: str[], *, prompt: str?, min: int = 0, max: int?) -&gt; str[]\n</code></pre> <p>Shows an interactive multi-select menu where users can select zero or more options. = Unlike <code>pick</code>, which returns a single selection, <code>multipick</code> returns a list of all selected items.</p> <p>Parameters:</p> Parameter Type Description <code>_options</code> <code>str[]</code> List of options to display in the menu <code>prompt</code> <code>str?</code> Custom prompt text. If not provided, automatically generated based on min/max <code>min</code> <code>int = 0</code> Minimum number of selections required (default 0 allows empty selection) <code>max</code> <code>int?</code> Maximum number of selections allowed (optional, unlimited if not set) <p>The <code>prompt</code> parameter has smart defaults that adjust based on the min/max constraints.</p> <p>Example:</p> <pre><code>fruits = [\"apple\", \"banana\", \"cherry\", \"date\"]\nselected = multipick(fruits)\n// selected equals e.g. [ \"apple\", \"cherry\" ]\n</code></pre>"},{"location":"reference/functions/#http","title":"HTTP","text":"<p>Rad provides functions for all HTTP methods. All functions have identical signatures and return the same response format.</p>"},{"location":"reference/functions/#http-functions","title":"HTTP Functions","text":"<p>Available methods:</p> <ul> <li><code>http_get</code>, <code>http_post</code>, <code>http_put</code>, <code>http_patch</code>, <code>http_delete</code></li> <li><code>http_head</code>, <code>http_options</code>, <code>http_trace</code>, <code>http_connect</code></li> </ul> <pre><code>http_method(url: str, *, body: any?, json: any?, headers: map?) -&gt; map\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>url</code> <code>str</code> The target URL <code>body</code> <code>any?</code> Request body content (sent as-is) <code>json</code> <code>any?</code> Request body content (JSON-serialized) <code>headers</code> <code>map?</code> Map of HTTP headers - optional. Values can be strings or lists of strings <ul> <li>Body vs JSON: The <code>body</code> parameter sends content as-is using string representation, while <code>json</code> automatically   JSON-serializes the content and sets <code>Content-Type: application/json</code> header only if no <code>headers</code> are provided at all.</li> <li>Mutually exclusive: Cannot use both <code>body</code> and <code>json</code> parameters together - you must choose one or the other.</li> </ul> <p>URL Encoding:</p> <p>Rad automatically normalizes URLs to ensure proper encoding:</p> <ul> <li>Spaces: Encoded as <code>%20</code> everywhere (path and query parameters)</li> <li>Special characters: Properly percent-encoded per RFC 3986</li> </ul> <p>This means you can write URLs naturally with spaces and special characters:</p> <pre><code>// URLs with spaces work naturally\nhttp_get(\"https://api.example.com/search?query=hello world\")\n// Sent as: https://api.example.com/search?query=hello%20world\n\n// Literal plus signs are preserved\nhttp_get(\"https://api.example.com?formula=a+b\")\n// Sent as: https://api.example.com?formula=a%2Bb\n\n// Parameter order is preserved\nhttp_get(\"https://api.example.com?zebra=1&amp;alpha=2\")\n// Sent as written (not reordered alphabetically)\n</code></pre> <p>Response map contains:</p> <ul> <li><code>success: bool</code> - Whether request succeeded</li> <li><code>duration_seconds: float</code> - Request duration</li> <li><code>status_code?: int</code> - HTTP status code (if response received)</li> <li><code>body?: any</code> - Response body parsed as JSON if possible (if present)</li> <li><code>error?: str</code> - Error message (if request failed)</li> </ul> <p>Examples:</p> <pre><code>// Simple GET request\nresponse = http_get(\"https://api.example.com/users\")\nif response.success:\n    users = response.body\n\n// POST with JSON body (automatic serialization and Content-Type header)\ndata = {\"name\": \"Alice\", \"email\": \"alice@example.com\"}\nresponse = http_post(\"https://api.example.com/users\", json=data)\n\n// POST with raw body content (sent as-is)\nresponse = http_post(\"https://api.example.com/webhook\", body=\"raw text data\")\n\n// With custom headers\nheaders = {\"Authorization\": \"Bearer token123\"}\nresponse = http_get(\"https://api.example.com/data\", headers=headers)\n\n// JSON with custom headers (Content-Type automatically added)\nresponse = http_post(\"https://api.example.com/users\", json=data, headers={\"Authorization\": \"Bearer token123\"})\n\n// Error handling\nresponse = http_get(\"https://invalid-url\")\nif not response.success:\n    print(\"Request failed:\", response.error)\n\n// Cannot use both body and json together - this will error:\n// response = http_post(\"url\", body=\"data\", json={\"key\": \"value\"})  // -&gt; Error\n</code></pre>"},{"location":"reference/functions/#math","title":"Math","text":""},{"location":"reference/functions/#abs","title":"abs","text":"<p>Returns the absolute value of a number.</p> <pre><code>abs(_num: int|float) -&gt; int|float\n</code></pre> <pre><code>abs(-5)      // -&gt; 5\nabs(3.14)    // -&gt; 3.14\nabs(-2.7)    // -&gt; 2.7\n</code></pre>"},{"location":"reference/functions/#sum","title":"sum","text":"<p>Sums all numbers in a list.</p> <pre><code>sum(_nums: list[float]) -&gt; float|error\n</code></pre> <pre><code>sum([1, 2, 3, 4])        // -&gt; 10.0\nsum([1.5, 2.5, 3.0])     // -&gt; 7.0\nsum([])                  // -&gt; 0.0\nsum([1, \"text\", 3])      // -&gt; Error: requires list of numbers\n</code></pre>"},{"location":"reference/functions/#round","title":"round","text":"<p>Rounds a number to the specified decimal precision.</p> <pre><code>round(_num: float, _decimals: int = 0) -&gt; int|float|error\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>_num</code> <code>float</code> Number to round <code>_decimals</code> <code>int = 0</code> Number of decimal places (must be non-negative) <p>With precision 0, returns an integer. With precision &gt; 0, returns a float. Precision must be non-negative.</p> <pre><code>round(3.14159)           // -&gt; 3 (integer)\nround(3.14159, 2)        // -&gt; 3.14 (float)\nround(2.7)               // -&gt; 3 (integer)\nround(3.14, -1)          // -&gt; Error: precision must be non-negative\n</code></pre>"},{"location":"reference/functions/#floor","title":"floor","text":"<p>Rounds a number down to the next integer.</p> <pre><code>floor(_num: float) -&gt; int\n</code></pre> <pre><code>floor(1.89)    // -&gt; 1\nfloor(-1.2)    // -&gt; -2\nfloor(5.0)     // -&gt; 5\n</code></pre>"},{"location":"reference/functions/#ceil","title":"ceil","text":"<p>Rounds a number up to the next integer.</p> <pre><code>ceil(_num: float) -&gt; int\n</code></pre> <pre><code>ceil(1.21)     // -&gt; 2\nceil(-1.8)     // -&gt; -1\nceil(5.0)      // -&gt; 5\n</code></pre>"},{"location":"reference/functions/#min","title":"min","text":"<p>Returns the minimum value from a list of numbers or from variadic arguments.</p> <pre><code>min(_nums: float|float[]) -&gt; float|error\n</code></pre> <p>Accepts either a single list of numbers or multiple number arguments.</p> <pre><code>min([1, 2, 3, 4])        // -&gt; 1.0\nmin(1, 2, 3, 4)          // -&gt; 1.0\nmin(5.5, 2.1, 8.9)       // -&gt; 2.1\nmin(5)                   // -&gt; 5.0\nmin([])                  // -&gt; Error: cannot find minimum of empty list\nmin([1, \"text\"])         // -&gt; Error: requires list of numbers\n</code></pre>"},{"location":"reference/functions/#max","title":"max","text":"<p>Returns the maximum value from a list of numbers or from variadic arguments.</p> <pre><code>max(_nums: float|float[]) -&gt; float|error\n</code></pre> <p>Accepts either a single list of numbers or multiple number arguments.</p> <pre><code>max([1, 2, 3, 4])        // -&gt; 4.0\nmax(1, 2, 3, 4)          // -&gt; 4.0\nmax(5.5, 2.1, 8.9)       // -&gt; 8.9\nmax(5)                   // -&gt; 5.0\nmax([])                  // -&gt; Error: cannot find maximum of empty list\nmax([1, \"text\"])         // -&gt; Error: requires list of numbers\n</code></pre>"},{"location":"reference/functions/#clamp","title":"clamp","text":"<p>Constrains a value between minimum and maximum bounds.</p> <pre><code>clamp(val: float, min: float, max: float) -&gt; float|error\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>val</code> <code>float</code> Value to constrain <code>min</code> <code>float</code> Minimum bound <code>max</code> <code>float</code> Maximum bound <p>Returns <code>val</code> if between min and max, otherwise returns the nearest bound. Min must be \u2264 max.</p> <pre><code>clamp(25, 20, 30)    // -&gt; 25.0\nclamp(10, 20, 30)    // -&gt; 20.0\nclamp(40, 20, 30)    // -&gt; 30.0\nclamp(15, 30, 20)    // -&gt; Error: min must be &lt;= max\n</code></pre>"},{"location":"reference/functions/#pow","title":"pow","text":"<p>Raises <code>base</code> to the power of <code>exponent</code>. Useful for exponentiation, square roots, and cube roots.</p> <pre><code>pow(base: float, exponent: float) -&gt; float\n</code></pre> <pre><code>pow(2, 3)      // -&gt; 8\npow(4, 0.5)    // -&gt; 2.0 (square root)\npow(8, 1/3)    // -&gt; 2.0 (cube root)  \npow(2, -2)     // -&gt; 0.25\npow(-2, 3)     // -&gt; -8\n</code></pre>"},{"location":"reference/functions/#hashing-encodedecode","title":"Hashing &amp; Encode/Decode","text":""},{"location":"reference/functions/#hash","title":"hash","text":"<p>Generates a hash of the input text using various algorithms.</p> <pre><code>hash(_val: str) -&gt; str\nhash(_val: str, *, algo: [\"sha1\", \"sha256\", \"sha512\", \"md5\"] = \"sha1\") -&gt; str\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>_val</code> <code>str</code> Text to hash <code>algo</code> <code>[\"sha1\", \"sha256\", \"sha512\", \"md5\"] = \"sha1\"</code> Hashing algorithm to use <p>The default <code>sha1</code> is not cryptographically secure. Use <code>sha256</code> or <code>sha512</code> for security.</p> <pre><code>hash(\"hello world\")                    // -&gt; \"2aae6c35c94fcfb415dbe95f408b9ce91ee846ed\"\nhash(\"hello world\", algo=\"sha256\")     // -&gt; \"b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9\"\nhash(\"sensitive data\", algo=\"sha512\")  // -&gt; Long SHA-512 hash\n</code></pre>"},{"location":"reference/functions/#encode_base64","title":"encode_base64","text":"<p>Encodes text to Base64 format.</p> <pre><code>encode_base64(_content: str) -&gt; str\nencode_base64(_content: str, *, url_safe: bool = false, padding: bool = true) -&gt; str\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>_content</code> <code>str</code> Text to encode <code>url_safe</code> <code>bool = false</code> Replace <code>+/</code> with <code>-_</code> for URL-safe encoding <code>padding</code> <code>bool = true</code> Include <code>=</code> padding characters <p>Use <code>url_safe=true</code> to replace <code>+/</code> with <code>-_</code> for URL-safe encoding. Use <code>padding=false</code> to omit <code>=</code> padding.</p> <pre><code>encode_base64(\"Hello World\")                      // -&gt; \"SGVsbG8gV29ybGQ=\"\nencode_base64(\"Hello World\", url_safe=true)       // -&gt; URL-safe version\nencode_base64(\"Hello World\", padding=false)       // -&gt; \"SGVsbG8gV29ybGQ\"\n</code></pre>"},{"location":"reference/functions/#decode_base64","title":"decode_base64","text":"<p>Decodes Base64 text back to original string.</p> <pre><code>decode_base64(_content: str) -&gt; str|error\ndecode_base64(_content: str, *, url_safe: bool = false, padding: bool = true) -&gt; str|error\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>_content</code> <code>str</code> Base64 text to decode <code>url_safe</code> <code>bool = false</code> Expect URL-safe encoding (<code>-_</code> instead of <code>+/</code>) <code>padding</code> <code>bool = true</code> Expect padding characters (<code>=</code>) <p>Settings must match those used for encoding.</p> <pre><code>encoded = encode_base64(\"Hello World\")\ndecoded = decode_base64(encoded)           // -&gt; \"Hello World\"\n\n// URL-safe decoding\nurl_encoded = encode_base64(\"test\", url_safe=true)\ndecoded = decode_base64(url_encoded, url_safe=true)\n\n// Error handling\nresult = decode_base64(\"invalid base64!\")\nif result.error:\n    print(\"Decode failed:\", result.error)\n</code></pre>"},{"location":"reference/functions/#encode_base16","title":"encode_base16","text":"<p>Encodes text to Base16 (hexadecimal) format.</p> <pre><code>encode_base16(_content: str) -&gt; str\n</code></pre> <pre><code>encode_base16(\"Hello\")        // -&gt; \"48656c6c6f\"\nencode_base16(\"ABC\")          // -&gt; \"414243\"\n</code></pre>"},{"location":"reference/functions/#decode_base16","title":"decode_base16","text":"<p>Decodes Base16 (hexadecimal) text back to original string.</p> <pre><code>decode_base16(_content: str) -&gt; str|error\n</code></pre> <pre><code>decode_base16(\"48656c6c6f\")   // -&gt; \"Hello\"\ndecode_base16(\"414243\")       // -&gt; \"ABC\"\n\n// Error handling\nresult = decode_base16(\"invalid hex\")\nif result.error:\n    print(\"Invalid hex string\")\n</code></pre>"},{"location":"reference/functions/#system-files","title":"System &amp; Files","text":""},{"location":"reference/functions/#exit","title":"exit","text":"<p>Exits the script with the given exit code.</p> <pre><code>exit(_code: int|bool = 0) -&gt; void\n</code></pre> <pre><code>exit()          // -&gt; Exits with code 0\nexit(1)         // -&gt; Exits with code 1\nexit(true)      // -&gt; Exits with code 1 (bool conversion)\nexit(false)     // -&gt; Exits with code 0 (bool conversion)\n</code></pre>"},{"location":"reference/functions/#read_file","title":"read_file","text":"<p>Reads the contents of a file.</p> <pre><code>read_file(_path: str, *, mode: [\"text\", \"bytes\"] = \"text\") -&gt; map|error\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>_path</code> <code>str</code> Path to the file to read <code>mode</code> <code>[\"text\", \"bytes\"] = \"text\"</code> Read as UTF-8 text or raw bytes <p>In text mode, decodes as UTF-8 and returns a string. In bytes mode, returns a list of integers.</p> <p>Return map contains:</p> <ul> <li><code>size_bytes: int</code> - File size in bytes</li> <li><code>content: str|list[int]</code> - File contents (type depends on mode)</li> </ul> <p>Examples:</p> <pre><code>// Read text file\nresult = read_file(\"config.txt\")\nif result.success:\n    content = result.content  // -&gt; string\n\n// Read binary file\nresult = read_file(\"image.png\", mode=\"bytes\")\nif result.success:\n    bytes = result.content    // -&gt; list[int]\n\n// Handle errors\nresult = read_file(\"missing.txt\")\nif not result.success:\n    print(\"Error:\", result.error)\n</code></pre>"},{"location":"reference/functions/#write_file","title":"write_file","text":"<p>Writes content to a file. Creates the file if it doesn't exist.</p> <pre><code>write_file(_path: str, _content: str, *, append: bool = false) -&gt; map|error\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>_path</code> <code>str</code> Path where to write the file <code>_content</code> <code>str</code> Content to write <code>append</code> <code>bool = false</code> Append to existing content instead of overwriting <p>By default overwrites the file. Use <code>append=true</code> to append to existing content.</p> <p>Return map contains:</p> <ul> <li><code>bytes_written: int</code> - Number of bytes written</li> <li><code>path: str</code> - Full path to the written file</li> </ul> <p>Examples:</p> <pre><code>// Write new file\nresult = write_file(\"output.txt\", \"Hello world\")\nprint(\"Wrote\", result.bytes_written, \"bytes\")\n\n// Append to existing file\nwrite_file(\"log.txt\", \"\\nNew entry\", append=true)\n\n// Error handling\nresult, err = write_file(\"/readonly/file.txt\", \"data\")\nif err:\n    print(\"Write failed:\", err.msg)\n</code></pre>"},{"location":"reference/functions/#read_stdin","title":"read_stdin","text":"<p>Reads all data from stdin.</p> <pre><code>read_stdin() -&gt; str?|error\n</code></pre> <pre><code>read_stdin()                  // -&gt; \"piped content\" (if piped)\nread_stdin()                  // -&gt; null (if not piped)\nread_stdin()                  // -&gt; Error 20026 if read fails\ncontent = read_stdin()\nlines = content.split(\"\\n\")   // Process stdin line-by-line\n</code></pre>"},{"location":"reference/functions/#has_stdin","title":"has_stdin","text":"<p>Checks if stdin is piped to the script.</p> <pre><code>has_stdin() -&gt; bool\n</code></pre> <pre><code>has_stdin()                     // -&gt; true (if piped)\nhas_stdin()                     // -&gt; false (if not piped)\nif has_stdin():\n  content = read_stdin()        // Conditional read\n</code></pre>"},{"location":"reference/functions/#get_path","title":"get_path","text":"<p>Gets information about a file or directory path.</p> <pre><code>get_path(_path: str) -&gt; map\n</code></pre> <p>Always returns:</p> <ul> <li><code>exists: bool</code> - Whether the path exists</li> <li><code>full_path: str</code> - Absolute path</li> </ul> <p>When path exists, also returns:</p> <ul> <li><code>base_name?: str</code> - File/directory name</li> <li><code>permissions?: str</code> - Permission string (e.g., \"rwxr-xr-x\")</li> <li><code>type?: str</code> - Either \"file\" or \"dir\"</li> <li><code>size_bytes?: int</code> - File size (only for files)</li> </ul> <p>Examples:</p> <pre><code>info = get_path(\"config.txt\")\nif info.exists:\n    print(\"File size:\", info.size_bytes, \"bytes\")\n    print(\"Type:\", info.type)\nelse:\n    print(\"File not found\")\n</code></pre>"},{"location":"reference/functions/#find_paths","title":"find_paths","text":"<p>Returns a list of all paths under a directory.</p> <pre><code>find_paths(_path: str) -&gt; list[str]|error\nfind_paths(_path: str, *, depth: int = -1, relative: [\"target\", \"cwd\", \"absolute\"] = \"target\") -&gt; list[str]|error\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>_path</code> <code>str</code> Directory to search <code>depth</code> <code>int = -1</code> Max depth to search (-1 for unlimited) <code>relative</code> <code>[\"target\", \"cwd\", \"absolute\"] = \"target\"</code> How to format returned paths <ul> <li><code>\"target\"</code> - Relative to input path (default)</li> <li><code>\"cwd\"</code> - Relative to current directory</li> <li><code>\"absolute\"</code> - Full absolute paths</li> </ul> <p>Examples:</p> <pre><code>// Find all files in directory\npaths = find_paths(\"src/\")\nfor path in paths:\n    print(path)  // -&gt; \"file1.txt\", \"subdir/file2.txt\", etc.\n\n// Limit depth\npaths = find_paths(\"src/\", depth=1)  // -&gt; Only direct children\n\n// Get absolute paths\npaths = find_paths(\"src/\", relative=\"absolute\")\n</code></pre>"},{"location":"reference/functions/#get_env","title":"get_env","text":"<p>Retrieves the value of an environment variable.</p> <pre><code>get_env(_var: str) -&gt; str\n</code></pre> <p>Returns the environment variable value, or empty string if not set.</p> <pre><code>home_dir = get_env(\"HOME\")                    // -&gt; \"/Users/username\"\napi_key = get_env(\"API_KEY\") or \"default\"     // -&gt; Uses default if not set\nmissing = get_env(\"NONEXISTENT\")              // -&gt; \"\"\n</code></pre>"},{"location":"reference/functions/#delete_path","title":"delete_path","text":"<p>Deletes a file or directory at the specified path.</p> <pre><code>delete_path(_path: str) -&gt; bool\n</code></pre> <p>Returns <code>true</code> if the path was successfully deleted, <code>false</code> if it didn't exist or couldn't be deleted.</p> <pre><code>delete_path(\"temp.txt\")         // -&gt; true (if file existed and was deleted)\ndelete_path(\"missing.txt\")      // -&gt; false (file didn't exist)\ndelete_path(\"directory/\")       // -&gt; true (if directory existed and was deleted)\n</code></pre>"},{"location":"reference/functions/#get_rad_home","title":"get_rad_home","text":"<p>Returns Rad's home directory.</p> <pre><code>get_rad_home() -&gt; str\n</code></pre> <pre><code>home = get_rad_home()  // -&gt; \"/Users/username/.rad\" or $RAD_HOME\n</code></pre>"},{"location":"reference/functions/#get_args","title":"get_args","text":"<p>Returns the raw command-line arguments passed to the script.</p> <pre><code>get_args() -&gt; list[str]\n</code></pre> <p>Returns all arguments after the script name. Unlike parsed args, this gives you raw access to all arguments.</p> <pre><code>// If script was called: rad myscript.rad arg1 arg2 --flag\nargs = get_args()  // -&gt; [\"./myscript.rad\", \"arg1\", \"arg2\", \"--flag\"]\n</code></pre>"},{"location":"reference/functions/#error_1","title":"error","text":"<p>Creates an error object with the given message.</p> <pre><code>error(_msg: str) -&gt; error\n</code></pre> <pre><code>err = error(\"Something went wrong\")\nreturn err  // -&gt; Script will exit with this error message\n</code></pre>"},{"location":"reference/functions/#home-stash","title":"Home &amp; Stash","text":""},{"location":"reference/functions/#get_rad_home_1","title":"<code>get_rad_home</code>","text":"<p>Returns the path to rad's home folder on the user's machine.</p> <pre><code>get_rad_home() -&gt; string\n</code></pre> <p>Return Values</p> <p>Defaults to <code>$HOME/.rad</code>, or <code>$RAD_HOME</code> if it's defined.</p>"},{"location":"reference/functions/#get_stash_dir","title":"<code>get_stash_dir</code>","text":"<p>Returns the full path to the script's stash directory, with the given subpath if specified.</p> <p>Requires a stash ID to have been defined.</p> <pre><code>get_stash_dir(subpath: string?) -&gt; string\n</code></pre> <p>Return Values</p> <ul> <li>Without subpath defined: <code>&lt;rad home&gt;/stashes/&lt;stash id&gt;</code></li> <li>With subpath defined: <code>&lt;rad home&gt;/stashes/&lt;stash id&gt;/&lt;subpath&gt;</code></li> </ul>"},{"location":"reference/functions/#load_state","title":"<code>load_state</code>","text":"<p>Loads the script's stashed state. Creates it if it doesn't already exist.</p> <p>Requires a stash ID to have been defined.</p> <pre><code>load_state() -&gt; map, bool\n</code></pre> <p>Return Values</p> <ol> <li><code>map</code> containing the saved state. Starts empty, before anything is saved to it.</li> <li><code>bool</code> representing if the state existed before the load, or if it was just created.</li> </ol>"},{"location":"reference/functions/#save_state","title":"save_state","text":"<p>Saves the script's state to persistent stash storage.</p> <pre><code>save_state(_state: map) -&gt; error?\n</code></pre> <pre><code>state = {\"counter\": 42, \"last_run\": now().date}\nsave_state(state)\nprint(\"State saved\")\n</code></pre>"},{"location":"reference/functions/#load_stash_file","title":"load_stash_file","text":"<p>Loads a file from the script's stash directory, creating it with default content if it doesn't exist.</p> <pre><code>load_stash_file(_path: str, _default: str = \"\") -&gt; map|error\n</code></pre> <p>Return map contains:</p> <ul> <li><code>full_path: str</code> - Full path to the file</li> <li><code>created: bool</code> - Whether the file was just created</li> <li><code>content?: str</code> - File contents (if successfully loaded)</li> </ul> <pre><code>result = load_stash_file(\"config.txt\", \"default config\")\nif result.success:\n    if result.created:\n        print(\"Created new config file\")\n    content = result.content\n</code></pre>"},{"location":"reference/functions/#write_stash_file","title":"write_stash_file","text":"<p>Writes content to a file in the script's stash directory.</p> <pre><code>write_stash_file(_path: str, _content: str) -&gt; error?\n</code></pre> <pre><code>write_stash_file(\"log.txt\", \"Script executed at \" + now().time)\nwrite_stash_file(\"data/results.json\", json_data)\nprint(\"Data saved to stash\")\n</code></pre>"},{"location":"reference/functions/#time","title":"Time","text":""},{"location":"reference/functions/#now","title":"now","text":"<p>Returns the current time with various accessible formats.</p> <pre><code>now(*, tz: str = \"local\") -&gt; map|error\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>tz</code> <code>str = \"local\"</code> Timezone (e.g., \"UTC\", \"America/Chicago\") <p>Map values:</p> Accessor Description Type Example <code>.date</code> Current date YYYY-MM-DD string 2019-12-13 <code>.year</code> Current calendar year int 2019 <code>.month</code> Current calendar month int 12 <code>.day</code> Current calendar day int 13 <code>.hour</code> Current clock hour (24h) int 14 <code>.minute</code> Current minute of the hour int 15 <code>.second</code> Current second of the minute int 16 <code>.time</code> Current time in \"hh:mm:ss\" format string 14:15:16 <code>.epoch.seconds</code> Seconds since 1970-01-01 00:00:00 UTC int 1576246516 <code>.epoch.millis</code> Millis since 1970-01-01 00:00:00 UTC int 1576246516123 <code>.epoch.nanos</code> Nanos since 1970-01-01 00:00:00 UTC int 1576246516123456789 <p>Examples:</p> <pre><code>time = now()\nprint(\"Current date:\", time.date)          // -&gt; \"2024-04-05\"\nprint(\"Current time:\", time.time)          // -&gt; \"14:30:25\"\nprint(\"Year:\", time.year)                  // -&gt; 2024\n\n// Use epoch for timestamps\ntimestamp = now().epoch.seconds\nprint(\"Timestamp:\", timestamp)             // -&gt; 1712345678\n\n// Different timezone\nutc_time = now(tz=\"UTC\")\nprint(\"UTC time:\", utc_time.time)          // -&gt; Time in UTC\n</code></pre>"},{"location":"reference/functions/#parse_epoch","title":"parse_epoch","text":"<p>Parses a Unix epoch timestamp into various time formats.</p> <pre><code>parse_epoch(_epoch: int) -&gt; map|error\nparse_epoch(_epoch: int, *, tz: str = \"local\") -&gt; map|error\nparse_epoch(_epoch: int, *, unit: [\"auto\", \"seconds\", \"milliseconds\", \"microseconds\", \"nanoseconds\"] = \"auto\") -&gt; map|error\nparse_epoch(_epoch: int, *, tz: str = \"local\", unit: [\"auto\", \"seconds\", \"milliseconds\", \"microseconds\", \"nanoseconds\"] = \"auto\") -&gt; map|error\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>_epoch</code> <code>int</code> Unix epoch timestamp <code>tz</code> <code>str = \"local\"</code> Timezone (e.g., \"UTC\", \"America/Chicago\") <code>unit</code> <code>[\"auto\", \"seconds\", \"milliseconds\", \"microseconds\", \"nanoseconds\"] = \"auto\"</code> Timestamp unit (auto-detects by default) <p>Converts an epoch timestamp to the same format as <code>now()</code>. Auto-detects units from digit count, or specify explicitly.</p> <p>Examples:</p> <pre><code>// Parse seconds epoch (auto-detected)\ntime = parse_epoch(1712345678)\nprint(time.date, time.time)  // -&gt; \"2024-04-05 22:01:18\"\n\n// Parse milliseconds with timezone\ntime = parse_epoch(1712345678123, tz=\"America/Chicago\")\nprint(time.hour)  // -&gt; Hour in Chicago timezone\n\n// Explicit unit specification\ntime = parse_epoch(1712345678000, unit=\"milliseconds\")\n\n// Error handling\ntime, err = parse_epoch(1712345678, tz=\"Invalid/Timezone\")\nif err:\n    print(\"Invalid timezone:\", err.msg)\n</code></pre>"},{"location":"reference/global-flags/","title":"Global Flags","text":"<p>WIP</p>"},{"location":"reference/json-field-definition/","title":"Json Field Definition","text":"<p>TODO perhaps reframe as general 'json extraction logic' reference?</p>"},{"location":"reference/logic/","title":"Boolean Logic","text":""},{"location":"reference/logic/#truthy-falsy","title":"Truthy / Falsy","text":"<p>Rad supports truthy/falsy logic.</p> <p>For those unfamiliar, this means that, instead of writing the following (as an example):</p> <pre><code>if len(my_list) &gt; 0:\n    print(\"My list has elements!\")\n</code></pre> <p>you can write</p> <pre><code>if my_list:\n    print(\"My list has elements!\")\n</code></pre> <p>Essentially, you can use any type as a condition, and it will resolve to true or false depending on the value.</p> <p>The following table shows which values return false for each type. All other values resolve to true.</p> Type Falsy Description str <code>\"\"</code> Empty strings int <code>0</code> Zero float <code>0.0</code> Zero list <code>[]</code> Empty lists map <code>{}</code> Empty maps <p>Note that a string which is all whitespace e.g. <code>\" \"</code> is truthy.</p>"},{"location":"reference/math/","title":"Math","text":""},{"location":"reference/math/#modulo","title":"Modulo","text":"<p>Rad has a modulo operator. It can be used to get the remainder after performing integer division.</p> <pre><code>print(5 % 3)\n</code></pre> <pre><code>2\n</code></pre> <p>This also works for floats, or mixes between floats and ints.</p> <pre><code>print(5.6 % 4.1)\nprint(5 % 4.5)\n</code></pre> <pre><code>1.5\n0.5\n</code></pre> <p>Negative numbers is a somewhat complex topic, and different languages handle them differently. Here is a brief overview:</p> -11 % 7 = Approach Result takes sign of... Example Languages -4 Truncated Division Numerator (dividend) Rad, C/C++, Java, JavaScript, Go, Rust, Swift, C# 3 Floored Division Denominator (divisor) Python, Ruby, R <p>Notice Rad behaves differently from Python, and instead follows the behavior of most other major languages.</p>"},{"location":"reference/rad-blocks/","title":"Rad Blocks","text":""},{"location":"reference/rad-blocks/#rad-block","title":"<code>rad</code> block","text":"<pre><code>rad url:\n    fields Name, Birthdate, Height\n    Name:\n        map fn(n) truncate(n, 20)\n    if sort_by_height:\n        sort Height, Name, Birthdate\n    else:\n        sort\n</code></pre>"},{"location":"reference/rad-blocks/#request-block","title":"<code>request</code> block","text":"<pre><code>request url:\n    fields Name, Birthdate, Height\n</code></pre>"},{"location":"reference/rad-blocks/#display-block","title":"<code>display</code> block","text":"<pre><code>display:\n    fields Name, Birthdate, Height\n</code></pre>"},{"location":"reference/rad-blocks/#colors","title":"Colors","text":"<p>Valid colors:</p> <p><code>plain, black, red, green, yellow, blue, magenta, cyan, white, orange, pink</code></p>"},{"location":"reference/shell-commands/","title":"Shell Commands","text":""},{"location":"reference/shell-commands/#basic-shell-commands","title":"Basic Shell Commands","text":"<pre><code>$`ls -l`\nfail:\n    print(\"Command failed! Exiting script!\")\n</code></pre> <pre><code>$`ls -l`\nrecover:\n    print(\"Command failed! Continuing script...\")\n</code></pre>"},{"location":"reference/shell-commands/#critical-shell-commands","title":"Critical Shell Commands","text":"<pre><code>$!`ls -l`\n</code></pre>"},{"location":"reference/shell-commands/#unsafe-shell-commands","title":"Unsafe Shell Commands","text":"<pre><code>unsafe $`ls -l`\n</code></pre>"},{"location":"reference/shell-commands/#output-capture","title":"Output Capture","text":"<pre><code>err_code = $!`ls -l`\nerr_code, stdout = $!`ls -l`\nerr_code, stdout, stderr = $!`ls -l`\n</code></pre>"},{"location":"reference/shell-commands/#suppress-announcements","title":"Suppress Announcements","text":"<p>By default, Rad will 'announce' (i.e. print) commands as they're executed. Example:</p> Without quiet<pre><code>$!`ls`\n$!`echo hello`\n</code></pre> Without quiet output<pre><code>\u26a1\ufe0f Running: ls\npick.rad  simple.rad  sorting.rad\n\u26a1\ufe0f Running: echo hello\nhello\n</code></pre> <p>These announcements can be suppressed with the <code>quiet</code> keyword. It does not impact stdout/stderr output for the command.</p> With quiet<pre><code>quiet $!`ls`\nquiet $!`echo hello`\n</code></pre> With quiet output<pre><code>pick.rad  simple.rad  sorting.rad\nhello\n</code></pre>"},{"location":"reference/strings/","title":"Strings","text":"<p>Rad has three delimiters for strings:</p> <pre><code>\"double quotes\"\n'single quotes'\n`backticks`\n</code></pre> <p>All three of these behave the same way. Rad offers three so you have alternatives to pick between depending on the contents of your string. For example, if you have a string which itself contains lots of single quotes, you may choose to use the double quotes delimiter. Or, if your string has both single and double quotes, you can use backticks to delimit your string. Specific example:</p> <pre><code>`Single quotes: 'Hi!', double quotes: \"Hi!\"`\n</code></pre>"},{"location":"reference/strings/#string-attributes","title":"String Attributes","text":"<ul> <li>Not all strings are just plain text. They may have attributes such as color.</li> <li>This means that Rad contains logic on how to handle attributes when strings are combined or operated on<ul> <li>e.g. concatenation, slicing, replace functions, etc</li> </ul> </li> <li>The following operations maintain color attributes:<ul> <li>concatenation</li> <li>index lookup</li> </ul> </li> <li>The following do not, and just return a plain string:<ul> <li>slicing (to be added)</li> <li>functions: <code>replace</code>, <code>split</code></li> </ul> </li> <li>Attributes do not impact things like equality or comparing strings.<ul> <li>A green string \"Alice\" and a yellow string \"Alice\" will be considered 'equal'.</li> </ul> </li> </ul>"},{"location":"reference/strings/#string-interpolation","title":"String Interpolation","text":""},{"location":"reference/strings/#formatting","title":"Formatting","text":"<ul> <li>Float formatting does not require a <code>f</code> at the end.<ul> <li>Correct: <code>{myFloat:.2}</code></li> <li>Incorrect: <code>{myFloat:.2f}</code></li> </ul> </li> </ul> <p>Examples:</p> <pre><code>\"{myString:20}\"\n\"{myString:&lt;20}\"\n\"{myString:&gt;20}\"\n\"{myFloat:.2}\"\n</code></pre>"},{"location":"reference/strings/#escaping","title":"Escaping","text":"<ul> <li><code>\\</code> will escape:</li> <li><code>{</code> (to prevent string interpolation)</li> <li><code>\\n</code> new line</li> <li><code>\\t</code> tab</li> <li><code>\\</code> i.e. itself, so you can write backslashes</li> <li>The respective string delimiter itself, so <code>\\\"</code>, <code>\\'</code>, or <code>\\`</code>, depending on the delimiter you're using.<ul> <li>However, it's advised you use delimiters that don't clash with the contents of your string, if possible.</li> </ul> </li> </ul>"},{"location":"reference/strings/#raw-strings","title":"Raw Strings","text":"<p>Raw strings can be used when you want Rad to treat the string as it's written, rather than performing escaping, interpolation, etc.</p> <p>Raw strings are created by prefixing an <code>r</code> to the opening delimiter of your string. For example:</p> <pre><code>name = \"alice\"\ntext = r\"Regards,\\n{name}\"\nprint(text)\n</code></pre> <pre><code>Regards,\\n{name}\n</code></pre> <p>Notice Rad did not render the <code>\\n</code> as a newline as it would in a regular string, and that <code>{name}</code> is also left as-is i.e. no interpolation was performed.</p> <p>Unlike Python, you cannot escape anything in raw strings, including the delimiter. For example:</p> <pre><code>r\"\\\"\"\n</code></pre> <p>is illegal because the backslash does not escape the following <code>\"</code>, and so that quote actually ends the raw string. Then we're left with a third and dangling <code>\"</code> at the end, causing a syntax error.</p> <p>You cannot escape the raw string's own delimiter</p> <p>Rad raw strings behave more like their equivalent in Go than Python. In Python, you can escape the delimiter used to make the raw string i.e. <code>r\"quote: \\\"!\"</code>. If printed, this will display as <code>quote: \\\"!</code> i.e. the escape character is also printed. There are lots of discussions online about this somewhat odd behavior, which is why Rad (and Go) opted to instead keep the rules very simple and not allow escaping in raw strings of any kind.</p> <p>Instead, if you try the same thing in Rad, you will get an error because the quote following <code>\\</code> will close the string, leaving a dangling <code>!\"</code> at the end, which is invalid syntax.</p>"}]}