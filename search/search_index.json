{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Rad","text":""},{"location":"#new","title":"New?","text":"<p>Check out the Getting Started guide!</p>"},{"location":"#reference","title":"Reference","text":"<p>See 'Reference' in the side panel.</p>"},{"location":"introduction/","title":"Introduction","text":"<p>Bash scripts are great! They make our lives easier by allowing us to automate common workflows, saving valuable time.</p> <p>However, writing Bash scripts is not great, and it can be time-consuming to get them right. One of the main reasons is the syntax - compared to today's popular languages, Bash's syntax is unusual and downright arcane in some places.</p> <p>Wouldn't it be nice if we had an alternative with far more familiar and intuitive syntax, but still as powerful in what it can achieve?</p>"},{"location":"introduction/#rad","title":"Rad","text":"<p>Rad is a tool for running scripts written in RSL - Rad Scripting Language. RSL is designed to </p>"},{"location":"guide/basics/","title":"Basics","text":"<p>This section of the guide will rapidly cover the basics of RSL. RSL shares a lot of conventions and syntax with popular languages like Python, so if you're familiar with programming, this will be quick &amp; easy.</p>"},{"location":"guide/basics/#variables-assignment","title":"Variables &amp; Assignment","text":"<p>To create a variable, you can do it through assignment. Let's use a string example:</p> <pre><code>name = \"Alice\"\n</code></pre> <p>You can re-assign variables. Types don't need to stay the same:</p> <pre><code>name = 2\n</code></pre> <p>You cannot create multiple variables this way on one line.</p> <p>The following is illegal syntax</p> <pre><code>a, b = \"one\", \"two\"\n</code></pre> <p>instead, declare each variable on one line.</p> <pre><code>a = \"one\"\nb = \"two\"\n</code></pre>"},{"location":"guide/basics/#data-types","title":"Data Types","text":"<p>RSL's data types closely mirror those of JSON. Namely: strings, ints, floats, bools, lists, and maps.</p>"},{"location":"guide/basics/#strings","title":"Strings","text":"<p>Strings can be delimited in three ways. The most standard are double quotes (<code>\"text\"</code>) or single quotes(<code>'text'</code>). The third is backticks (<code>`text`</code>).</p> <p>Double and single quotes behave the same way. For example:</p> <pre><code>greeting = \"Hello\\nWorld!\"\nprint(greeting)\n</code></pre> <pre><code>Hello\nWorld!\n</code></pre> <pre><code>greeting = 'Hello\\nWorld!'\nprint(greeting)\n</code></pre> <pre><code>Hello\nWorld!\n</code></pre> <p>Backtick-delimited strings behave a little differently. Characters like <code>\\n</code> don't get escaped and so print as-is.</p> <pre><code>greeting = `Hello\\nWorld!`\nprint(greeting)\n</code></pre> <pre><code>Hello\\nWorld!\n</code></pre> <p>Use backtick strings when you want the contents to remain closer to their 'raw' form.</p> <p>Why 3 different delimiters?</p> <p>Having 3 different delimiters is particularly useful when you want your string to contain one (or more) of the delimiter characters.</p> <p>For example, if you want a double quote in your string, you can use double quote delimiters and escape them:</p> <pre><code>\"She said \\\"Goodbye\\\"\"\n</code></pre> <p>However, this can be finicky and hard to read. Instead, you can pick one of the other two delimiters, for example:</p> <pre><code>'She said \"Goodbye\"'\n`She said \"Goodbye\"`\n</code></pre> <p>We'll cover this again later, but as a note, backticks can be particularly useful in shell commands, as shell/bash commands may include single or double quotes, and backticks save us from having to escape them.</p>"},{"location":"guide/basics/#int","title":"int","text":"<p>RSL has ints. There's nothing unusual about them. Example:</p> <pre><code>team_size = 20\ncelsius = -5\n</code></pre> <p>Note that if you divide two ints, you will get back a float.</p> <pre><code>liters = 10\npeople = 4\nprint(\"This is a float:\", liters / people)\n</code></pre> <pre><code>This is a float: 2.5\n</code></pre>"},{"location":"guide/basics/#float","title":"float","text":"<p>The other number type is float:</p> <pre><code>length_meters = 2.68\n</code></pre> <p>If you want to define a whole number as a float, simply include a decimal place:</p> <pre><code>years = 20.0\n</code></pre>"},{"location":"guide/basics/#bool","title":"bool","text":"<p>RSL uses lowercase <code>true</code> / <code>false</code>:</p> <pre><code>is_running = true\nis_tired = false\n</code></pre>"},{"location":"guide/basics/#list","title":"list","text":"<p>RSL has two collection types: lists and maps. First, let's look at lists. These are also sometimes referred to as 'arrays' in other languages.</p> <pre><code>names = [\"alice\", \"bob\", \"charlie\"]\n</code></pre> <p>Lists you define can contain any types:</p> <pre><code>mixed = [\"alice\", true, 50, -2.4]\n</code></pre> <p>They can also be nested:</p> <pre><code>nested = [\"alice\", [1, [\"very nested\", \"ahhh\"]]]\n</code></pre> <p>Indexing and slicing works very similarly to Python. If we assume the 3 variables above exist, you can index with both positive and negative indexes:</p> <pre><code>print(names[0])\nprint(mixed[-1])  // grab last element in the list\nprint(nested[1][1][0])\n</code></pre> <pre><code>alice\n-2.4\nvery nested\n</code></pre> <p>And also you can slice:</p> <pre><code>numbers = [10, 20, 30, 40, 50]\nprint(numbers[1:3])\nprint(numbers[2:])\nprint(numbers[:-1])\n</code></pre> <pre><code>[20, 30]\n[30, 40, 50]\n[10, 20, 30, 40]\n</code></pre>"},{"location":"guide/basics/#map","title":"map","text":"<p>The last type, and second of two collection types, is a 'map'. These may also be referred to as 'hashmap' or 'dictionary' in other languages.</p> <pre><code>scores = { \"alice\": 25, \"bob\": 17, \"charlie\": 36 }\n</code></pre> <p>Like lists, they can contain mixed types for values, and can nest. However, keys must be strings.</p> <pre><code>mixed_map = { \"alice\": \"accountant\", \"mylist\": [\"London\", 25] }\nnested_map = { \"error\": { \"msg\": \"Request failed!\", \"code\": 400 } }\n</code></pre> <p>If we take the above example, values can then be accessed in two ways. First is the square bracket lookup:</p> <pre><code>print(mixed_map[\"alice\"])\nprint(nested_map[\"error\"][\"msg\"])\n</code></pre> <pre><code>accountant\nRequest failed!\n</code></pre> <p>Alternatively, you can use a dot syntax. Note this second way only works for keys with no spaces in the name.</p> <pre><code>print(mixed_map.alice)\nprint(nested_map.error.msg)\n</code></pre> <pre><code>accountant\nRequest failed!\n</code></pre> <p>You can modify maps using either syntax:</p> Using brackets<pre><code>mymap = { \"alice\": 30 }\n\nmymap[\"alice\"] = 40\nprint(mymap)\n\nmymap.alice = 50\nprint(mymap)\n</code></pre> <pre><code>{ alice: 40 }\n{ alice: 50 }\n</code></pre> <p>You can also add keys this way:</p> <pre><code>mymap = { \"alice\": 30 }\nmymap[\"bob\"] = 31\nmymap.charlie = 32\nprint(mymap)\n</code></pre> <pre><code>{ alice: 30, bob: 31, charlie: 32 }\n</code></pre>"},{"location":"guide/basics/#operators","title":"Operators","text":"<ul> <li>TBC<ul> <li>arithmetic</li> <li>comparison</li> <li>logical</li> <li>concat</li> <li>ternary</li> </ul> </li> </ul>"},{"location":"guide/basics/#control-flow","title":"Control Flow","text":"<ul> <li>TBC<ul> <li>if<ul> <li>truthy/falsy </li> </ul> </li> <li>for</li> <li>switch</li> </ul> </li> </ul>"},{"location":"guide/getting_started/","title":"Getting Started","text":""},{"location":"guide/getting_started/#installation","title":"Installation","text":""},{"location":"guide/getting_started/#macos","title":"macOS","text":"<pre><code>brew tap amterp/rad\nbrew install rad\n</code></pre> <p>Other than building from source, rad is not available for other platforms/package managers (yet).</p>"},{"location":"guide/getting_started/#checking-installation","title":"Checking Installation","text":"<p>After you've installed rad, you can check your installation:</p> <pre><code>rad -V\n</code></pre> <p>If this prints rad's version, you're set!</p>"},{"location":"guide/getting_started/#your-first-rsl-script-hello-world","title":"Your First RSL Script - Hello World","text":"<p>Let's write the classic \"Hello, World!\" program. We'll then modify it to give it a bit of an RSL twist, demoing a couple of features rad provides.</p> <p>First, create a file, let's call it simply <code>hello</code>, and give it the following contents:</p> <pre><code>print(\"Hello, World!\") \n</code></pre> <p><code>print()</code></p> <p><code>print()</code> is the go-to function for outputting to stdout. It behaves a lot like <code>print()</code> in Python.</p> <p>You can read more about it in the reference.</p> <p>RSL Extensions</p> <p>If you want to give your RSL scripts an extension, it's recommended you follow <code>.rsl</code> as a convention.</p> <p>Then, run the script from your CLI by invoking <code>rad</code> on it, and you should see it print out like so:</p> <pre><code>&gt; rad ./hello\n</code></pre> <pre><code>Hello, World!\n</code></pre> <p>Nice! Next, let's spruce it up with a few RSL features.</p>"},{"location":"guide/getting_started/#adding-in-some-rsl-features","title":"Adding In Some RSL Features","text":"<p>One of the selling points of rad is that it makes defining arguments to your script super simple, using a declarative style.</p> <p>Let's modify the script to greet a name you input from command line.</p> <pre><code>args:\n  name string\n\nprint(\"Hello, {name}!\")\n</code></pre> <p>A couple of things to note here:</p> <ol> <li>We define an \"args block\". Right now it contains just the one line, but you can do lots of things in here.</li> <li>The modified <code>print()</code> utilizes string interpolation. String interpolation in RSL behaves a lot like it does in Python (you'll see this is a pattern).</li> </ol> <p>Now, let's try invoking the script again, and this time, input your (or someone's) name:</p> <pre><code>&gt; rad ./hello Alex\n</code></pre> <pre><code>Hello, Alex!\n</code></pre> <p>Cool! What if we invoke without a name?</p> <pre><code>&gt; rad ./hello\n</code></pre> <pre><code>Usage:\n  hello &lt;name&gt;\n\nScript args:\n      --name string\n</code></pre> <p>If you run an RSL script without providing any args to a script which expects at least one, rad will print out the script usage, interpreting your invocation similar to if you had passed <code>--help</code>.</p> <p>This shows a little of the automatic script usage string generation that rad gives you. Let's explore that a bit more.</p>"},{"location":"guide/getting_started/#improving-script-usage-string","title":"Improving Script Usage String","text":"<p>RSL facilitates writing well-documented and easy-to-use scripts, in part through unique syntax that it offers. Let's use a couple of those now.</p> <p>First, we'll add a file header to your script.</p> <pre><code>---\nPrints a polite greeting using an input name.\n---\nargs:\n  name string\n\nprint(\"Hello, {name}!\")\n</code></pre> <p>File Headers</p> <p>File headers, as the name suggests, go at the top of RSL scripts (with the exception of shebangs, to be covered later).  They allow you to write a description for your script in between two <code>---</code> lines. The contents will get printed as part of the script's usage string.</p> <p>Some ideas on what to cover in your file headers:</p> <ul> <li>A brief description of what the script does.</li> <li>Why you might want to use the script.</li> <li>Examples of valid invocations and what they do.</li> </ul> <p>Second, we can add comments to args that a script declares. Let's do that too:</p> <pre><code>---\nPrints a polite greeting using an input name.\n---\nargs:\n  name string # The name of someone to greet.\n\nprint(\"Hello, {name}!\")\n</code></pre> <p>Note on <code>#</code> vs. <code>//</code></p> <p>RSL uses <code>#</code> to denote a arg comments in RSL. <code>#</code> comments are special and do get passed to RSL's parser and can affect script behavior (namely in this case, adding information to the script usage string). </p> <p>Standard code comments in RSL use <code>//</code>, similar to Java or C/C++. These are stripped prior to parsing and don't impact script behavior.</p> <p>You can use code comments on your arg comments, if you so choose e.g.</p> <pre><code>name string # A name.  // todo make this more descriptive\n</code></pre> <p>Now, when someone reads the script, it's pretty clear what the script does and what the expected arguments are.</p> <p>But it gets better! Let's try invoking the script's usage string again (this time let's try using the <code>-h</code> flag explicitly, though it's not necessary):</p> <pre><code>&gt; rad ./hello -h\n</code></pre> <pre><code>Prints a polite greeting using an input name.\n\nUsage:\n  hello &lt;name&gt;\n\nScript args:\n      --name string   The name of someone to greet.\n</code></pre> <p>Not only is the script now easier to maintain for developers, it's also easier for users to understand!</p>"},{"location":"guide/getting_started/#shebang","title":"Shebang","text":"<p>Last thing, as part of this introduction guide.</p> <p>Needing to manually invoke <code>rad</code> each time you want to run an RSL script can be a little cumbersome. Thankfully, Unix kernels provide a mechanism known as a \"shebang\".</p> <p>Let's add one to our script. It has to go on the very first line.</p> <pre><code>#!/usr/bin/env rad\n---\nPrints a polite greeting using an input name.\n---\nargs:\n  name string # The name of someone to greet.\n\nprint(\"Hello, {name}!\")\n</code></pre> <p>Then, make the script executable using the following command:</p> <pre><code>chmod +x ./hello\n</code></pre> <p>Now, you can invoke the script directly:</p> <pre><code>&gt; ./hello Bob\n</code></pre> <pre><code>Hello, Bob!\n</code></pre> <p>Basically, when you invoke an executable script this way, the Kernel scans for a shebang (<code>#!</code>) in the first line. If it finds a path to an interpreter (in this case, it will find <code>rad</code> if you've correctly put it in your <code>PATH</code>), it will invoke said interpreter on the script (equivalent to <code>rad ./hello</code> like we were doing before).</p>"},{"location":"guide/getting_started/#learnings-summary","title":"Learnings Summary","text":"<ul> <li>We learned how to print, and saw an example of string interpolation.</li> <li>We were introduced to the args block</li> <li>We saw how we can write self-documenting scripts that also help our users by leveraging file headers and arg comments.</li> <li>We saw how we can leverage shebangs to make our scripts more convenient to run.</li> </ul> <p>Note on RSL file contents ordering</p> <p>Rad expects a certain order between shebangs, file headers, arg blocks, and the rest of your code.</p> <p>It's important to adhere to the following ordering in RSL scripts, or you'll see errors:</p> <p>1) Shebang (if present)</p> <p>2) File header (if present)</p> <p>3) Args block (if present)</p> <p>4) Rest of the file</p>"},{"location":"guide/getting_started/#next","title":"Next","text":"<p>Great job on getting this far! You've gotten a peek at what rad and RSL have to offer.</p> <p>If you're ready to dive into more details, then you can continue in the next section: Basics.</p>"},{"location":"reference/args/","title":"Args","text":""},{"location":"reference/args/#basics","title":"Basics","text":"<pre><code>args:\n    argVar \"alias\"? shorthand? type = default? # Description?\n</code></pre> <pre><code>args:\n    name n string # A required arg 'name' which can be specified positionally or also with -n.\n    is_employee \"is-employee\" bool # Variable for script is is_employee, but users will see it as is-employee.\n\nif is_employee:\n    print(\"{name} is an employee.\")\nelse:\n    print(\"{name} is not an employee.\") \n</code></pre> <pre><code>args:\n    name string\n    age_years \"age-years\" int\n    height float # Height in meters\n    is_employee \"is-employee\" e bool\n    friends string[] # Specified as e.g. Alice,Bob\n    nationality n string = \"Australian\" # Defaults to this if not specified.\n</code></pre> <p>Example usage:</p> <pre><code>script Charlie 30 -e --friends David,Eve -h 1.86\n</code></pre>"},{"location":"reference/args/#constraint-statements","title":"Constraint Statements","text":""},{"location":"reference/args/#enum","title":"Enum","text":"<pre><code>args:\n    name string\n    name enum [\"alice\", \"bob\", \"charlie\"]\n</code></pre> <pre><code>// valid!\nmyscript alice\n\n// invalid, will print error\nmyscript david\n</code></pre>"},{"location":"reference/assignment/","title":"Assignment","text":"<p>Generally speaking, multi-assignments are only legal for switch expressions, or single operations (e.g. functions) that return multiple values.</p>"},{"location":"reference/assignment/#legal-assignments","title":"Legal Assignments","text":"<pre><code>a = 1\na, b = pick_from_resoure(...)\na, b = switch ...\na, b = parse_int(text)\n\nmyMap[\"key\"] = 2\nmyList[1] = 3\n</code></pre>"},{"location":"reference/assignment/#illegal-assignments","title":"Illegal Assignments","text":"<pre><code>a, b = 1, 2\nmyMap[\"key\"], myMap[\"key2\"] = 2, 3\nmyList[1], myList[2] = 3, 4\n</code></pre>"},{"location":"reference/defer/","title":"Defer & Errdefer","text":"<ul> <li><code>defer</code> and <code>errdefer</code> run in LIFO order, each kind being part of the same one queue.</li> <li>If there are several defer statements, and one fails, further defer statements will still attempt to run.</li> <li>Rad's error code will become an error if the main script succeeded but a defer statement failed.</li> <li>errdefers will not get triggered if the main script succeeded but a <code>defer</code> or <code>errdefer</code> statement failed.</li> </ul>"},{"location":"reference/defer/#defer","title":"<code>defer</code>","text":"defer Example<pre><code>defer:\n    print(1)\n    print(2)\ndefer:\n    print(3)\n    print(4)\nprint(\"Hello!\")\n</code></pre> defer Example Output<pre><code>Hello!\n3\n4\n1\n2\n</code></pre>"},{"location":"reference/defer/#errdefer","title":"<code>errdefer</code>","text":"errdefer Example 1<pre><code>defer:\n    print(1)\n    print(2)\nerrdefer:\n    print(3)\n    print(4)\ndefer:\n    print(5)\n    print(6)\nerrdefer:\n    print(7)\n    print(8)\nprint(\"Hello!\")\nexit(0)  // successful script run\n</code></pre> errdefer Example 1 Output<pre><code>Hello!\n5\n6\n1\n2\n</code></pre> errdefer Example 2<pre><code>defer:\n    print(1)\n    print(2)\nerrdefer:\n    print(3)\n    print(4)\ndefer:\n    print(5)\n    print(6)\nerrdefer:\n    print(7)\n    print(8)\nprint(\"Hello!\")\nexit(1)  // perceived as error!\n</code></pre> errdefer Example 2 Output<pre><code>Hello!\n7\n8\n5\n6\n3\n4\n1\n2\n</code></pre>"},{"location":"reference/functions/","title":"Functions","text":""},{"location":"reference/functions/#output","title":"Output","text":""},{"location":"reference/functions/#print","title":"print","text":"<p>Description:</p> <p>Prints the given input. Includes a newline after. Stringifies whatever is given to it.</p> <pre><code>print(items ...any?)\n</code></pre> <p>Parameters:</p> <ul> <li><code>items: ...any?</code>: Zero or more items to print. If several are given, they get printed separated by spaces.</li> </ul> <p>Examples:</p> <pre><code>print(\"Hello!\")\n</code></pre> <pre><code>name = \"Alice\"\nprint(\"Hello\", name)  // prints \"Hello Alice\"\n</code></pre> <pre><code>print()  // prints a newline\n</code></pre> <pre><code>numbers = [1, 20, 300]\nprint(numbers)  // prints \"[1, 20, 300]\"\n</code></pre>"},{"location":"reference/functions/#pprint","title":"pprint","text":"<p>Description:</p> <p>Pretty prints the given input. Mainly useful for maps so they get printed in a json-style.</p> <pre><code>pprint(item any?)\n</code></pre> <p>Parameters:</p> <ul> <li><code>input: any?</code>: Zero or one item to pretty print. If zero, just prints a newline.</li> </ul> <p>Examples:</p> Example 1<pre><code>item = { \"name\": \"Alice\", age: 30 }\npprint(item)\n</code></pre> Example 1 Output<pre><code>{\n  \"name\": \"Alice\",\n  \"age\": 30\n}\n</code></pre>"},{"location":"reference/functions/#debug","title":"debug","text":"<p>Behaves like <code>print</code> but only prints if debug is enabled via the <code>--DEBUG</code> flag.</p> <pre><code>debug(items ...any?)\n</code></pre>"},{"location":"reference/functions/#misc","title":"Misc","text":""},{"location":"reference/functions/#exit","title":"exit","text":"<pre><code>exit(code int = 0)\n</code></pre>"},{"location":"reference/functions/#sleep","title":"sleep","text":"<pre><code>sleep(seconds int)\nsleep(seconds float)\nsleep(duration string)\n</code></pre>"},{"location":"reference/functions/#len","title":"len","text":"<pre><code>len(input string) -&gt; int\nlen(input any[]) -&gt; int\nlen(input map) -&gt; int\n</code></pre>"},{"location":"reference/functions/#range","title":"range","text":"<pre><code>range(end int|float) -&gt; int|float[]\nrange(start int|float, end int|float) -&gt; int|float[]\nrange(start int|float, end int|float, step int|float) -&gt; int|float[]\n</code></pre> <pre><code>range(5)         -&gt; [0, 1, 2, 3, 4]\nrange(5.5)       -&gt; [0, 1, 2, 3, 4, 5]\nrange(0.5, 5)    -&gt; [0.5, 1.5, 2.5, 3.5, 4.5]\nrange(10, 5, -2) -&gt; [10, 8, 6]\n</code></pre>"},{"location":"reference/functions/#confirm","title":"confirm","text":"<pre><code>confirm() -&gt; bool\nconfirm(prompt string) -&gt; bool\n</code></pre> Example 1<pre><code>if confirm():\n    print(\"Confirmed!\")\nelse:\n    print(\"Not confirmed!\")\n</code></pre> Example 1 Output<pre><code>Confirm? [y/n] y\nConfirmed!\n</code></pre> Example 2<pre><code>if confirm(\"Are you sure? &gt; \"):\n    print(\"You're sure!\")\nelse:\n    print(\"Unsure!\")\n</code></pre> Example 2 Output<pre><code>Are you sure? &gt; n\nUnsure!\n</code></pre>"},{"location":"reference/functions/#join","title":"join","text":"<pre><code>join(input any[], joiner string, prefix string|int|float|bool?, suffix string|int|float|bool?) -&gt; string\n</code></pre>"},{"location":"reference/functions/#unique","title":"unique","text":"<pre><code>unique(input any[]) -&gt; any[]\n</code></pre> <pre><code>unique([2, 1, 2, 3, 1, 3, 4])  // [2, 1, 3, 4]\n</code></pre>"},{"location":"reference/functions/#sort","title":"sort","text":"<pre><code>sort(input any[], reverse=bool?)\n</code></pre> <pre><code>sort([3, 4, 2, 1])                 // [1, 2, 3, 4]\nsort([3, 4, 2, 1], reversed=true)  // [4, 3, 2, 1]\nsort([3, 4, \"2\", 1, true])         // [true, 1, 3, 4, \"2\"]\n</code></pre>"},{"location":"reference/functions/#parsing","title":"Parsing","text":""},{"location":"reference/functions/#parse_int","title":"parse_int","text":"<pre><code>parse_int(input str) -&gt; int, err\n</code></pre>"},{"location":"reference/functions/#parse_float","title":"parse_float","text":"<pre><code>parse_float(input str) -&gt; float, err\n</code></pre>"},{"location":"reference/functions/#parse_json","title":"parse_json","text":"<pre><code>parse_json(input string) -&gt; any\n</code></pre>"},{"location":"reference/functions/#time","title":"Time","text":""},{"location":"reference/functions/#now_date","title":"now_date","text":"<pre><code>now_date() -&gt; string  // e.g. \"2006-11-25\"\n</code></pre>"},{"location":"reference/functions/#now_year","title":"now_year","text":"<pre><code>now_year() -&gt; int  // e.g. 2006\n</code></pre>"},{"location":"reference/functions/#now_month","title":"now_month","text":"<pre><code>now_month() -&gt; int  // e.g. 11\n</code></pre>"},{"location":"reference/functions/#now_day","title":"now_day","text":"<pre><code>now_day() -&gt; int  // e.g. 25\n</code></pre>"},{"location":"reference/functions/#now_hour","title":"now_hour","text":"<pre><code>now_hour() -&gt; int  // e.g. 14\n</code></pre>"},{"location":"reference/functions/#now_minute","title":"now_minute","text":"<pre><code>now_minute() -&gt; int  // e.g. 31\n</code></pre>"},{"location":"reference/functions/#now_second","title":"now_second","text":"<pre><code>now_second() -&gt; int  // e.g. 35\n</code></pre>"},{"location":"reference/functions/#epoch_seconds","title":"epoch_seconds","text":"<pre><code>epoch_seconds() -&gt; int  // e.g. 1731063226\n</code></pre>"},{"location":"reference/functions/#epoch_millis","title":"epoch_millis","text":"<pre><code>epoch_millis() -&gt; int  // e.g. 1731063226123\n</code></pre>"},{"location":"reference/functions/#epoch_nanos","title":"epoch_nanos","text":"<pre><code>epoch_nanos() -&gt; int  // e.g. 1731063226123456789\n</code></pre>"},{"location":"reference/functions/#text","title":"Text","text":""},{"location":"reference/functions/#upper","title":"upper","text":"<ul> <li>Preserves string color attributes.</li> </ul> <pre><code>upper(input any) -&gt; string\n</code></pre>"},{"location":"reference/functions/#lower","title":"lower","text":"<ul> <li>Preserves string color attributes.</li> </ul> <pre><code>lower(input any) -&gt; string\n</code></pre>"},{"location":"reference/functions/#replace","title":"replace","text":"<ul> <li>Does not preserve string color attributes.</li> </ul> <p>Parameters:</p> <ul> <li><code>input: string</code></li> <li><code>old: string</code>: Regex pattern of what text to replace.</li> <li><code>new: string</code>: Regex pattern of what to replace matches with.</li> </ul> <pre><code>replace(input string, old string, new string) -&gt; string\n</code></pre> <p>Examples:</p> Example 1<pre><code>input = \"Name: Charlie Brown\"\nreplace(input, \"Charlie (.*)\", \"Alice $1\") \n</code></pre> Example 1 Output<pre><code>\"Alice Brown\" \n</code></pre>"},{"location":"reference/functions/#starts_with","title":"starts_with","text":"<pre><code>starts_with(input string, substring string) -&gt; bool\n</code></pre>"},{"location":"reference/functions/#ends_with","title":"ends_with","text":"<pre><code>ends_with(input string, substring string) -&gt; bool\n</code></pre>"},{"location":"reference/functions/#truncate","title":"truncate","text":"<pre><code>truncate(input string, length int) -&gt; string\n</code></pre>"},{"location":"reference/functions/#split","title":"split","text":"<ul> <li>Does not preserve string color attributes.</li> </ul> <pre><code>split(input string, delimiter_regex string) -&gt; string[]\n</code></pre>"},{"location":"reference/functions/#maps","title":"Maps","text":""},{"location":"reference/functions/#keys","title":"keys","text":"<pre><code>keys(input map) -&gt; any[]\n</code></pre>"},{"location":"reference/functions/#values","title":"values","text":"<pre><code>values(input map) -&gt; any[]\n</code></pre>"},{"location":"reference/functions/#random","title":"Random","text":""},{"location":"reference/functions/#rand","title":"rand","text":"<pre><code>rand() -&gt; float\n</code></pre>"},{"location":"reference/functions/#rand_int","title":"rand_int","text":"<pre><code>rand_int(max int) -&gt; int\nrand_int(min int, max int) -&gt; int\n</code></pre>"},{"location":"reference/functions/#seed_random","title":"seed_random","text":"<pre><code>seed_random(seed int)\n</code></pre>"},{"location":"reference/functions/#picking","title":"Picking","text":""},{"location":"reference/functions/#pick","title":"pick","text":"<pre><code>pick(options string[], filter string?) -&gt; string\n</code></pre> <p>Named args: - <code>prompt</code></p>"},{"location":"reference/functions/#pick_kv","title":"pick_kv","text":"<pre><code>pick_kv(keys string[], values string[], filter string?) -&gt; string\n</code></pre> <p>Named args: - <code>prompt</code></p>"},{"location":"reference/functions/#pick_from_resource","title":"pick_from_resource","text":"<pre><code>pick_from_resource(resource_path string, filter string?) -&gt; any...\n</code></pre>"},{"location":"reference/functions/#http","title":"HTTP","text":"<p>Map outputs contain the following keys: - <code>status_code</code> - <code>body</code></p> <p>Failed queries (e.g. invalid url, no response) will result in an error and script exit.</p>"},{"location":"reference/functions/#http_get","title":"http_get","text":"<pre><code>http_get(url string) -&gt; map\nhttp_get(url string, headers = map) -&gt; map\n</code></pre>"},{"location":"reference/functions/#http_post","title":"http_post","text":"<pre><code>http_post(url string, body any?) -&gt; map\nhttp_post(url string, body any?, headers = map) -&gt; map\n</code></pre>"},{"location":"reference/functions/#http_put","title":"http_put","text":"<pre><code>http_put(url string, body any?) -&gt; map\nhttp_put(url string, body any?, headers = map) -&gt; map\n</code></pre>"},{"location":"reference/functions/#math","title":"Math","text":""},{"location":"reference/functions/#abs","title":"abs","text":"<pre><code>abs(int) -&gt; int\nabs(float) -&gt; float\n</code></pre>"},{"location":"reference/logic/","title":"Boolean Logic","text":""},{"location":"reference/logic/#truthy-falsy","title":"Truthy / Falsy","text":"<p>RSL supports truthy/falsy logic.</p> <p>For those unfamiliar, this means that, instead of writing the following (as an example):</p> <pre><code>if len(myList) &gt; 0:\n    print(\"My list has elements!\")\n</code></pre> <p>you can write</p> <pre><code>if myList:\n    print(\"My list has elements!\")\n</code></pre> <p>Essentially, you can use any type as a condition, and it will resolve to true or false depending on the value.</p> <p>See below for which values for each type will resolve to false. All other values will resolve to true.</p> Type Falsy string <code>\"\"</code> int <code>0</code> float <code>0.0</code> list <code>[]</code> map <code>{}</code> <p>Note that a string which is all whitespace e.g. <code>\" \"</code> is truthy.</p>"},{"location":"reference/rad-blocks/","title":"Rad Blocks","text":""},{"location":"reference/rad-blocks/#rad-block","title":"<code>rad</code> block","text":"<pre><code>rad url:\n    fields Name, Birthdate, Height\n    Name:\n        map n -&gt; truncate(n, 20)\n    if sort_by_height:\n        sort Height, Name, Birthdate\n    else:\n        sort\n</code></pre>"},{"location":"reference/rad-blocks/#request-block","title":"<code>request</code> block","text":"<pre><code>request url:\n    fields Name, Birthdate, Height\n</code></pre>"},{"location":"reference/rad-blocks/#display-block","title":"<code>display</code> block","text":"<pre><code>display:\n    fields Name, Birthdate, Height\n</code></pre>"},{"location":"reference/shell-commands/","title":"Shell Commands","text":""},{"location":"reference/shell-commands/#basic-shell-commands","title":"Basic Shell Commands","text":"<pre><code>$`ls -l`\nfail:\n    print(\"Command failed! Exiting script!\")\n</code></pre> <pre><code>$`ls -l`\nrecover:\n    print(\"Command failed! Continuing script...\")\n</code></pre>"},{"location":"reference/shell-commands/#critical-shell-commands","title":"Critical Shell Commands","text":"<pre><code>$!`ls -l`\n</code></pre>"},{"location":"reference/shell-commands/#unsafe-shell-commands","title":"Unsafe Shell Commands","text":"<pre><code>unsafe $`ls -l`\n</code></pre>"},{"location":"reference/shell-commands/#output-capture","title":"Output Capture","text":"<pre><code>err_code = $!`ls -l`\nerr_code, stdout = $!`ls -l`\nerr_code, stdout, stderr = $!`ls -l`\n</code></pre>"},{"location":"reference/shell-commands/#suppress-announcements","title":"Suppress Announcements","text":"<p>By default, Rad will 'announce' (i.e. print) commands as they're executed. Example:</p> Without quiet<pre><code>$!`ls`\n$!`echo hello`\n</code></pre> Without quiet output<pre><code>\u26a1\ufe0f Running: ls\npick.rsl  simple.rsl  sorting.rsl\n\u26a1\ufe0f Running: echo hello\nhello\n</code></pre> <p>These announcements can be suppressed with the <code>quiet</code> keyword. It does not impact stdout/stderr output for the command.</p> With quiet<pre><code>quiet $!`ls`\nquiet $!`echo hello`\n</code></pre> With quiet output<pre><code>pick.rsl  simple.rsl  sorting.rsl\nhello\n</code></pre>"},{"location":"reference/strings/","title":"Strings","text":"<p>RSL has three delimiters for strings:</p> <pre><code>\"double quotes\"\n'single quotes'\n`backticks`\n</code></pre> <p>All three of these behave the same way. RSL offers three so you have alternatives to pick between depending on the contents of your string. For example, if you have a string which itself contains lots of single quotes, you may choose to use the double quotes delimiter. Or, if your string has both single and double quotes, you can use backticks to delimit your string. Specific example:</p> <pre><code>`Single quotes: 'Hi!', double quotes: \"Hi!\"`\n</code></pre>"},{"location":"reference/strings/#escaping","title":"Escaping","text":"<ul> <li><code>\\</code> will escape:<ul> <li><code>{</code> (to prevent string interpolation)</li> <li><code>\\n</code> new line</li> <li><code>\\t</code> tab</li> <li><code>\\</code> i.e. itself, so you can write backslashes</li> <li>The respective string delimiter itself, so <code>\\\"</code>, <code>\\'</code>, or <code>\\`</code>, epending on the string you're using. <ul> <li>However, it's advised to instead mix string delimiters instead, especially with backticks. So respectively: <code>`\"`</code>, <code>`'`</code>.</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/strings/#string-attributes","title":"String Attributes","text":"<ul> <li>Not all strings are just plain text. They may have attributes such as color.</li> <li>This means that RSL contains logic on how to handle attributes when strings are combined or operated on<ul> <li>e.g. concatenation, slicing, replace functions, etc</li> </ul> </li> <li>The following operations maintain color attributes:<ul> <li>concatenation</li> <li>index lookup</li> </ul> </li> <li>The following do not, and just return a plain string:<ul> <li>slicing (to be added)</li> <li>functions: <code>replace</code>, <code>split</code></li> </ul> </li> <li>Attributes do not impact things like equality or comparing strings.<ul> <li>A green string \"Alice\" and a yellow string \"Alice\" will be considered 'equal'.</li> </ul> </li> </ul>"},{"location":"reference/strings/#string-interpolation","title":"String Interpolation","text":""},{"location":"reference/strings/#formatting","title":"Formatting","text":"<ul> <li>Float formatting does not require a <code>f</code> at the end.<ul> <li>Correct: <code>{myFloat:.2}</code></li> <li>Incorrect: <code>{myFloat:.2f}</code></li> </ul> </li> </ul> <p>Examples:</p> <pre><code>\"{myString:20}\"\n\"{myString:&lt;20}\"\n\"{myString:&gt;20}\"\n\"{myFloat:.2}\"\n</code></pre>"}]}