{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to Rad","text":"greet.rad <pre><code>#!/usr/bin/env rad\nargs:\n    name str        # Name to greet.\n    times int = 1   # How many times.\n\nfor i in range(times):\n    print(\"Hello, {name}!\")\n</code></pre>"},{"location":"#rad","title":"Rad","text":"<p> A scripting language designed to make writing CLI tools delightful. Familiar, Python-like syntax with CLI superpowers built-in. </p> <p>Get Started View Examples</p>"},{"location":"#why-rad","title":"Why Rad?","text":"<p>No boilerplate. Declarative argument parsing, built-in JSON processing, and shell integration\u2014all in a clean, readable syntax.</p> <p>Familiar. If you know Python, you already know most of Rad. The learning curve is gentle; the productivity gains are immediate.</p> <p>Delightful. Rad is designed to be fun to use. Small touches like helpful error messages and intuitive syntax make scripting enjoyable again.</p>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>&gt; ./greet --help\nUsage:\n  greet &lt;name&gt; [times]\n\nScript args:\n      --name str    Name to greet.\n      --times int   How many times. (default 1)\n</code></pre> <pre><code>&gt; ./greet Alice --times 2\nHello, Alice!\nHello, Alice!\n</code></pre>"},{"location":"#explore","title":"Explore","text":"<ul> <li>Getting Started \u2013 Installation &amp; your first script</li> <li>Args \u2013 Declarative argument parsing</li> <li>Rad Blocks \u2013 JSON processing &amp; API queries</li> <li>Shell Commands \u2013 Running shell commands</li> <li>Examples \u2013 Real-world scripts</li> </ul> <p>Early Development</p> <p>Rad is in early development but useful today. Core features work well, though expect breaking changes between versions. Feedback welcome!</p>"},{"location":"releases/","title":"Release Notes","text":"<p>All Rad releases. Newest first.</p>"},{"location":"releases/#v080-2026-01-29","title":"v0.8.0 - 2026-01-29","text":"<ul> <li>feat!: remove get_default function in favor of ?? operator (7bbad61)</li> <li>feat(docs): redesign website with \"Sunset Terminal\" theme (79b0103)</li> <li>feat: add ?? fallback support for list and string indexing (7350604)</li> <li>feat: add list support to reverse function (d13e6d7)</li> <li>feat: hyphenate command names for CLI invocation (c8373a2)</li> <li>fix: use workflow_run trigger for release notes workflow (7c450bf)</li> </ul>"},{"location":"releases/#v071-2026-01-26","title":"v0.7.1 - 2026-01-26","text":"<ul> <li>Release VSCode extension v0.3.0 (9443d85)</li> <li>ci: add automated docs deployment and release notes (883a593)</li> <li>ci: add cross-platform testing for macOS and Windows (e085011)</li> <li>ci: fix Windows build output filename in cross-platform tests (4474ee3)</li> <li>ci: treat all platforms as equal first-class citizens (668a509)</li> <li>feat: add platform abstraction for Windows compatibility (5fdf8fd)</li> <li>feat: add underscore to v0.7 for-loop migration hint detection (cf4af1a)</li> <li>feat: complete platform normalization for Windows compatibility (83c839e)</li> <li>fix: improve gen_fid collision resistance (0ee37ff)</li> </ul>"},{"location":"releases/#v070-2026-01-16","title":"v0.7.0 - 2026-01-16","text":"<ul> <li>docs(SYNTAX.md): add script commands  (9e4e595)</li> <li>feat!: redesign for-loop syntax with explicit context access  (e98f7fc)</li> <li>See v0.7 migration guide for more information.</li> <li>feat: add context support to rad block map/filter lambdas  (21976ec)</li> </ul>"},{"location":"releases/#v0627-2026-01-11","title":"v0.6.27 - 2026-01-11","text":"<ul> <li>Release VSCode extension v0.2.0 (80c4102)</li> <li>fix: multiline string interpolation followed by content (5365366)</li> </ul>"},{"location":"releases/#v0626-2026-01-02","title":"v0.6.26 - 2026-01-02","text":"<ul> <li>ci: optimize ci benchmarks by interleaving &amp; reducing runs (3a4a7f4)</li> <li>feat(pick): implement 'prefer_exact' named arg (a3092c7)</li> <li>feat: improve syntax error messages with specific diagnostics (82d9472)</li> <li>feat: unpackage radls from vs code extension, use PATH instead (d79186f)</li> </ul>"},{"location":"releases/#v0625-2025-12-16","title":"v0.6.25 - 2025-12-16","text":"<ul> <li>Release VSCode extension v0.1.13 (c492a49)</li> <li>docs(thinking): Rewrite imports.md and add some quick counter thoughts (f50a960)</li> <li>feat: add additional get_path fields e.g. modified_millis (f536f12)</li> <li>feat: allow parse_epoch to accept floats (c15def5)</li> <li>fix: avoid Go 'MISSING' formatting malformed print in shell cmds (6a69141)</li> </ul>"},{"location":"releases/#v0624-2025-12-14","title":"v0.6.24 - 2025-12-14","text":"<ul> <li>feat: add flat_map function (0f72798)</li> </ul>"},{"location":"releases/#v0623-2025-12-10","title":"v0.6.23 - 2025-12-10","text":"<ul> <li>feat: allow min/max to accept var args of numbers  (fb6582d)</li> </ul>"},{"location":"releases/#v0621-2025-12-03","title":"v0.6.21 - 2025-12-03","text":"<ul> <li>ci: use full brew hash (4dfb9ed)</li> </ul>"},{"location":"releases/#v0620-2025-12-03","title":"v0.6.20 - 2025-12-03","text":"<ul> <li>ci: attempt brew CI fix by pulling latest commit (775afad)</li> </ul>"},{"location":"releases/#v0619-2025-12-02","title":"v0.6.19 - 2025-12-02","text":"<ul> <li>ci: attempt to fix homebrew release (da006f4)</li> </ul>"},{"location":"releases/#v0618-2025-11-29","title":"v0.6.18 - 2025-11-29","text":"<ul> <li>feat: implement 'filter' rad block field modifier syntax (022267b)</li> <li>fix: un-indent command descriptions (5f1480e)</li> </ul>"},{"location":"releases/#v0617-2025-11-20","title":"v0.6.17 - 2025-11-20","text":"<ul> <li>Release VSCode extension v0.1.12 (d70dbbe)</li> <li>feat(checker): add warning against undefined cmd callback references (868d6f8)</li> <li>feat: add function 'multipick' (8c96666)</li> <li>fix: delete pointless multipick tests (6a0ebba)</li> </ul>"},{"location":"releases/#v0616-2025-11-19","title":"v0.6.16 - 2025-11-19","text":"<ul> <li>Implement commands in Rad (cef9661)</li> </ul>"},{"location":"releases/#v0615-2025-11-09","title":"v0.6.15 - 2025-11-09","text":"<ul> <li>Release VSCode extension v0.1.11 (1c6bb65)</li> <li>feat: recognize hoisted functions for unknown functions check (e535795)</li> <li>fix: allow --version --src and --src-tree on invalid scripts (4220c18)</li> <li>fix: avoid passing arg-less prints through printf (7e16b1a)</li> <li>fix: fix x/crypto dependency (5bb2ea7)</li> </ul>"},{"location":"releases/#v0614-2025-11-04","title":"v0.6.14 - 2025-11-04","text":"<ul> <li>feat(check): add error check against hoisted functions shadowing args (ff839e6)</li> <li>feat: allow non-str types in colorize function (ba71c19)</li> </ul>"},{"location":"releases/#v0613-2025-11-03","title":"v0.6.13 - 2025-11-03","text":"<ul> <li>Release VSCode extension v0.1.10 (e27b21c)</li> <li>ci: fix test-runner.rad syntax (18c9bad)</li> <li>docs(guide): add complete example to getting started (c4df48a)</li> <li>docs(guide): add error-handling.md (4a7f9f5)</li> <li>docs(guide): add type-annotations.md (20fe398)</li> <li>docs(guide): shorten shell-commands.md header (d704c25)</li> <li>docs(guide): update args.md (ab615c6)</li> <li>docs(guide): update basics.md (0a38d12)</li> <li>docs(guide): update functions.md (67b5fdc)</li> <li>docs(guide): update getting started (7974f4c)</li> <li>docs(guide): update rad-blocks.md (5c58d83)</li> <li>docs(guide): update shell-commands.md (863c3c1)</li> <li>docs(guide): update strings-advanced.md (2776ef6)</li> <li>feat: revamp http url encoding behavior (d91350b)</li> <li>fix(fomatting): accept thousands_separator before alignment/padding (c18c971)</li> <li>fix(shell): fix shell modifier keywords (e448f72)</li> <li>fix: check built-in function signatures for parsing errors (17b14fe)</li> <li>fix: use Print, not Printf for --src (8579dac)</li> <li>tests: fix broken tests from earlier commit (0dba710)</li> </ul>"},{"location":"releases/#v0612-2025-10-16","title":"v0.6.12 - 2025-10-16","text":""},{"location":"releases/#breaking","title":"Breaking!","text":"<p>This release changes shell and error handling syntax, expect breaks.</p> <pre><code>// OLD: Critical command\n$!`make build`\n\n// NEW: Same behavior (critical by default)\n$`make build`\n\n// OLD: Unsafe command\nunsafe $`command_that_might_fail`\n\n// NEW: Use catch block\n$`command_that_might_fail` catch:\n    pass\n\n// OLD: Recover block\n$`curl {url}`\nrecover:\n    print_err(\"Failed but continuing\")\n\n// NEW: Use catch block\n$`curl {url}` catch:\n    print_err(\"Failed but continuing\")\n\n// OLD: Fail block\n$`curl {url}`\nfail:\n    print_err(\"Failed, exiting\")\n    exit(1)\n\n// NEW: Use catch block with exit\n$`curl {url}` catch:\n    print_err(\"Failed, exiting\")\n    exit(1)\n</code></pre> <ul> <li>Release VSCode extension v0.1.9  (46e3eed)</li> <li>feat: implement new error handling syntax (catch suffix)  (5c0253c)</li> <li>feat: implement new shell syntax + catch suffix syntax  (7ef3f46)</li> <li>feat: update syntax dump tests for new shell &amp; error handling syntax  (78a4857)</li> <li>feat: update textmate grammar for new shell + error handling syntax  (981fdfb)</li> </ul>"},{"location":"releases/#v0611-2025-10-12","title":"v0.6.11 - 2025-10-12","text":"<ul> <li>feat: add --from-logs flag to check cmd (468b455)</li> <li>feat: add global config loading (a068c49)</li> <li>feat: add invocation logging &amp; rolling (c5ee8e7)</li> <li>refactor: move Run up in runner.go (2257aa7)</li> </ul>"},{"location":"releases/#v0610-2025-10-06","title":"v0.6.10 - 2025-10-06","text":"<ul> <li>Release VSCode extension v0.1.8 (5b94a4e)</li> <li>feat: add stdin support for Unix-style piping (cd880f7)</li> </ul>"},{"location":"releases/#v069-2025-10-05","title":"v0.6.9 - 2025-10-05","text":"<ul> <li>feat: allow scientific notation for int defaults (8fd724a)</li> <li>feat: validate script immediately after parsing (127f484)</li> <li>fix: correctly allow unknown flags to be absorbed in var args (34ee9be)</li> <li>fix: resolve shell command pipe race condition (319a956)</li> </ul>"},{"location":"releases/#v068-2025-09-30","title":"v0.6.8 - 2025-09-30","text":"<ul> <li>Release VSCode extension v0.1.7 (4b6613e)</li> <li>ci: implement 5 more PR benchmarks (f8310f0)</li> <li>feat: allow int short count arg input style (05b7ee2)</li> </ul>"},{"location":"releases/#v067-2025-09-28","title":"v0.6.7 - 2025-09-28","text":"<ul> <li>Bump version to v0.6.7 (379d785)</li> <li>ci: add PR benchmarking (046a3c2)</li> <li>ci: add PR check automation (9efd9b4)</li> <li>ci: add benchmark-scripts (7f6349c)</li> <li>feat: support formatting numbers with commas separating thousands (9e2bc45)</li> <li>tests: fix local TZ-dependent time tests (8e2dd59)</li> </ul>"},{"location":"releases/#v066-2025-09-27","title":"v0.6.6 - 2025-09-27","text":"<ul> <li>ci: iterate goreleaser (f3a331a)</li> </ul>"},{"location":"releases/#v065-2025-09-27","title":"v0.6.5 - 2025-09-27","text":"<ul> <li>ci: iterate goreleaser (284797b)</li> </ul>"},{"location":"releases/#v062-2025-09-21","title":"v0.6.2 - 2025-09-21","text":""},{"location":"releases/#v061-2025-09-21","title":"v0.6.1 - 2025-09-21","text":""},{"location":"releases/#v060-2025-09-21","title":"v0.6.0 - 2025-09-21","text":"<ul> <li>fix: returning from fn in for loop by @amterp in https://github.com/amterp/rad/pull/44</li> <li>feat(args): support var args by @amterp in https://github.com/amterp/rad/pull/45</li> </ul>"},{"location":"releases/#v0559-2025-09-14","title":"v0.5.59 - 2025-09-14","text":"<ul> <li>Replace pflag with Ra by @amterp in https://github.com/amterp/rad/pull/38</li> <li>feat: add function 'matches' for regex matching by @amterp in https://github.com/amterp/rad/pull/39</li> <li>fix: convert arg constraint targets to external name format by @amterp in https://github.com/amterp/rad/pull/40</li> <li>feat: add global flag '--rad-args-dump' by @amterp in https://github.com/amterp/rad/pull/41</li> <li>feat(repl): implement REPL by @amterp in https://github.com/amterp/rad/pull/43</li> </ul>"},{"location":"releases/#historical-releases","title":"Historical Releases","text":"<p>Releases before automated GitHub releases. Notable changes only.</p>"},{"location":"releases/#v05-2025-02-12","title":"v0.5 - 2025-02-12","text":"<ul> <li>Replaced handwritten lexer/parser with tree sitter</li> <li><code>defer</code> statements</li> <li>Further shell command support improvements, critical shell commands</li> <li>Emoji support</li> <li>Basic syntax highlighter</li> <li>Reworked JSON field extraction algo</li> <li><code>errdefer</code></li> <li>Reworked string character escaping</li> <li>Improved rad block sorting operation, added matching <code>sort</code> function</li> <li>Added more functions: <code>confirm</code>, <code>range</code>, <code>split</code> etc</li> <li>Removed Cobra</li> <li>Reworked strings (<code>RslString</code>, attributes, colors)</li> <li>http functions</li> <li>parsing functions e.g. parse_int, parse_float</li> <li><code>.dot.syntax</code> for map key access</li> <li>Truthy/falsy logic</li> <li>Raw strings</li> <li>Multiline strings</li> <li>Arg constraints - enum, regex</li> <li>Modulo operator <code>%</code></li> <li><code>++</code>/<code>--</code> operators</li> </ul>"},{"location":"releases/#v04-2024-10-28","title":"v0.4 - 2024-10-28","text":"<ul> <li><code>exit</code> function</li> <li>Allow output pass-through in <code>rad</code> blocks</li> <li><code>rad</code> field modifiers: <code>truncate</code>, <code>color</code></li> <li>Reworked arrays: all arrays now allow mixed types</li> <li>maps</li> <li>collection entry assignment</li> <li><code>del</code></li> <li><code>in</code> and <code>not in</code></li> <li>Json algo: allow capturing json nodes as maps</li> <li>Added list/string slicing</li> <li>Improved indexing, including negative indexing</li> <li>Added ternary expressions</li> <li>Added inline expressions for string interpolation, including formatting</li> <li>Implemented shell command invocation</li> </ul>"},{"location":"releases/#v03-2024-09-29","title":"v0.3 - 2024-09-29","text":"<ul> <li>Improved shell embedding</li> <li>Improved table-to-terminal size adjustment</li> <li>Good unit testing</li> <li>Compound assignments</li> <li>Allow mocking responses <code>--MOCK-RESPONSE</code></li> <li>Json algo: add <code>*</code> wildcard capture</li> <li><code>rad</code> sort statements</li> <li>Colorized headers</li> <li>Switch from <code>int</code> to <code>int64</code> representation of ints</li> <li>Add <code>pick</code> functions, including <code>pick_from_resource</code></li> <li>Add list comprehensions</li> <li><code>request</code> and <code>display</code> blocks</li> </ul>"},{"location":"releases/#v02-2024-09-09","title":"v0.2 - 2024-09-09","text":"<ul> <li>Added Apache License 2.0</li> <li>Arg defaults</li> <li>std functions: date functions, replace, join, upper/lower, etc</li> <li>'Single quote' strings</li> </ul>"},{"location":"releases/#v01-2024-09-08","title":"v0.1 - 2024-09-08","text":"<ul> <li>Initial version</li> <li>Newest notable feature was <code>--STDIN</code> and output shell export commands.</li> </ul>"},{"location":"status/","title":"Project Status","text":"<p>Rad is in early development but actively maintained and useful for real scripts today.</p> <p>What this means:</p> <ul> <li>Core features work well</li> <li>Actively maintained and improving</li> <li>Breaking changes may occur between minor versions</li> <li>Some rough edges and missing features remain</li> </ul>"},{"location":"status/#platform-support","title":"Platform Support","text":"Platform Status Notes macOS Fully Supported Primary development platform Linux Fully Supported Works well due to Unix similarity Windows Experimental Limited support, some features unavailable"},{"location":"status/#macos","title":"macOS","text":"<p>Primary development and testing platform. All features fully supported on both Apple Silicon (arm64) and Intel (amd64).</p>"},{"location":"status/#linux","title":"Linux","text":"<p>Works reliably due to Unix similarity. Statically linked binaries provide broad compatibility across distributions. Both amd64 and arm64 architectures supported.</p>"},{"location":"status/#windows","title":"Windows","text":"<p>Experimental support - use with caution.</p> <ul> <li>Shell command integration (<code>$`...`</code>) does not currently work</li> <li>Some edge cases may have bugs</li> <li>Only x86-64 (Intel/AMD) architecture currently available (no ARM)</li> <li>Community bug reports welcome to help improve support</li> </ul>"},{"location":"status/#near-term-focus","title":"Near-term Focus","text":"<p>We're balancing quick wins (new functions, bug fixes) with building out major features so we can learn how they fit together as the language evolves.</p> <p>Currently we're working on:</p> <ul> <li>Continuing to build out the script command syntax</li> <li>Iterating and adding to the json path syntax</li> <li>Making errors more informative and user-friendly</li> <li>Improving IDE integrations &amp; support</li> <li>Ongoing: bug fixes, new functions, documentation improvements</li> </ul>"},{"location":"status/#long-term-vision","title":"Long-term Vision","text":"<p>Rad aims to be the best way to write CLI scripts. That's a high bar, and we're building toward it deliberately.</p> <p>What this means:</p> <ul> <li>Rad scripts will need to cover as many use cases as possible</li> <li>Writing idiomatic Rad should be natural and easy, and the result should be better than equivalent scripts in other languages</li> <li>Writing and reading Rad should be a joy</li> <li>User-friendly errors, clear syntax for newcomers, high-quality documentation, etc</li> <li>Top-class tooling and supporting infrastructure</li> <li>Language servers, static analysis, editor integrations, easy installation, etc</li> </ul> <p>This is a long-term ambition, and we're building it piece by piece.</p>"},{"location":"status/#get-involved","title":"Get Involved","text":"<p>Your feedback directly shapes the language!</p> <ul> <li>GitHub Discussions - Questions, ideas, and general discussion</li> <li>GitHub Issues - Bug reports and feature requests</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>Real-world scripts demonstrating Rad's features in practice.</p> Example Description Demonstrates brewi Check a Homebrew formula before installing Args, shell commands, <code>confirm()</code> prompt epoch Convert epoch timestamps across timezones Optional args, <code>display</code> blocks, <code>.map()</code>, loop unpacking hm Personal command cheatsheet manager Stashes, script commands, file storage"},{"location":"examples/brewi/","title":"brewi","text":""},{"location":"examples/brewi/#preview","title":"Preview","text":"<pre><code>#!/usr/bin/env rad\n---\nFacilitates checking a brew formula before installing it.\n---\nargs:\n    formula str    # Name of the formula to install.\n    cask c bool    # Enable if it's a cask.\n\n$`brew info {formula}`\nif confirm():\n    $`brew install{cask ? \" --cask\" : \"\"} {formula}`\n</code></pre> <pre><code>&gt; brewi -h\nFacilitates checking a brew formula before installing it.\n\nUsage:\n  brewi &lt;formula&gt; [cask]\n\nScript args:\n      --formula str      Name of the formula to install.\n  -c, --cask             Enable if it's a cask.\n</code></pre>"},{"location":"examples/brewi/#tutorial-building-brewi","title":"Tutorial: Building <code>brewi</code>","text":""},{"location":"examples/brewi/#motivation","title":"Motivation","text":"<p>I tend to run <code>brew info</code> before installing formulas just to double-check that I've got the right one. Most of the time, it is, so I follow that with a <code>brew install</code>.</p> <p>Rather than writing out these two commands manually each time, it'd be neat if I had an alias, which not only saved some characters, but did this workflow for me.</p>"},{"location":"examples/brewi/#writing-the-script","title":"Writing the script","text":"<p>We can use <code>rad</code> to create the script file for us. The <code>-s</code> flag gives us a minimal template with just a shebang, and <code>-o code</code> opens it in VS Code.</p> <pre><code>rad new brewi -s -o code\n</code></pre> <p>First, we want to quickly describe what the script is aiming to do, so we'll add a file header.</p> <pre><code>#!/usr/bin/env rad\n---\nFacilitates checking a brew formula before installing it.\n---\n</code></pre> <p>We want the script to accept a formula as an argument, i.e. the formula we may be installing. It'll be a string, so let's add this in an arg block. We'll include a little comment to improve our usage string.</p> <pre><code>#!/usr/bin/env rad\n---\nFacilitates checking a brew formula before installing it.\n---\nargs:\n    formula string # Name of the formula to install.\n</code></pre> <p><code>formula</code> will serve both as the variable name for the rest of the script, and be exposed to the user as the script's CLI API.</p> <p>Setup done. First thing we'll wanna do is run <code>brew info</code> with the formula. We'll do this via a shell command.</p> <p>Specifically, we'll use a critical shell command, because if the command fails (including if the formula just doesn't exist), we want to just print the error and exit the script.</p> <p>This uses the <code>$</code> syntax.</p> <pre><code>#!/usr/bin/env rad\n---\nFacilitates checking a brew formula before installing it.\n---\nargs:\n    formula string # Name of the formula to install.\n\n$`brew info {formula}`\n</code></pre> <p>We use string interpolation to insert the formula into the command.</p> <p>You can try running the command now! Make sure it's executable (<code>chmod +x ./brewi</code>).</p> <p>Next, we want to ask the user if they'd like to proceed with installing the formula. For that, Rad offers the <code>confirm</code> function. The default prompt is <code>Confirm? [Y/n] &gt;</code>, which works fine for us here, so we'll do a simple 0-arg <code>confirm()</code> call. The function returns a bool for yes/no, so we'll put it in an if statement.</p> <pre><code>#!/usr/bin/env rad\n---\nFacilitates checking a brew formula before installing it.\n---\nargs:\n    formula string # Name of the formula to install.\n\n$`brew info {formula}`\nif confirm():\n    $`brew install {formula}`\n</code></pre> <p>Feel free to try it again now!</p> <p>One last touch: we should also allow installing casks with this script. We'll aim to offer a simple <code>-c</code> flag users can set which modifies the command. </p> <p>We'll add the <code>bool</code> arg, and insert an additional interpolation in our <code>brew install</code> command, leveraging Rad's ternary syntax. We need to pay close attention to whitespace so we make sure the command comes out correct in the cask and non-cask cases.</p> <pre><code>#!/usr/bin/env rad\n---\nFacilitates checking a brew formula before installing it.\n---\nargs:\n    formula string # Name of the formula to install.\n    cask c bool    # Enable if it's a cask.\n\n$`brew info {formula}`\nif confirm():\n    $`brew install{cask ? \" --cask\" : \"\"} {formula}`\n</code></pre> <p>Note the shorthand flag in <code>cask c bool</code>.</p> <p>Done! You've now got a great, convenient helper script for installing things with brew :)</p>"},{"location":"examples/brewi/#concepts-demonstrated","title":"Concepts demonstrated","text":"Concept Where File header Script description for <code>--help</code> Args block <code>formula str</code>, <code>cask c bool</code> Short flags <code>cask c bool</code> gives <code>-c</code> Shell commands <code>$\\</code>brew info {formula}`` String interpolation <code>{formula}</code> in shell command <code>confirm()</code> Interactive yes/no prompt Ternary operator <code>cask ? \" --cask\" : \"\"</code>"},{"location":"examples/epoch/","title":"epoch","text":""},{"location":"examples/epoch/#preview","title":"Preview","text":"<pre><code>#!/usr/bin/env rad\n---\nConvert epoch timestamps to human-readable times across multiple timezones.\n---\nargs:\n    epoch int?  # Epoch time to convert. Defaults to current time if omitted.\n\nif not epoch:\n    epoch = now().epoch.millis\n    print(\"Epoch millis: {epoch.yellow()}\")\n\ntz_to_flag = [\n    ['Europe/London', '\ud83c\uddec\ud83c\udde7'],\n    ['America/New_York', '\ud83c\uddfa\ud83c\uddf8'],\n    ['Asia/Tokyo', '\ud83c\uddef\ud83c\uddf5'],\n    ['Australia/Melbourne', '\ud83c\udde6\ud83c\uddfa'],\n]\n\nTimezone = tz_to_flag.map(fn(x) \"{x[1]} {x[0]}\")\n\nTime = []\nfor tz, _ in tz_to_flag:\n    time = parse_time(epoch, tz)\n    Time += [time]\n\ndisplay:\n    fields Timezone, Time\n\nfn parse_time(epoch: int, tz: str) -&gt; str:\n    time = parse_epoch(epoch, tz=tz)\n    return \"{time.date} {time.time}\"\n</code></pre> <pre><code>&gt; epoch -h\nConvert epoch timestamps to human-readable times across multiple timezones.\n\nUsage:\n  epoch [epoch] [OPTIONS]\n\nScript args:\n      --epoch int   (optional) Epoch time to convert. Defaults to current time if omitted.\n</code></pre> <pre><code>&gt; epoch 1700000000000\nTimezone                Time\n\ud83c\uddec\ud83c\udde7 Europe/London         2023-11-14 22:13:20\n\ud83c\uddfa\ud83c\uddf8 America/New_York      2023-11-14 17:13:20\n\ud83c\uddef\ud83c\uddf5 Asia/Tokyo            2023-11-15 07:13:20\n\ud83c\udde6\ud83c\uddfa Australia/Melbourne   2023-11-15 09:13:20\n\n&gt; epoch\nEpoch millis: 1769378597483\nTimezone                Time\n\ud83c\uddec\ud83c\udde7 Europe/London         2026-01-25 22:03:17\n\ud83c\uddfa\ud83c\uddf8 America/New_York      2026-01-25 17:03:17\n\ud83c\uddef\ud83c\uddf5 Asia/Tokyo            2026-01-26 07:03:17\n\ud83c\udde6\ud83c\uddfa Australia/Melbourne   2026-01-26 09:03:17\n</code></pre>"},{"location":"examples/epoch/#tutorial-building-epoch","title":"Tutorial: Building <code>epoch</code>","text":""},{"location":"examples/epoch/#motivation","title":"Motivation","text":"<p>When debugging distributed systems or reading logs, you'll often encounter epoch timestamps - large integers representing milliseconds (or seconds, or nanoseconds) since 1970. Converting these to human-readable times is tedious, and when you're coordinating across timezones, you often want to see the same moment in multiple locations at once.</p> <p>Let's build a script that converts an epoch timestamp into a table showing that moment across several timezones.</p>"},{"location":"examples/epoch/#writing-the-script","title":"Writing the script","text":"<p>We can use <code>rad</code> to create the script file for us.</p> <pre><code>rad new epoch -s\n</code></pre> <p>This will set us up with an executable script named <code>epoch</code>, and the <code>-s</code> simplifies the template it's instantiated with to contain just a shebang.</p> <p>The shebang will allow us to invoke the script as <code>epoch</code> from the CLI rather than writing out <code>rad ./epoch</code>. Open up <code>epoch</code> in your editor, and you should see something like this:</p> <pre><code>#!/usr/bin/env rad\n</code></pre> <p>Let's begin editing it. First, we want to quickly describe what the script is aiming to do, so we'll add a file header.</p> <pre><code>#!/usr/bin/env rad\n---\nConvert epoch timestamps to human-readable times across multiple timezones.\n---\n</code></pre>"},{"location":"examples/epoch/#adding-an-optional-argument","title":"Adding an optional argument","text":"<p>We want the script to accept an epoch timestamp, but it should also work without one - defaulting to the current time. We declare this with <code>int?</code>, where the <code>?</code> makes it optional (it will be <code>null</code> if not provided).</p> <pre><code>#!/usr/bin/env rad\n---\nConvert epoch timestamps to human-readable times across multiple timezones.\n---\nargs:\n    epoch int?  # Epoch time to convert. Defaults to current time if omitted.\n</code></pre> <p>Now we handle the case where no epoch was provided:</p> <pre><code>#!/usr/bin/env rad\n---\nConvert epoch timestamps to human-readable times across multiple timezones.\n---\nargs:\n    epoch int?  # Epoch time to convert. Defaults to current time if omitted.\n\nif not epoch:\n    epoch = now().epoch.millis\n    print(\"Epoch millis: {epoch.yellow()}\")\n</code></pre> <p>The <code>now()</code> function returns a map with various time fields. We access <code>.epoch.millis</code> to get the current epoch in milliseconds, then print it so the user knows what value we're working with.</p>"},{"location":"examples/epoch/#setting-up-our-timezone-data","title":"Setting up our timezone data","text":"<p>We'll store our timezones alongside their flag emoji in a list of pairs. Each inner list contains <code>[timezone_id, flag]</code>:</p> <pre><code>#!/usr/bin/env rad\n---\nConvert epoch timestamps to human-readable times across multiple timezones.\n---\nargs:\n    epoch int?  # Epoch time to convert. Defaults to current time if omitted.\n\nif not epoch:\n    epoch = now().epoch.millis\n    print(\"Epoch millis: {epoch.yellow()}\")\n\ntz_to_flag = [\n    ['Europe/London', '\ud83c\uddec\ud83c\udde7'],\n    ['America/New_York', '\ud83c\uddfa\ud83c\uddf8'],\n    ['Asia/Tokyo', '\ud83c\uddef\ud83c\uddf5'],\n    ['Australia/Melbourne', '\ud83c\udde6\ud83c\uddfa'],\n]\n</code></pre>"},{"location":"examples/epoch/#building-the-display-columns","title":"Building the display columns","text":"<p>For our table output, we need two columns: <code>Timezone</code> (for display) and <code>Time</code> (the converted times).</p> <p>First, let's create the <code>Timezone</code> column. We want it to show the flag followed by the timezone name, like \"\ud83c\uddec\ud83c\udde7 Europe/London\". We'll use <code>.map()</code> with a lambda to transform each pair:</p> <pre><code>#!/usr/bin/env rad\n---\nConvert epoch timestamps to human-readable times across multiple timezones.\n---\nargs:\n    epoch int?  # Epoch time to convert. Defaults to current time if omitted.\n\nif not epoch:\n    epoch = now().epoch.millis\n    print(\"Epoch millis: {epoch.yellow()}\")\n\ntz_to_flag = [\n    ['Europe/London', '\ud83c\uddec\ud83c\udde7'],\n    ['America/New_York', '\ud83c\uddfa\ud83c\uddf8'],\n    ['Asia/Tokyo', '\ud83c\uddef\ud83c\uddf5'],\n    ['Australia/Melbourne', '\ud83c\udde6\ud83c\uddfa'],\n]\n\nTimezone = tz_to_flag.map(fn(x) \"{x[1]} {x[0]}\")\n</code></pre> <p>Each <code>x</code> is a <code>[timezone, flag]</code> pair, so <code>x[1]</code> is the flag and <code>x[0]</code> is the timezone name. We interpolate them into a string with the flag first.</p> <p>List comprehension alternative</p> <p>You could also write this as a list comprehension, which is a bit more concise in this case: <pre><code>Timezone = [\"{x[1]} {x[0]}\" for x in tz_to_flag]\n</code></pre></p>"},{"location":"examples/epoch/#iterating-with-unpacking","title":"Iterating with unpacking","text":"<p>Now we need to build the <code>Time</code> column by converting the epoch for each timezone. When iterating over a list of lists, we can unpack each inner list directly into named variables:</p> <pre><code>#!/usr/bin/env rad\n---\nConvert epoch timestamps to human-readable times across multiple timezones.\n---\nargs:\n    epoch int?  # Epoch time to convert. Defaults to current time if omitted.\n\nif not epoch:\n    epoch = now().epoch.millis\n    print(\"Epoch millis: {epoch.yellow()}\")\n\ntz_to_flag = [\n    ['Europe/London', '\ud83c\uddec\ud83c\udde7'],\n    ['America/New_York', '\ud83c\uddfa\ud83c\uddf8'],\n    ['Asia/Tokyo', '\ud83c\uddef\ud83c\uddf5'],\n    ['Australia/Melbourne', '\ud83c\udde6\ud83c\uddfa'],\n]\n\nTimezone = tz_to_flag.map(fn(x) \"{x[1]} {x[0]}\")\n\nTime = []\nfor tz, _ in tz_to_flag:\n    time = parse_time(epoch, tz)\n    Time += [time]\n</code></pre> <p>The <code>for tz, _ in tz_to_flag:</code> line unpacks each <code>[timezone, flag]</code> pair. The first element becomes <code>tz</code>, and we use <code>_</code> for the second element to indicate we don't need the flag here - it's a convention meaning \"discard this value.\"</p> <p>This is cleaner than writing:</p> <pre><code>for pair in tz_to_flag:\n    tz = pair[0]\n    // ...\n</code></pre> <p>We're calling a <code>parse_time</code> function we haven't written yet - let's do that next.</p>"},{"location":"examples/epoch/#the-helper-function","title":"The helper function","text":"<p>We'll define a function that takes an epoch and timezone, then returns a formatted string:</p> <pre><code>#!/usr/bin/env rad\n---\nConvert epoch timestamps to human-readable times across multiple timezones.\n---\nargs:\n    epoch int?  # Epoch time to convert. Defaults to current time if omitted.\n\nif not epoch:\n    epoch = now().epoch.millis\n    print(\"Epoch millis: {epoch.yellow()}\")\n\ntz_to_flag = [\n    ['Europe/London', '\ud83c\uddec\ud83c\udde7'],\n    ['America/New_York', '\ud83c\uddfa\ud83c\uddf8'],\n    ['Asia/Tokyo', '\ud83c\uddef\ud83c\uddf5'],\n    ['Australia/Melbourne', '\ud83c\udde6\ud83c\uddfa'],\n]\n\nTimezone = tz_to_flag.map(fn(x) \"{x[1]} {x[0]}\")\n\nTime = []\nfor tz, _ in tz_to_flag:\n    time = parse_time(epoch, tz)\n    Time += [time]\n\n// display block will go here\n\nfn parse_time(epoch: int, tz: str) -&gt; str:\n    time = parse_epoch(epoch, tz=tz)\n    return \"{time.date} {time.time}\"\n</code></pre> <p>The <code>parse_epoch()</code> function converts an epoch timestamp to a time map, accepting a <code>tz</code> parameter for the timezone. We then format the <code>.date</code> and <code>.time</code> fields into a string.</p> <p>Note the type annotations <code>epoch: int, tz: str</code> and <code>-&gt; str</code> - these are optional but help document what the function expects and returns.</p>"},{"location":"examples/epoch/#the-display-block","title":"The display block","text":"<p>Finally, we use a <code>display</code> block to render our two columns as a formatted table:</p> <pre><code>#!/usr/bin/env rad\n---\nConvert epoch timestamps to human-readable times across multiple timezones.\n---\nargs:\n    epoch int?  # Epoch time to convert. Defaults to current time if omitted.\n\nif not epoch:\n    epoch = now().epoch.millis\n    print(\"Epoch millis: {epoch.yellow()}\")\n\ntz_to_flag = [\n    ['Europe/London', '\ud83c\uddec\ud83c\udde7'],\n    ['America/New_York', '\ud83c\uddfa\ud83c\uddf8'],\n    ['Asia/Tokyo', '\ud83c\uddef\ud83c\uddf5'],\n    ['Australia/Melbourne', '\ud83c\udde6\ud83c\uddfa'],\n]\n\nTimezone = tz_to_flag.map(fn(x) \"{x[1]} {x[0]}\")\n\nTime = []\nfor tz, _ in tz_to_flag:\n    time = parse_time(epoch, tz)\n    Time += [time]\n\ndisplay:\n    fields Timezone, Time\n\nfn parse_time(epoch: int, tz: str) -&gt; str:\n    time = parse_epoch(epoch, tz=tz)\n    return \"{time.date} {time.time}\"\n</code></pre> <p>The <code>display</code> block takes our pre-populated lists and renders them as aligned columns. The variable names (<code>Timezone</code>, <code>Time</code>) become the column headers.</p>"},{"location":"examples/epoch/#try-it-out","title":"Try it out","text":"<pre><code>&gt; epoch 1700000000000\nTimezone                Time\n\ud83c\uddec\ud83c\udde7 Europe/London         2023-11-14 22:13:20\n\ud83c\uddfa\ud83c\uddf8 America/New_York      2023-11-14 17:13:20\n\ud83c\uddef\ud83c\uddf5 Asia/Tokyo            2023-11-15 07:13:20\n\ud83c\udde6\ud83c\uddfa Australia/Melbourne   2023-11-15 09:13:20\n</code></pre> <p>Or without an argument, to see the current time:</p> <pre><code>&gt; epoch\nEpoch millis: 1769378597483\nTimezone                Time\n\ud83c\uddec\ud83c\udde7 Europe/London         2026-01-25 22:03:17\n\ud83c\uddfa\ud83c\uddf8 America/New_York      2026-01-25 17:03:17\n\ud83c\uddef\ud83c\uddf5 Asia/Tokyo            2026-01-26 07:03:17\n\ud83c\udde6\ud83c\uddfa Australia/Melbourne   2026-01-26 09:03:17\n</code></pre>"},{"location":"examples/epoch/#concepts-demonstrated","title":"Concepts demonstrated","text":"Concept Where Optional arguments <code>epoch int?</code> Null checking <code>if not epoch:</code> Built-in <code>now()</code> <code>now().epoch.millis</code> List of lists <code>tz_to_flag</code> <code>.map()</code> with lambdas <code>tz_to_flag.map(fn(x) ...)</code> Loop unpacking <code>for tz, _ in tz_to_flag:</code> Functions with types <code>fn parse_time(epoch: int, tz: str) -&gt; str:</code> <code>parse_epoch()</code> Time conversion <code>display</code> blocks Tabular output"},{"location":"examples/hm/","title":"hm","text":""},{"location":"examples/hm/#preview","title":"Preview","text":"<pre><code>#!/usr/bin/env rad\n---\nA personal cheatsheet manager.\nStore and retrieve help snippets for commands you forget.\n@stash_id = J8xKmN3pQrT\n---\n\ncommand show:\n    ---\n    Show the help entry for a topic.\n    ---\n    topic str  # The topic to look up.\n    calls do_show\n\ncommand edit:\n    ---\n    Edit or create a help entry for a topic.\n    ---\n    topic str  # The topic to edit.\n    calls do_edit\n\ncommand list:\n    ---\n    List all stored topics.\n    ---\n    calls do_list\n\nstate = load_state()\ndefer save_state(state)\n\nfn do_show():\n    file_path = get_stash_path(\"files/entries/{topic}.txt\")\n    if not file_path.get_path().exists:\n        print(\"No entry for '{topic}'. Use 'hm edit {topic}' to create one.\")\n    else:\n        print(file_path.read_file().content)\n\nfn do_edit():\n    editor = state.load(\"editor\", fn() input(\"Editor? &gt; \", default=\"vim\"))\n    result = load_stash_file(\"entries/{topic}.txt\", \"\")\n    $`{editor} {result.full_path}`\n    print(\"Entry for '{topic}' saved.\")\n\nfn do_list():\n    entries_dir = get_stash_path(\"files/entries\")\n    if not entries_dir.get_path().exists:\n        print(\"No entries yet. Use 'hm edit &lt;topic&gt;' to create one.\")\n        exit()\n    files = entries_dir.find_paths(depth=1, relative=\"absolute\")\n    if files.len() == 0:\n        print(\"No entries yet. Use 'hm edit &lt;topic&gt;' to create one.\")\n        exit()\n    for file in files:\n        name = file.get_path().base_name.replace(\".txt\", \"\")\n        print(name)\n</code></pre> <pre><code>&gt; hm -h\nA personal cheatsheet manager.\nStore and retrieve help snippets for commands you forget.\n\nUsage:\n  hm [command] [OPTIONS]\n\nCommands:\n  edit   Edit or create a help entry for a topic.\n  list   List all stored topics.\n  show   Show the help entry for a topic.\n</code></pre> <pre><code>&gt; hm edit tar\nEditor? &gt; vim\n# Opens vim with empty file, user writes their notes, saves and exits\nEntry for 'tar' saved.\n\n&gt; hm show tar\ntar - extract and create archives\n\nExtract:    tar -xvf archive.tar.gz\nCreate:     tar -cvzf archive.tar.gz files/\nList:       tar -tvf archive.tar.gz\n\n&gt; hm edit rsync\n# No prompt this time - editor preference was saved!\nEntry for 'rsync' saved.\n\n&gt; hm list\ntar\nrsync\n</code></pre>"},{"location":"examples/hm/#tutorial-building-hm","title":"Tutorial: Building <code>hm</code>","text":""},{"location":"examples/hm/#motivation","title":"Motivation","text":"<p>Some commands have notoriously hard-to-remember syntax - <code>tar</code>, <code>find</code>, <code>rsync</code>. You look them up, use them once, and forget again. Tools like <code>tldr</code> help, but sometimes you want your own notes - the specific incantations that work for your use cases.</p> <p>Let's build <code>hm</code> - a personal cheatsheet manager that stores your notes in a stash, so they persist between sessions.</p>"},{"location":"examples/hm/#writing-the-script","title":"Writing the script","text":"<p>Let's start with a new script:</p> <pre><code>rad new hm -s\n</code></pre> <p>First, we'll add a description and set up a stash ID. The stash ID is what tells Rad where to store our persistent data. You can generate one with <code>rad gen-id</code>:</p> <pre><code>#!/usr/bin/env rad\n---\nA personal cheatsheet manager.\nStore and retrieve help snippets for commands you forget.\n@stash_id = J8xKmN3pQrT\n---\n</code></pre> <p>The <code>@stash_id</code> macro in the file header creates a dedicated storage area at <code>~/.rad/stashes/J8xKmN3pQrT/</code> for this script.</p>"},{"location":"examples/hm/#defining-commands","title":"Defining commands","text":"<p>We'll use script commands to organize our CLI into commands. Each command gets its own description and arguments:</p> <pre><code>#!/usr/bin/env rad\n---\nA personal cheatsheet manager.\nStore and retrieve help snippets for commands you forget.\n@stash_id = J8xKmN3pQrT\n---\n\ncommand show:\n    ---\n    Show the help entry for a topic.\n    ---\n    topic str  # The topic to look up.\n    calls do_show\n\ncommand edit:\n    ---\n    Edit or create a help entry for a topic.\n    ---\n    topic str  # The topic to edit.\n    calls do_edit\n\ncommand list:\n    ---\n    List all stored topics.\n    ---\n    calls do_list\n</code></pre> <p>Each command block declares its own arguments (like <code>topic str</code>) and uses <code>calls</code> to specify which function handles it. The <code>---</code> sections become the command descriptions shown in <code>--help</code>.</p>"},{"location":"examples/hm/#setting-up-state","title":"Setting up state","text":"<p>Before implementing our commands, we need to set up state management. We'll use state to remember user preferences (like their preferred editor):</p> <pre><code>#!/usr/bin/env rad\n---\nA personal cheatsheet manager.\nStore and retrieve help snippets for commands you forget.\n@stash_id = J8xKmN3pQrT\n---\n\ncommand show:\n    ---\n    Show the help entry for a topic.\n    ---\n    topic str  # The topic to look up.\n    calls do_show\n\ncommand edit:\n    ---\n    Edit or create a help entry for a topic.\n    ---\n    topic str  # The topic to edit.\n    calls do_edit\n\ncommand list:\n    ---\n    List all stored topics.\n    ---\n    calls do_list\n\nstate = load_state()\ndefer save_state(state)\n</code></pre> <p>The <code>defer save_state(state)</code> ensures our state is saved when the script exits, even if something goes wrong later.</p>"},{"location":"examples/hm/#the-show-command","title":"The show command","text":"<p>Now let's implement <code>do_show()</code>. We check if the entry exists and display it:</p> <pre><code>#!/usr/bin/env rad\n---\nA personal cheatsheet manager.\nStore and retrieve help snippets for commands you forget.\n@stash_id = J8xKmN3pQrT\n---\n\ncommand show:\n    ---\n    Show the help entry for a topic.\n    ---\n    topic str  # The topic to look up.\n    calls do_show\n\ncommand edit:\n    ---\n    Edit or create a help entry for a topic.\n    ---\n    topic str  # The topic to edit.\n    calls do_edit\n\ncommand list:\n    ---\n    List all stored topics.\n    ---\n    calls do_list\n\nstate = load_state()\ndefer save_state(state)\n\nfn do_show():\n    file_path = get_stash_path(\"files/entries/{topic}.txt\")\n    if not file_path.get_path().exists:\n        print(\"No entry for '{topic}'. Use 'hm edit {topic}' to create one.\")\n    else:\n        print(file_path.read_file().content)\n</code></pre> <p>We use <code>get_stash_path()</code> to build the path to where the entry file would live. The <code>\"files/\"</code> prefix is needed because stash files are stored in a <code>files/</code> subdirectory. Then we chain <code>.get_path().exists</code> to check if it exists - if not, we tell the user how to create it. If it does exist, we read and print it with <code>.read_file().content</code>.</p>"},{"location":"examples/hm/#the-edit-command","title":"The edit command","text":"<p>The edit command opens the entry in the user's editor. Here's where it gets interesting - we use  <code>load()</code> to handle first-run configuration:</p> <pre><code>#!/usr/bin/env rad\n---\nA personal cheatsheet manager.\nStore and retrieve help snippets for commands you forget.\n@stash_id = J8xKmN3pQrT\n---\n\ncommand show:\n    ---\n    Show the help entry for a topic.\n    ---\n    topic str  # The topic to look up.\n    calls do_show\n\ncommand edit:\n    ---\n    Edit or create a help entry for a topic.\n    ---\n    topic str  # The topic to edit.\n    calls do_edit\n\ncommand list:\n    ---\n    List all stored topics.\n    ---\n    calls do_list\n\nstate = load_state()\ndefer save_state(state)\n\nfn do_show():\n    file_path = get_stash_path(\"files/entries/{topic}.txt\")\n    if not file_path.get_path().exists:\n        print(\"No entry for '{topic}'. Use 'hm edit {topic}' to create one.\")\n    else:\n        print(file_path.read_file().content)\n\nfn do_edit():\n    editor = state.load(\"editor\", fn() input(\"Editor? &gt; \", default=\"vim\"))\n    result = load_stash_file(\"entries/{topic}.txt\", \"\")\n    $`{editor} {result.full_path}`\n    print(\"Entry for '{topic}' saved.\")\n</code></pre> <p>The <code>load()</code> function is the star here. It checks if <code>\"editor\"</code> exists in <code>state</code>:</p> <ul> <li>First run: Key doesn't exist, so it calls the loader function - which prompts the user with <code>input()</code>. The result   gets stored in <code>state[\"editor\"]</code>.</li> <li>Subsequent runs: Key exists, so it returns the cached value immediately - no prompt.</li> </ul> <p>Since we have <code>defer save_state(state)</code>, the editor preference persists between sessions.</p>"},{"location":"examples/hm/#the-list-command","title":"The list command","text":"<p>Finally, we list all stored entries by finding files in the entries directory:</p> <pre><code>#!/usr/bin/env rad\n---\nA personal cheatsheet manager.\nStore and retrieve help snippets for commands you forget.\n@stash_id = J8xKmN3pQrT\n---\n\ncommand show:\n    ---\n    Show the help entry for a topic.\n    ---\n    topic str  # The topic to look up.\n    calls do_show\n\ncommand edit:\n    ---\n    Edit or create a help entry for a topic.\n    ---\n    topic str  # The topic to edit.\n    calls do_edit\n\ncommand list:\n    ---\n    List all stored topics.\n    ---\n    calls do_list\n\nstate = load_state()\ndefer save_state(state)\n\nfn do_show():\n    file_path = get_stash_path(\"files/entries/{topic}.txt\")\n    if not file_path.get_path().exists:\n        print(\"No entry for '{topic}'. Use 'hm edit {topic}' to create one.\")\n    else:\n        print(file_path.read_file().content)\n\nfn do_edit():\n    editor = state.load(\"editor\", fn() input(\"Editor? &gt; \", default=\"vim\"))\n    result = load_stash_file(\"entries/{topic}.txt\", \"\")\n    $`{editor} {result.full_path}`\n    print(\"Entry for '{topic}' saved.\")\n\nfn do_list():\n    entries_dir = get_stash_path(\"files/entries\")\n    if not entries_dir.get_path().exists:\n        print(\"No entries yet. Use 'hm edit &lt;topic&gt;' to create one.\")\n        exit()\n    files = entries_dir.find_paths(depth=1, relative=\"absolute\")\n    if files.len() == 0:\n        print(\"No entries yet. Use 'hm edit &lt;topic&gt;' to create one.\")\n        exit()\n    for file in files:\n        name = file.get_path().base_name.replace(\".txt\", \"\")\n        print(name)\n</code></pre> <p>We use <code>get_stash_path()</code> to get the path to our entries folder - note the <code>\"files/\"</code> prefix since stash files live in a <code>files/</code> subdirectory. We chain  <code>.get_path()</code> to check if it exists, and  <code>.find_paths()</code> to list all files. The <code>depth=1</code> parameter limits the search to direct children only, and <code>relative=\"absolute\"</code> gives us full paths so that subsequent <code>get_path()</code> calls resolve correctly. For each file, we extract the topic name with <code>.get_path().base_name</code> and strip the <code>.txt</code> extension.</p>"},{"location":"examples/hm/#try-it-out","title":"Try it out","text":"<p>Create your first entry:</p> <pre><code>&gt; hm edit tar\nEditor? &gt; vim\n# Editor opens, you write your notes, save and exit\nEntry for 'tar' saved.\n</code></pre> <p>View it later:</p> <pre><code>&gt; hm show tar\ntar - extract and create archives\n\nExtract:    tar -xvf archive.tar.gz\nCreate:     tar -cvzf archive.tar.gz files/\nList:       tar -tvf archive.tar.gz\n</code></pre> <p>Add another entry - notice no editor prompt this time:</p> <pre><code>&gt; hm edit rsync\n# Opens vim immediately - preference was remembered!\nEntry for 'rsync' saved.\n</code></pre> <p>List all your entries:</p> <pre><code>&gt; hm list\ntar\nrsync\n</code></pre> <p>Your notes live at <code>~/.rad/stashes/J8xKmN3pQrT/files/entries/</code> and your preferences are stored in <code>~/.rad/stashes/J8xKmN3pQrT/state.json</code>.</p>"},{"location":"examples/hm/#concepts-demonstrated","title":"Concepts demonstrated","text":"Concept Where Stash ID <code>@stash_id = J8xKmN3pQrT</code> State persistence <code>load_state()</code> / <code>save_state()</code> Defer pattern <code>defer save_state(state)</code> <code>load()</code> First-run config with <code>state.load(\"editor\", ...)</code> <code>input()</code> Prompting for editor preference <code>load_stash_file()</code> Creating entry files in <code>do_edit()</code> <code>read_file()</code> Reading entry content in <code>do_show()</code> <code>get_stash_path()</code> Getting entries paths Script commands <code>command show:</code>, <code>command edit:</code>, <code>command list:</code> Shell commands <code>$\\</code>``} {result.full_path <code>find_paths()</code> Listing files in the entries directory <code>get_path()</code> Checking if directory exists, extracting base name Custom functions <code>fn do_show():</code>, etc."},{"location":"guide/args/","title":"Args","text":"<p>This section covers syntax for declaring arguments that your script can accept.</p>"},{"location":"guide/args/#arg-declarations","title":"Arg Declarations","text":"<p>Rad takes a declarative approach to arguments. You simply declare what arguments your script accepts, you can define some constraints you want for them, and let Rad take care of the rest, including parsing user input and validation.</p> <p>Arguments are declared as part of an args block.</p> <p>Here's an example script we'll call <code>printwords</code> that prints an input word some number of times:</p> <pre><code>#!/usr/bin/env rad\nargs:\n    word str\n    repeats int\n\nfor _ in range(repeats):\n    print(word)\n</code></pre> <p>We can print its usage string using the <code>-h</code> flag:</p> <pre><code>./printwords -h\n</code></pre> <pre><code>Usage:\n  printwords &lt;word&gt; &lt;repeats&gt;\n\nScript args:\n      --word str\n      --repeats int\n</code></pre> <p>This script defines two mandatory arguments: <code>word</code> that is expected to be a string, and <code>repeats</code> which is expected to be an integer.</p> <p>Some important things to note:</p> <ul> <li>All arguments can be defined positionally or via a flag.</li> <li>The positional ordering of args follows the order of declaration in the block.</li> <li>Flags are automatically generated and can be used by users to pass values for that argument, instead of doing it positionally.</li> </ul> <p>Let's look at a more complex example to demonstrate some more features. Let's call it <code>wordjoin</code>.</p> <pre><code>#!/usr/bin/env rad\n---\nGiven some words, joins them together, and optionally capitalizes them.\n---\nargs:\n    words str[]                            # Words to join together.\n    joiner j str = \"-\"                     # Joiner for the words.\n    should_capitalize \"capitalize\" c bool  # If true, capitalize the words.\n\nif should_capitalize:\n    words = [upper(w) for w in words]\n\nprint(join(words, joiner))\n</code></pre> <p>If we run <code>-h</code> on this one:</p> <pre><code>./wordjoin -h\n</code></pre> <pre><code>Given some words, joins them together, and optionally capitalizes them.\n\nUsage:\n  wordjoin &lt;words&gt; [joiner] [OPTIONS]\n\nScript args:\n      --words strs   Words to join together.\n  -j, --joiner str   Joiner for the words. (default -)\n  -c, --capitalize   If true, capitalize the words.\n</code></pre> <p>Let's break down each declaration to see what's going on here.</p> <ol> <li> <p><code>words str[]  # Words to join together.</code></p> <ul> <li>We declare an arg <code>words</code> which is a list of strings. Note that <code>int[]</code>, <code>float[]</code> and <code>bool[]</code> can be used for int, float, and bool lists respectively.</li> <li>We also define an arg comment to make the usage string include a description of what the argument is.</li> </ul> </li> <li> <p><code>joiner j str = \"-\"  # Joiner for the words.</code></p> <ul> <li>We declare a second argument, this one a string called <code>joiner</code>. We also define a shorthand flag <code>j</code>, allowing users to specify the arg with a simple <code>-j</code> flag.</li> <li>After that, we define a default value <code>-</code> for this parameter that will be used if the user doesn't provide one. We finish with another arg comment.</li> </ul> </li> <li> <p><code>should_capitalize \"capitalize\" c bool  # If true, capitalize the words.</code></p> <ul> <li>We declare our final argument <code>should_capitalize</code>. We rename it with <code>\"capitalize\"</code>, which will be what users see exposed to them, instead of the initial variable name. <code>should_capitalize</code> will remain the name of the variable to be referenced throughout the script. We define a shorthand <code>c</code>, and specify the parameter is a <code>bool</code> before finally giving it an arg comment.</li> </ul> </li> </ol> <p>Bool args are always false by default.</p> <p>To bring it all together, this is the anatomy of an arg declaration (<code>&lt;angle brackets&gt;</code> mean it's required, <code>[square brackets]</code> indicate it's optional):</p> <p><code>&lt;name&gt; [rename] [shorthand flag] &lt;type&gt; [= default] [# arg comment]</code></p> <p>Feel free to go back up and check this against the example scripts we wrote, you'll see how each one fits this mold.</p>"},{"location":"guide/args/#argument-types-and-user-input","title":"Argument Types and User Input","text":"<p>This section explains the different argument types you can declare and how users pass values for each type.</p>"},{"location":"guide/args/#basic-types","title":"Basic Types","text":"<p>For basic types (<code>int</code>, <code>float</code>, <code>str</code>), users can pass values either positionally or via flags:</p> <pre><code>#!/usr/bin/env rad\nargs:\n    name str\n    age int\n    height float\n\nprint(\"{name} is {age} years old and {height}m tall\")\n</code></pre> <p>Both invocations work identically:</p> <pre><code>./script Alice 25 1.65\n./script --name Alice --age 25 --height 1.65\n./script Alice 25 --height 1.65\n</code></pre> <p>Type validation happens automatically. If a user provides <code>--age abc</code> when age is an <code>int</code>, Rad will show an error.</p>"},{"location":"guide/args/#bool-flags","title":"Bool Flags","text":"<p>Bool arguments are never positional - they must be passed via flags. You can set them either by presence or with an explicit value:</p> <pre><code>args:\n    verbose v bool\n    debug d bool\n\nprint(\"verbose: {verbose}, debug: {debug}\")\n</code></pre> <pre><code>./script --verbose           # verbose=true, debug=false\n./script -v                  # Same as above (short flag)\n./script -v -d               # Both true\n./script --verbose=true      # Explicit value\n./script --verbose=false     # Explicitly set to false\n</code></pre> <p>Bool args always default to <code>false</code> unless you give them a different default:</p> <pre><code>args:\n    verbose bool = true  # Defaults to true\n</code></pre>"},{"location":"guide/args/#list-types","title":"List Types","text":"<p>For list arguments (<code>str[]</code>, <code>int[]</code>, <code>float[]</code>, <code>bool[]</code>), users pass values by repeating the flag:</p> <pre><code>args:\n    files f str[]\n    counts int[]\n\nprint(\"files: {files}\")\nprint(\"counts: {counts}\")\n</code></pre> <pre><code>./script -f hello.txt -f world.txt --counts 1 --counts 2 --counts 3\n</code></pre> <pre><code>files: [ \"hello.txt\", \"world.txt\" ]\ncounts: [ 1, 2, 3 ]\n</code></pre> <p>Both long and short flags can be used interchangeably and repeated as needed.</p>"},{"location":"guide/args/#variadic-arguments","title":"Variadic Arguments","text":"<p>Variadic arguments use a <code>*</code> prefix and collect any number of positional values into a list:</p> <pre><code>args:\n    command str\n    *files str\n    verbose v bool\n\nprint(\"command: {command}\")\nprint(\"files: {files}\")\n</code></pre> <pre><code>./script build file1.txt file2.txt file3.txt --verbose\n</code></pre> <pre><code>command: build\nfiles: [ \"file1.txt\", \"file2.txt\", \"file3.txt\" ]\n</code></pre> <p>Variadic args can have defaults and work with any type (<code>*numbers int</code>, <code>*values float</code>, etc.):</p> <pre><code>args:\n    *items str = [\"default.txt\"]\n</code></pre> <p>You can have multiple variadic sections separated by flags - the flags act as delimiters:</p> <pre><code>args:\n    *section1 str\n    *section2 int\n    flag f bool\n\nprint(\"section1: {section1}\")\nprint(\"section2: {section2}\")\n</code></pre> <pre><code>./script a b c --flag 1 2 3\n</code></pre> <pre><code>section1: [ \"a\", \"b\", \"c\" ]\nsection2: [ 1, 2, 3 ]\n</code></pre>"},{"location":"guide/args/#optional-arguments","title":"Optional Arguments","text":"<p>Mark arguments as optional with <code>?</code> suffix. When not provided, their value is <code>null</code>:</p> <pre><code>args:\n    name str\n    role str?\n    year int?\n\nif role == null:\n    print(\"{name} has no role assigned\")\nelse:\n    print(\"{name} is a {role}\")\n</code></pre> <pre><code>./script Alice\n</code></pre> <pre><code>Alice has no role assigned\n</code></pre> <p>You can check for null values with <code>== null</code> or use truthy/falsy logic: <code>if role:</code> will be false when role is null.</p>"},{"location":"guide/args/#short-flag-clustering","title":"Short Flag Clustering","text":"<p>When you define short flags (single letters), users can cluster multiple bool flags together:</p> <pre><code>args:\n    verbose v bool\n    debug d bool\n    quiet q bool\n</code></pre> <pre><code>./script -vdq    # Same as: -v -d -q\n</code></pre> <p>All three flags are set to true with this single clustered argument.</p>"},{"location":"guide/args/#int-flag-counting","title":"Int Flag Counting","text":"<p>For <code>int</code> arguments with short flags, repeating the flag increments the count:</p> <pre><code>args:\n    verbosity v int\n</code></pre> <pre><code>./script -vvv           # verbosity = 3\n./script -vvvvv         # verbosity = 5\n</code></pre> <p>This is useful for verbosity levels. If an explicit value is provided, it overrides the counting:</p> <pre><code>./script -vvv=10        # verbosity = 10 (not 3)\n</code></pre>"},{"location":"guide/args/#constraints","title":"Constraints","text":"<p>In addition to declaring the arguments themselves, Rad also allows you to declare constraints on those arguments, such as what kinds of values are valid.</p> <p>By doing this in the args block, Rad can use this information to validate input for you, and automatically include the information in your script's usage string.</p> <p>If a user gives an input which doesn't meet one of the listed constraints, Rad will print:</p> <ol> <li> <p>The specific error and constraint that was violated.</p> </li> <li> <p>The usage string.</p> </li> </ol>"},{"location":"guide/args/#enums","title":"Enums","text":"<p>If you have a string argument where you really only want to accept some limited number of known values, you can use an enum constraint.</p> <p>Let's use a simple example, we'll call the script <code>colors</code>:</p> <pre><code>#!/usr/bin/env rad\nargs:\n    color str\n    color enum [\"red\", \"green\", \"blue\"]\nprint(\"You like {color}!\")\n</code></pre> <p>If we print the usage string, you can see it tells users what values are valid:</p> <pre><code>./colors -h\n</code></pre> <pre><code>Usage:\n  colors &lt;color&gt;\n\nScript args:\n      --color str    Valid values: [red, green, blue].\n</code></pre> <p>If we invoke this script with a value outside the listed valid values:</p> <pre><code>./colors yellow\n</code></pre> <pre><code>Invalid 'color' value: yellow (valid values: red, green, blue)\nUsage:\n  colors &lt;color&gt;\n\nScript args:\n      --color str    Valid values: [red, green, blue].\n</code></pre> <p>Whereas using a valid value will run the script as intended:</p> <pre><code>./colors green\n</code></pre> <pre><code>You like green!\n</code></pre>"},{"location":"guide/args/#range","title":"Range","text":"<p>For numeric arguments (<code>int</code> or <code>float</code>), you can enforce minimum and maximum values using a range constraint.</p> <p>Range constraints use <code>[</code> for inclusive bounds and <code>(</code> for exclusive bounds:</p> <pre><code>#!/usr/bin/env rad\nargs:\n    age int\n    temperature float\n\n    age range [0, 120]              // 0 to 120, both inclusive\n    temperature range (-50.0, 50.0) // Between -50 and 50, both exclusive\n</code></pre> <p>You can also specify only a floor or only a ceiling:</p> <pre><code>args:\n    count int\n    score float\n\n    count range [1,]      // Minimum of 1, no maximum\n    score range (,100.0]  // No minimum, maximum of 100 (inclusive)\n</code></pre> <p>Floor/Ceiling Syntax</p> <p>When specifying only a floor or ceiling, both <code>[0,]</code> and <code>[0,)</code> are equivalent (both mean \"minimum of 0, no maximum\"). The closing delimiter doesn't affect the meaning when the value is omitted.</p> <p>Let's look at a complete example with various range types:</p> File: validator<pre><code>#!/usr/bin/env rad\nargs:\n    age int              # Person's age\n    score float          # Test score\n    count int            # Item count\n\n    age range [0, 120]\n    score range (0, 100]\n    count range [1,]\n</code></pre> <p>The help text automatically shows the constraints:</p> <pre><code>./validator -h\n</code></pre> <pre><code>Usage:\n  validator &lt;age&gt; &lt;score&gt; &lt;count&gt; [OPTIONS]\n\nScript args:\n      --age int      Person's age. Range: [0, 120]\n      --score float  Test score. Range: (0, 100]\n      --count int    Item count. Range: [1, )\n</code></pre> <p>If a user provides an invalid value, they get a clear error:</p> <pre><code>./validator 150 50.0 5\n</code></pre> <pre><code>'age' value 150 is &gt; maximum 120\n\nUsage:\n  validator &lt;age&gt; &lt;score&gt; &lt;count&gt; [OPTIONS]\n\nScript args:\n      --age int      Person's age. Range: [0, 120]\n      --score float  Test score. Range: (0, 100]\n      --count int    Item count. Range: [1, )\n</code></pre> <p>When using exclusive bounds, values exactly at the boundary are rejected:</p> <pre><code>./validator 25 0 5   # score of 0 is invalid (exclusive minimum)\n</code></pre> <pre><code>'score' value 0 is &lt;= minimum (exclusive) 0\n</code></pre>"},{"location":"guide/args/#regex","title":"Regex","text":"<p>If you'd like input strings to match a certain pattern, you can do that via a regex constraint.</p> <pre><code>args:\n    name str\n    name regex \"[A-Z][a-z]*\"\nprint(\"Hi, {name}\")\n</code></pre> <p>In this example, a valid <code>name</code> value must start with a capital letter, and can then be followed by any number of lowercase letters. No other characters will be accepted, so <code>Alice</code> will be a valid value, but <code>bob</code> or <code>John123</code> are not.</p> <p>As with other constraints, Rad will validate input against this regex, and if it doesn't match, it will print an error. The constraint is also printed in the script's usage string.</p>"},{"location":"guide/args/#relational","title":"Relational","text":"<p>Relational constraints let you express logical relationships between your script's arguments. There are two types of constraints you can define:</p> <ul> <li><code>excludes</code> (arguments can't appear together)</li> <li><code>requires</code> (an argument depends on another argument also being provided)</li> </ul> <p>You can optionally precede these with the <code>mutually</code> keyword to indicate that the constraint applies in both directions.</p>"},{"location":"guide/args/#exclusion","title":"Exclusion","text":"<p>Use <code>excludes</code> to prevent arguments from being specified together. For example, consider a script that accepts either a file (<code>--file</code>) or a URL (<code>--url</code>), but not both:</p> File: fetcher<pre><code>#!/usr/bin/env rad\nargs:\n  file str\n  url str\n\n  file mutually excludes url\n\nif file:\n    print(\"Reading from file:\", file)\nelse:\n    print(\"Fetching from URL:\", url)\n</code></pre> <p>You can then provide either argument:</p> <pre><code>&gt; ./fetcher --file data.json\nReading from file: data.json\n\n&gt; ./fetcher --url https://example.com/data.json\nFetching from URL: https://example.com/data.json\n</code></pre> <p>If both are provided, Rad gives a clear error:</p> <pre><code>&gt; ./fetcher --file data.json --url https://example.com/data.json\nInvalid arguments: 'file' excludes 'url', but 'url' was given\n</code></pre> <p>Note in this example, that if e.g. <code>file</code> is provided, then <code>url</code> will be <code>null</code> (and vice versa).</p>"},{"location":"guide/args/#requirement","title":"Requirement","text":"<p>Use the <code>requires</code> keyword to indicate that, when one argument is defined, so must another argument.</p> <p>Consider a script that can authenticate either by using a token or by providing a username/password pair. </p> <p>If the user provides a username, the password is also required.</p> File: auth<pre><code>args:\n  token str\n  username str\n  password str\n\n  username mutually requires password\n  token mutually excludes username, password\n\nif token:\n    print(\"Authenticating with token {token}\")\nelse:\n    print(\"Authenticating user {username} with password length {len(password)}\")\n</code></pre> <p>Valid usage examples:</p> <pre><code>&gt; ./auth --token abc123\nAuthenticating with token abc123\n\n&gt; ./auth --username alice --password secret\nAuthenticating user alice with password length 6\n</code></pre> <p>Invalid usage examples:</p> <pre><code>&gt; ./auth --username alice\nInvalid arguments: 'username' requires 'password', but 'password' was not provided\n\n&gt; ./auth --token abc123 --password secret\nInvalid arguments: 'token' excludes 'password', but 'password' was given\n</code></pre>"},{"location":"guide/args/#summary","title":"Summary","text":"<ul> <li>Rad takes a declarative approach to args, and handles parsing user input.</li> <li>All args can be specified positionally or via a flag from the user.</li> <li> <p>Anatomy of an arg declaration:</p> <p><code>&lt;name&gt; [rename] [shorthand flag] &lt;type&gt; [= default] [# arg comment]</code></p> </li> <li> <p>Rad supports various argument types:</p> <ul> <li>Basic types: <code>int</code>, <code>float</code>, <code>str</code>, <code>bool</code></li> <li>List types: <code>str[]</code>, <code>int[]</code>, <code>float[]</code>, <code>bool[]</code> (passed via repeated flags)</li> <li>Variadic: <code>*args &lt;type&gt;</code> (collects remaining positional arguments)</li> <li>Optional: <code>&lt;type&gt;?</code> (value is <code>null</code> when not provided)</li> </ul> </li> <li>Short flags support clustering (<code>-vdq</code>) and counting for ints (<code>-vvv</code> = 3)</li> <li>You can apply constraints to arguments inside the arg block:<ul> <li><code>enum</code> for discrete values</li> <li><code>range</code> for numeric bounds (using <code>[</code> for inclusive, <code>(</code> for exclusive)</li> <li><code>regex</code> for pattern matching</li> <li>Relational constraints (<code>requires</code>, <code>excludes</code>)</li> </ul> </li> <li>Details in the arg block are used by Rad to provide a better usage/help string.</li> </ul>"},{"location":"guide/args/#next","title":"Next","text":"<p>Next, we'll look at another important concept in Rad: Functions.</p>"},{"location":"guide/basics/","title":"Basics","text":"<p>This section of the guide will rapidly cover the basics of Rad. Rad shares a lot of conventions and syntax with popular languages like Python, so if you're familiar with programming, this will be a breeze.</p>"},{"location":"guide/basics/#variables-assignment","title":"Variables &amp; Assignment","text":"<p>To create a variable, you can do it through assignment. Let's use a string example:</p> <pre><code>name = \"Alice\"\n</code></pre> <p>You can re-assign variables. Types don't need to stay the same:</p> <pre><code>name = \"Alice\"\nname = 2\n</code></pre>"},{"location":"guide/basics/#data-types","title":"Data Types","text":"<p>Rad has 6 basic types: strings, ints, floats, bools, lists, and maps.</p>"},{"location":"guide/basics/#str","title":"str","text":"<p>Strings can be delimited in three ways:</p> <ol> <li>Double quotes: <code>\"text\"</code></li> <li>Single quotes: <code>'text'</code></li> <li>Backticks: <code>`text`</code></li> </ol> <p>All three behave the same way. To demonstrate:</p> <pre><code>print(\"Hello!\")\nprint('Hello!')\nprint(`Hello!`)\n</code></pre> <pre><code>Hello!\nHello!\nHello!\n</code></pre> <p>Why 3 different delimiters?</p> <p>Having 3 different delimiters is particularly useful when you want your string to contain one (or more) of those delimiter characters.</p> <p>For example, if you want a double quote in your string, you can use double quote delimiters and escape them:</p> <pre><code>\"She said \\\"Goodbye\\\"\"\n</code></pre> <p>However, this can be finicky and hard to read. Instead, you can pick one of the other two delimiters, for example:</p> <pre><code>'She said \"Goodbye\"'\n`She said \"Goodbye\"`\n</code></pre> <p>We'll cover this again later, but as a note, backticks can be particularly useful in shell commands, as shell/bash commands may include single or double quotes, and backticks save us from having to escape them.</p> <p>Strings can include special characters such as <code>\\n</code> for new lines and <code>\\t</code> for tabs.</p> <pre><code>print(\"Hello\\tdear\\nreader!\")\n</code></pre> <pre><code>Hello   dear\nreader!\n</code></pre> <p>Strings also support interpolation. String interpolation allows you to write expressions inside your string that will be evaluated and replaced for the final string. We'll cover this in more depth in a future section, but to give a very simple example:</p> <pre><code>name = \"Alice\"\nprint(\"Hi, {name}!\")\n</code></pre> <pre><code>Hi, Alice!\n</code></pre> <p>Anything encapsulated in a <code>{}</code> gets treated as an expression. Here, the expression is just the identifier <code>name</code>, which gets evaluated and substituted, giving us the final <code>Hi, Alice!</code> string.</p> <p>Those are the basics for strings - we'll cover additional string concepts in a future section, Strings (Advanced).</p>"},{"location":"guide/basics/#int","title":"int","text":"<p>Rad has ints. There's nothing unusual about them. Example:</p> <pre><code>team_size = 20\ncelsius = -5\n</code></pre> <p>For large numbers, you can use underscores to improve readability:</p> <pre><code>population = 1_234_567\ndistance = 93_000_000\n</code></pre> <p>Note that if you divide two ints, you will get back a float.</p> <pre><code>liters = 10\npeople = 4\nprint(\"This is a float:\", liters / people)\n</code></pre> <pre><code>This is a float: 2.5\n</code></pre>"},{"location":"guide/basics/#float","title":"float","text":"<p>The other number type is float:</p> <pre><code>length_meters = 2.68\n</code></pre> <p>If you want to define a whole number as a float, simply include a decimal place:</p> <pre><code>years = 20.0\n</code></pre> <p>Like ints, floats also support underscores for readability and scientific notation:</p> <pre><code>precise_value = 123.456_789  // 123.456789\nsmall_number = 5e-3          // 0.005\n</code></pre>"},{"location":"guide/basics/#bool","title":"bool","text":"<p>Rad uses lowercase <code>true</code> / <code>false</code>:</p> <pre><code>is_running = true\nis_tired = false\n</code></pre>"},{"location":"guide/basics/#list","title":"list","text":"<p>Rad has two collection types: lists and maps. First, let's look at lists.</p> <pre><code>names = [\"alice\", \"bob\", \"charlie\"]\n</code></pre> <p>Lists you define can contain any types:</p> <pre><code>mixed = [\"alice\", true, 50, -2.4]\n</code></pre> <p>They can also be nested:</p> <pre><code>nested = [\"alice\", [1, [\"very nested\", \"bird\"]]]\n</code></pre> <p>Indexing and slicing works very similarly to Python. Using the above 3 variables for an example, you can index with both positive and negative indexes:</p> <pre><code>print(names[0])\nprint(mixed[-1])  // grab last element in the list\nprint(nested[1][1][0])\n</code></pre> <pre><code>alice\n-2.4\nvery nested\n</code></pre> <p>You can also slice:</p> <pre><code>numbers = [10, 20, 30, 40, 50]\nprint(numbers[1:3])\nprint(numbers[2:])\nprint(numbers[:-1])\n</code></pre> <pre><code>[20, 30]\n[30, 40, 50]\n[10, 20, 30, 40]\n</code></pre> <p>String Indexing and Slicing</p> <p>All the same indexing and slicing rules that apply to lists also work with strings:</p> <pre><code>text = \"hello\"\nprint(text[0])      // h\nprint(text[-1])     // o\nprint(text[1:4])    // ell\nprint(text[:3])     // hel\n</code></pre>"},{"location":"guide/basics/#map","title":"map","text":"<p>The other collection type is 'map'. These may also be referred to as 'hashmap' or 'dictionary' in other languages.</p> <pre><code>scores = { \"alice\": 25, \"bob\": 17, \"charlie\": 36 }\n</code></pre> <p>Like lists, they can contain mixed types for values, and can nest.</p> <pre><code>mixed_map = { \n  \"alice\": \"accountant\",\n  \"mylist\": [ \"London\", 25 ],\n}\n\nnested_map = {\n  \"error\": {\n    \"msg\": \"Request failed!\",\n    \"code\": 400,\n  }\n}\n</code></pre> <p>If we take the above example, values can then be accessed in two ways. First is the square bracket lookup:</p> <pre><code>print(mixed_map[\"alice\"])\nprint(nested_map[\"error\"][\"msg\"])\n</code></pre> <pre><code>accountant\nRequest failed!\n</code></pre> <p>Alternatively, you can use a dot syntax. Note this second way only works for keys with no spaces in the name.</p> <pre><code>print(mixed_map.alice)\nprint(nested_map.error.msg)\n</code></pre> <pre><code>accountant\nRequest failed!\n</code></pre> <p>You can modify maps using either syntax:</p> <pre><code>mymap = { \"alice\": 30 }\n\nmymap[\"alice\"] = 40\nprint(mymap)\n\nmymap.alice = 50\nprint(mymap)\n</code></pre> <pre><code>{ alice: 40 }\n{ alice: 50 }\n</code></pre> <p>You can also add keys this way:</p> <pre><code>mymap = { \"alice\": 30 }\nmymap[\"bob\"] = 31\nmymap.charlie = 32\nprint(mymap)\n</code></pre> <pre><code>{ alice: 30, bob: 31, charlie: 32 }\n</code></pre> <p>Accessing a key that doesn't exist will cause an error. You can check if a key exists using <code>in</code>:</p> <pre><code>scores = { \"alice\": 25, \"bob\": 17 }\nprint(\"alice\" in scores)  // true\nprint(\"dave\" in scores)   // false\n</code></pre> <p>Alternatively, use the <code>??</code> fallback operator to provide a default value when a key is missing:</p> <pre><code>scores = { \"alice\": 25, \"bob\": 17 }\nprint(scores[\"alice\"] ?? 0)  // 25\nprint(scores[\"dave\"] ?? 0)   // 0\n</code></pre> <p>This is handy when you're not sure if a key exists and want to avoid errors.</p> <p>The <code>??</code> operator also works with lists and strings for out-of-bounds index access:</p> <pre><code>items = [\"a\", \"b\", \"c\"]\nprint(items[1] ?? \"missing\")   // b\nprint(items[10] ?? \"missing\")  // missing\n</code></pre>"},{"location":"guide/basics/#other-types","title":"Other Types","text":"<p>Rad has other types that we won't cover here. For example <code>null</code> and function references.</p>"},{"location":"guide/basics/#destructuring","title":"Destructuring","text":"<p>You can unpack values from lists into separate variables. Let's start with the traditional way of accessing list elements:</p> <pre><code>coords = [10, 20]\nprint(coords[0], coords[1])  // 10 20\n</code></pre> <p>Instead of using indices, you can destructure the list by unpacking its values into separate variables:</p> <pre><code>[x, y] = [10, 20]\nprint(x, y)  // 10 20\n</code></pre> <p>As syntactic sugar, the square brackets are optional:</p> <pre><code>x, y = 10, 20\nprint(x, y)  // 10 20\n</code></pre> <p>Keep in mind that this is still destructuring - Rad is creating a list <code>[10, 20]</code> behind the scenes and unpacking it into <code>x</code> and <code>y</code>.</p> <p>Destructuring is particularly useful when functions return multiple values:</p> <pre><code>x, y = get_coordinates()\nwidth, height = get_dimensions()\n</code></pre> <p>You can also destructure in for loops, which we'll see later in the Control Flow section.</p>"},{"location":"guide/basics/#operators","title":"Operators","text":"<p>Rad offers operators similar to many other languages. Below sections very quickly demonstrate.</p>"},{"location":"guide/basics/#arithmetic","title":"Arithmetic","text":"<p>Rad follows the standard order of operations for operators <code>() , * , / , % , + , -</code>:</p> <ol> <li>Parentheses</li> <li>Multiplication, Division, Modulo</li> <li>Addition, Subtraction</li> </ol> <pre><code>print(1 + 4 / 2)    // 3\nprint(2.5 * 3 - 1)  // 6.5\nprint((4 + 5) * 2)  // 18\nprint(5 % 3)        // 2\n</code></pre> <p>Dividing two integers will result in a floating point number.</p> <pre><code>print(5 / 2)  // 2.5\n</code></pre> <p>You can multiply strings to repeat them:</p> <pre><code>name = \"alice\"\nprint(name * 3)  // alicealicealice\n</code></pre>"},{"location":"guide/basics/#comparison","title":"Comparison","text":"<p>Comparisons return bools that can be used in e.g. if statements.</p> <p>String comparison is done based on contents.</p> <pre><code>print(\"alice\" == \"alice\")  // true\nprint(\"alice\" == \"bob\")    // false\nprint(\"alice\" != \"bob\")    // true\nprint(\"alice\" == \"Alice\")  // false\n</code></pre> <p>Numbers can also be compared with the standard comparators <code>&gt; , &gt;= , &lt; , &lt;= , ==</code>.</p> <pre><code>print(2 &gt;= 2)  // true\nprint(2 &gt; 2)   // false\nprint(2 &lt;= 2)  // true\nprint(2 &lt; 2)   // false\nprint(2 == 2)  // true\n</code></pre> <p>You cannot use these operators (outside of <code>==</code>) to compare non-numbers such as strings:</p> <pre><code>print(\"alice\" &gt; \"bob\")  // error\n</code></pre> <p>But you can check them for equality (will always return false, except ints and floats that are equal):</p> <pre><code>print(2 == \"alice\")  // false\nprint(2 == 2.0)      // true\n</code></pre> <p>Difference From Python on <code>True == 1</code> and <code>False == 0</code></p> <p>In Python, <code>False == 0</code> and <code>True == 1</code> are true, because under the hood, False is really int 0 and True is really int 1, hence they're equal. That's not the case in Rad. In Rad, any two values of different types are not equal (except ints/floats).</p> <p>The reasoning stems from truthy/falsy-ness. In Python, both <code>1</code> and <code>2</code> are truthy. But only <code>1</code> equals <code>True</code>. Rad avoids this oddity of making <code>1</code> special by instead making any two different types not equal (except ints/floats).</p>"},{"location":"guide/basics/#logical","title":"Logical","text":"<p>Rad uses <code>and</code> and <code>or</code> for binary logical operations.</p> <pre><code>print(false and false)  // false\nprint(false and true)   // false\nprint(true  and false)  // false\nprint(true  and true)   // true\n\nprint(false or  false)  // false\nprint(true  or  false)  // true\nprint(false or  true)   // true\nprint(true  or  true)   // true\n</code></pre> <p>And it uses <code>not</code> for logical negation.</p> <pre><code>print(not true)   // false\nprint(not false)  // true\n</code></pre>"},{"location":"guide/basics/#membership","title":"Membership","text":"<p>You can check if an item exists in a collection using the <code>in</code> operator:</p> <pre><code>names = [\"alice\", \"bob\", \"charlie\"]\nprint(\"alice\" in names)     // true\nprint(\"david\" in names)     // false\n</code></pre> <p>The <code>in</code> operator also works with strings to check for substrings:</p> <pre><code>text = \"hello world\"\nprint(\"world\" in text)      // true\nprint(\"goodbye\" in text)    // false\n</code></pre> <p>For maps, <code>in</code> checks if a key exists:</p> <pre><code>scores = { \"alice\": 25, \"bob\": 17 }\nprint(\"alice\" in scores)    // true\nprint(\"charlie\" in scores)  // false\n</code></pre> <p>You can use <code>not in</code> to check for the absence of an item:</p> <pre><code>print(\"david\" not in names)  // true\nprint(\"alice\" not in names)  // false\n</code></pre>"},{"location":"guide/basics/#concatenation","title":"Concatenation","text":"<p>To combine strings with other types, use string interpolation - it handles any type automatically:</p> <pre><code>count = 5\npi = 3.14\nprint(\"count: {count}, pi: {pi}\")\n</code></pre> <pre><code>count: 5, pi: 3.14\n</code></pre> <p>For joining strings together, you can also use the <code>+</code> operator:</p> <pre><code>first = \"Alice\"\nlast = \"Bobson\"\nprint(first + \" \" + last)\n</code></pre> <pre><code>Alice Bobson\n</code></pre> <p>The <code>+</code> operator requires both sides to be strings (errors also work, since they behave like strings for concatenation). To concatenate non-string values with <code>+</code>, convert them explicitly using <code>str</code>:</p> <pre><code>a = 1\ntext = \". Bullet point one\"\nprint(str(a) + text)\n</code></pre> <pre><code>1. Bullet point one\n</code></pre>"},{"location":"guide/basics/#compound-operators","title":"Compound Operators","text":"<p>Rad also supports compound operators for modifying variables in-place.</p> <pre><code>a = 3\na += 2   // a is now 5\na -= 1   // a is now 4\na *= 3   // a is now 12\na %= 10  // a is now 2\na /= 4   // a is now 0.5\n</code></pre>"},{"location":"guide/basics/#increment-decrement","title":"Increment / Decrement","text":"<p>You can quickly increment and decrement ints and floats using <code>++</code> and <code>--</code> syntax.</p> <pre><code>a = 2\na++\nprint(a)\n\nb = 2.5\nb--\nprint(b)\n</code></pre> <pre><code>3\n1.5\n</code></pre> <p>The increment and decrement operators produce statements, not expressions. This means that <code>a++</code> does not return anything, and so cannot be used inside e.g. a conditional.</p> <p>For example, the following two uses are invalid, because <code>a++</code> doesn't return a value:</p> <pre><code>a = 5\nif a++ &gt; 0:  // invalid, nothing for &gt; to evaluate against on the left side\n    ...\n\nb = a++  // also invalid because a++ doesn't return any value\n</code></pre> <p>Because of that, there's also no reason to support pre-incrementing, and so <code>++a</code> or <code>--a</code> are invalid statements.</p>"},{"location":"guide/basics/#ternary","title":"Ternary","text":"<p>Rad supports <code>? :</code> style ternary operators. </p> <p><code>&lt;condition&gt; ? &lt;true case&gt; : &lt;false case&gt;</code></p> <pre><code>a = 5\nb = a &gt; 0 ? \"larger than 0\" : \"less than 0\"\nprint(b)\n</code></pre> <pre><code>larger than 0\n</code></pre>"},{"location":"guide/basics/#functions","title":"Functions","text":"<p>Rad provides many built-in functions to help you write scripts. Functions can be invoked using a standard syntax:</p> <pre><code>names = [\"Bob\", \"Charlie\", \"Alice\"]\nnum_people = len(names)\nprint(\"There are {num_people} people.\")\n\nsorted_names = sort(names)\nprint(sorted_names)\n</code></pre> <pre><code>There are 3 people.\n[ \"Alice\", \"Bob\", \"Charlie\" ]\n</code></pre> <p>In this example, we use <code>len()</code> to get the list length, <code>sort()</code> to sort it, and <code>print()</code> to display output.</p> <p>You can also define your own custom functions - we'll cover that (and more) in detail in the Functions section. For a complete list of all built-in functions, see the Functions Reference.</p>"},{"location":"guide/basics/#control-flow","title":"Control Flow","text":""},{"location":"guide/basics/#if-statements","title":"If Statements","text":"<p>Rad employs very standard if statements.</p> <p>You are not required to wrap conditions in parentheses <code>()</code>.</p> <pre><code>if units == \"metric\":\n    print(\"That's 10 meters.\")\nelse if units == \"imperial\":\n    print(\"That's almost 33 feet.\")\nelse:\n    print(\"I don't know that measurement system!\")\n</code></pre> <p>Blocks use whitespace &amp; indentation</p> <p>Note that Rad uses whitespace &amp; indentation to denote blocks, instead of braces.</p> <p>As a convention, you can use 4 spaces for indentation. Mixing tabs and spaces is not allowed.</p>"},{"location":"guide/basics/#for-loops","title":"For Loops","text":"<p>Rad allows \"for each\" loops for iterating through collections such as lists.</p> <pre><code>names = [\"Alice\", \"Bob\", \"Charlie\"]\nfor name in names:\n    print(\"Hi {name}!\")\n</code></pre> <pre><code>Hi Alice!\nHi Bob!\nHi Charlie!\n</code></pre> <p>You can also iterate through a range of numbers using the <code>range</code> function, which returns a list of numbers within some specified range.</p> <pre><code>for i in range(5):\n    print(i)\n</code></pre> <pre><code>0\n1\n2\n3\n4\n</code></pre> <p>You can also invoke <code>range</code> with a starting value i.e. <code>range(start, end)</code> and with a step value i.e. <code>range(start, end, step)</code>.</p> <p>If you want to iterate through a list while also having access to the item's index, you can use the <code>with</code> clause to access a context object:</p> <pre><code>names = [\"Alice\", \"Bob\", \"Charlie\"]\nfor name in names with loop:\n    print(\"{name} is at index {loop.idx}\")\n</code></pre> <pre><code>Alice is at index 0\nBob is at index 1\nCharlie is at index 2\n</code></pre> <p>The context object provides two fields:</p> <ul> <li><code>loop.idx</code> - The current iteration index (0-based)</li> <li><code>loop.src</code> - An immutable snapshot of the original collection</li> </ul> <p>You can name the context variable anything you like, but <code>loop</code> is the convention for for-loops:</p> <pre><code>for name in names with loop:\n    print(\"Processing {loop.idx + 1} of {loop.src.len()}: {name}\")\n</code></pre> <pre><code>Processing 1 of 3: Alice\nProcessing 2 of 3: Bob\nProcessing 3 of 3: Charlie\n</code></pre> <p>Naming Convention</p> <p>By convention, use <code>loop</code> for context in for-loops and list comprehensions, and <code>ctx</code> for context in rad block lambdas.</p> <p>When iterating through a map, if you have one variable in the loop, then that variable will be the key:</p> <pre><code>colors = { \"alice\": \"blue\", \"bob\": \"green\" }\nfor k in colors:\n    print(k)\n</code></pre> <pre><code>alice\nbob\n</code></pre> <p>If you have two, then the first will be the key, and the second will be the value.</p> <pre><code>colors = { \"alice\": \"blue\", \"bob\": \"green\" }\nfor k, v in colors:\n    print(k, v)\n</code></pre> <pre><code>alice blue\nbob green\n</code></pre> <p>You can also combine map iteration with the context object:</p> <pre><code>for k, v in colors with loop:\n    print(\"{loop.idx}: {k} = {v}\")\n</code></pre> <pre><code>0: alice = blue\n1: bob = green\n</code></pre> <p>A useful function to know when iterating is <code>zip</code>. It lets you combine parallel lists into a list of lists. To demonstrate:</p> <pre><code>names = [\"alice\", \"bob\", \"charlie\"]\nages = [30, 40, 25]\nzipped = zip(names, ages)\nprint(zipped)  // [ [ \"alice\", 30 ], [ \"bob\", 40 ], [ \"charlie\", 25 ] ]\n</code></pre> <p>These inner lists can then be unpacked by specifying the appropriate number of identifiers in a for loop:</p> <pre><code>names = [\"alice\", \"bob\", \"charlie\"]\nages = [30, 40, 25]\nfor name, age in zip(names, ages):\n    print(name, age)\n</code></pre> <pre><code>alice 30\nbob 40\ncharlie 25\n</code></pre> <p>You can also access the index when unpacking with <code>zip</code>:</p> <pre><code>for name, age in zip(names, ages) with loop:\n    print(\"{loop.idx + 1}. {name} is {age}\")\n</code></pre> <pre><code>1. alice is 30\n2. bob is 40\n3. charlie is 25\n</code></pre>"},{"location":"guide/basics/#breaking-out-of-loops","title":"Breaking Out of Loops","text":"<p>You can exit a loop early using the <code>break</code> statement:</p> <pre><code>numbers = [1, 2, 3, 4, 5]\nfor n in numbers:\n    if n == 3:\n        break\n    print(n)\n</code></pre> <pre><code>1\n2\n</code></pre> <p>The loop stops completely when it reaches <code>3</code>, so numbers after that are never processed.</p>"},{"location":"guide/basics/#skipping-iterations","title":"Skipping Iterations","text":"<p>You can skip to the next iteration using the <code>continue</code> statement:</p> <pre><code>numbers = [1, 2, 3, 4, 5]\nfor n in numbers:\n    if n == 3:\n        continue\n    print(n)\n</code></pre> <pre><code>1\n2\n4\n5\n</code></pre> <p>The number <code>3</code> is skipped, but the loop continues with the remaining numbers.</p>"},{"location":"guide/basics/#while-loops","title":"While Loops","text":"<p>While loops repeat a block of code as long as a condition is true:</p> <pre><code>count = 0\nwhile count &lt; 3:\n    print(\"Count: {count}\")\n    count++\n</code></pre> <pre><code>Count: 0\nCount: 1\nCount: 2\n</code></pre> <p>You can create an infinite loop by omitting the condition:</p> <pre><code>while:\n    print(\"This runs forever!\")\n    // Use break to exit when needed\n</code></pre> <p>The <code>break</code> and <code>continue</code> statements work in while loops just like they do in for loops.</p>"},{"location":"guide/basics/#switch-statements","title":"Switch Statements","text":"<p>Rad has switch statements and switch expressions.</p> <p>You can <code>switch</code> on a value and write cases to match against, including a <code>default</code>.</p> <pre><code>args:\n    a float\n    op string\n    b float\n\nswitch op:\n    case \"add\":\n        result = a + b\n        print(\"added: {result}\")\n    case \"times\":\n        result = a * b\n        print(\"multiplied: {result}\")\n    default:\n        print(\"I don't know how to do that.\")\n</code></pre> <p>Cases can be written as blocks or single-line expressions. For example, the above <code>default</code> could be made into a single line:</p> <pre><code>args:\n    a float\n    op string\n    b float\n\nswitch op:\n    case \"add\":\n        result = a + b\n        print(\"added: {result}\")\n    case \"times\":\n        result = a * b\n        print(\"multiplied: {result}\")\n    default -&gt; print(\"I don't know how to do that.\")\n</code></pre> <p>The above examples are switch statements, because they do not return anything. Switch expressions can be used in assignments.</p> <pre><code>args:\n    object string\n\nsound = switch object:\n    case \"car\" -&gt; \"vroom\"\n    case \"mouse\" -&gt; \"squeak\"\n    default -&gt; \"moo\"  // default to cow\n\nprint(sound)\n</code></pre> <p>The above example cases are all single-line expressions (<code>case ... -&gt; ...</code>). If you want to write a case as a block in a switch expression, you can use the <code>yield</code> keyword to return values.</p> <p>Note also that you can assign and return more than 1 value at a time. To demonstrate:</p> <pre><code>args:\n    object string\n\nsound, plural = switch object:\n    case \"car\" -&gt; \"vroom\", \"cars\"\n    case \"mouse\" -&gt; \"squeak\", \"mice\"\n    default:\n        print(\"Don't know '{object}'; defaulting to cow.\")\n        yield \"moo\", \"cows\"\n\nprint(`{plural} go \"{sound}\"`)\n</code></pre>"},{"location":"guide/basics/#list-comprehensions","title":"List Comprehensions","text":"<p>List comprehensions provide a concise way to create lists by transforming or filtering existing collections. They use familiar for loop syntax but produce a new list as a result.</p>"},{"location":"guide/basics/#basic-syntax","title":"Basic Syntax","text":"<pre><code>numbers = [1, 2, 3, 4, 5]\nsquares = [x * x for x in numbers]\nprint(squares)\n</code></pre> <pre><code>[ 1, 4, 9, 16, 25 ]\n</code></pre> <p>The general pattern is <code>[expression for variable in collection]</code>, which creates a new list by evaluating the expression for each item in the collection.</p>"},{"location":"guide/basics/#using-functions","title":"Using Functions","text":"<p>You can call functions in list comprehensions:</p> <pre><code>words = [\"hello\", \"world\"]\nuppercase = [upper(word) for word in words]\nprint(uppercase)\n</code></pre> <pre><code>[ \"HELLO\", \"WORLD\" ]\n</code></pre>"},{"location":"guide/basics/#context-in-list-comprehensions","title":"Context in List Comprehensions","text":"<p>List comprehensions support the same <code>with</code> syntax as for loops:</p> <pre><code>items = [\"a\", \"b\", \"c\"]\nindexed = [\"{loop.idx}: {item}\" for item in items with loop]\nprint(indexed)\n</code></pre> <pre><code>[ \"0: a\", \"1: b\", \"2: c\" ]\n</code></pre>"},{"location":"guide/basics/#filtering-with-if","title":"Filtering with <code>if</code>","text":"<p>You can add an <code>if</code> clause to filter items while creating a list:</p> <pre><code>numbers = [1, 5, 10, 15, 20, 8]\nsmall_numbers = [x for x in numbers if x &lt; 10]\nprint(small_numbers)\n</code></pre> <pre><code>[ 1, 5, 8 ]\n</code></pre> <p>The filter condition can use any expression, including function calls:</p> <pre><code>words = [\"a\", \"ab\", \"abc\", \"abcd\"]\nshort_words = [w for w in words if len(w) &lt; 3]\nprint(short_words)\n</code></pre> <pre><code>[ \"a\", \"ab\" ]\n</code></pre> <p>You can combine filtering with transformation:</p> <pre><code>numbers = [1, 2, 3, 4, 5, 6]\neven_squares = [x * x for x in numbers if x % 2 == 0]\nprint(even_squares)\n</code></pre> <pre><code>[ 4, 16, 36 ]\n</code></pre> <p>Side Effects in Comprehensions</p> <p>If the expression in a comprehension produces side effects (like calling <code>print()</code>), the comprehension will still execute those side effects but returns an empty list:</p> <pre><code>[print(x) for x in [1, 2, 3]]  // Prints 1, 2, 3 but returns []\n</code></pre>"},{"location":"guide/basics/#truthy-falsy","title":"Truthy / Falsy","text":"<p>Rad supports truthy/falsy logic.</p> <p>This means that, instead of writing the following (as an example):</p> <pre><code>if len(my_list) &gt; 0:\n    print(\"My list has elements!\")\n</code></pre> <p>you can write</p> <pre><code>if my_list:\n    print(\"My list has elements!\")\n</code></pre> <p>Essentially, you can use any type as a condition, and it will resolve to true or false depending on the value.</p> <p>The following table shows which values return false for each type. All other values resolve to true.</p> Type Falsy Description string <code>\"\"</code> Empty strings int <code>0</code> Zero float <code>0.0</code> Zero list <code>[]</code> Empty lists map <code>{}</code> Empty maps <p>Blank strings and <code>null</code></p> <ul> <li>A string which is all whitespace e.g. <code>\" \"</code> is still truthy.</li> <li><code>null</code> is falsy.</li> </ul>"},{"location":"guide/basics/#converting-types","title":"Converting Types","text":"<p>Converting types may involve simple casts, or parsing.</p> <p>When casting, you can use the following functions: <code>str</code>,  <code>int</code>,  <code>float</code></p> <pre><code>print(int(2.1))  // 2\nprint(float(2))  // 2.0\nprint(str(2.2))  // \"2.2\"\n</code></pre> <p>Note that <code>int</code> and <code>float</code> will error on strings. To parse a string, use the following functions: <code>parse_int</code>,  <code>parse_float</code></p> <pre><code>print(parse_int(\"2\"))      // 2\nprint(parse_float(\"2.2\"))  // 2.2\n\nprint(parse_int(\"2.2\"))    // error\nprint(parse_float(\"bob\"))  // error\n</code></pre>"},{"location":"guide/basics/#errors","title":"Errors","text":"<p>When something goes wrong, Rad displays errors in a format designed to help you quickly locate and understand the problem:</p> <pre><code>error[RAD20029]: Index out of bounds: 5 (length 2)\n  --&gt; script.rad:11:13\n   |\n10 | names = [\"alice\", \"bob\"]\n11 | print(names[5])\n   |             ^\n   |\n   = info: rad explain RAD20029\n</code></pre> <p>Every error includes a code (like <code>RAD20029</code>) that identifies the type of error. To learn more about any error, use the <code>rad explain</code> command:</p> <pre><code>rad explain RAD20029\n</code></pre> <p>This displays detailed documentation about the error, including common causes and how to fix it.</p>"},{"location":"guide/basics/#summary","title":"Summary","text":"<ul> <li>We rapidly covered many basic topics such as assignment, data types, operators, and control flow.</li> <li>Rad has 6 basic types: strings, ints, floats, bools, lists, and maps.</li> <li>Strings and lists support indexing and slicing with the same syntax.</li> <li>Destructuring lets you unpack list values into separate variables: <code>x, y = [10, 20]</code> or simply <code>x, y = 10, 20</code>.</li> <li>Rad has operators such as <code>+ , - , * , / , %</code>. For bool logic, it uses <code>or</code> and <code>and</code>. For membership, <code>in</code> and <code>not in</code>.</li> <li>Rad provides many built-in functions like <code>len()</code>, <code>sort()</code>, <code>upper()</code>, and more. You can also define custom functions.</li> <li>Rad uses a \"for-each\" variety <code>for</code> loop. You always loop through items in a collection (or string).<ul> <li>If you want to increment through a number range, use the <code>range</code> function to generate you a list of ints.</li> <li>Use <code>break</code> to exit loops early and <code>continue</code> to skip to the next iteration.</li> </ul> </li> <li>List comprehensions provide a concise way to create lists: <code>[x * 2 for x in numbers]</code><ul> <li>Support filtering with <code>if</code>: <code>[x for x in numbers if x &lt; 10]</code></li> </ul> </li> <li>Rad also has <code>while</code> loops for repeating code while a condition is true.</li> <li>Rad offers truthy/falsy logic for more concise conditional expressions.</li> <li>Rad has switch statements and expressions. The latter uses <code>yield</code> as a keyword to return values from cases.</li> <li>Rad has functions for casting <code>str</code>, <code>int</code>, <code>float</code> and for parsing <code>parse_int</code>, <code>parse_float</code> values.</li> <li>When errors occur, use <code>rad explain &lt;code&gt;</code> to get detailed help.</li> </ul>"},{"location":"guide/basics/#next","title":"Next","text":"<p>Good job on getting through the basics of the language! </p> <p>Next, let's dive into one of the areas of Rad that make it shine: Args.</p>"},{"location":"guide/defer-errdefer/","title":"Defer & Errdefer","text":"<p>With defer statements, you can specify blocks of code to be run before the script exits.</p> <p>You may wish to use them to clean up or undo operations before exiting.</p>"},{"location":"guide/defer-errdefer/#defer","title":"Defer","text":"<p><code>defer</code> blocks always run before the script exits, regardless of if it's due to an error or not.</p> <p>Here is an example:</p> defer.rad<pre><code>$`mv notes.txt notes-tmp.txt`\ndefer:\n    $`mv notes-tmp.txt notes.txt`\n    print(\"Moved back!\")\n\n$`echo \"hi!\" &gt;&gt; notes.txt`\n$`cat notes.txt`\n</code></pre> <p>Let's say we already have a file <code>notes.txt</code> containing some text. In this script, we take the following steps, largely by invoking shell commands:</p> <ol> <li>Rename <code>notes.txt</code> to <code>notes-tmp.txt</code></li> <li>Define a <code>defer</code> block which will undo the rename, and then print <code>Moved back!</code>.</li> <li>Create a new <code>notes.txt</code> with the contents <code>hi!</code></li> <li>Print the contents <code>notes.txt</code> to show what it contains.</li> </ol> <p>When run:</p> <pre><code>rad defer.rl\n</code></pre> <pre><code>\u26a1\ufe0f Running: mv notes.txt notes-tmp.txt\n\u26a1\ufe0f Running: echo \"hi!\" &gt;&gt; notes.txt\n\u26a1\ufe0f Running: cat notes.txt\nhi!\n\u26a1\ufe0f Running: mv notes-tmp.txt notes.txt\nMoved back!\n</code></pre> <p>Note that despite the <code>Moved back!</code> print statement appearing earlier in the script, it only gets run at the end due to being in a <code>defer</code> block.</p>"},{"location":"guide/defer-errdefer/#errdefer","title":"Errdefer","text":"<p>Sometimes, you only want certain deferred statements to run in the event of a failure. This is useful when your script is working toward a critical step that, once executed, should not be rolled back. However, if the script fails before reaching that step, rollback actions may still be necessary.</p> <p>Below is an example of a version-bumping script. Using <code>sed</code>, this script replaces the version in a file called <code>VERSION</code>, stages the file with git, and commits it. However, if there's a failure in between the <code>sed</code> and <code>commit</code> steps, then we want to undo earlier steps as a cleanup, in order to make the script atomic i.e. it either succeeds entirely or does nothing, leaving no intermediary state changes behind. We accomplish this through <code>errdefer</code> blocks. </p> bump.rad<pre><code>args:\n    version str\n\npath = \"VERSION\"\n\n$`sed -i '' \"s/Version = .*/Version = {version}/\" {path}`\nerrdefer:\n    print(\"Undoing bump...\")\n    $`git checkout -- {path}`\n\nif false:  // failure simulation point 1\n    print(\"Oh no! ERROR!\")\n    exit(1)\n\n$`git add {path}`\nerrdefer:\n    print(\"Resetting {path}...\")\n    _, _ = $`git reset {path}`\n\nif false:  // failure simulation point 2\n    print(\"Bah! ERROR!\")\n    exit(1)\n\n$`git commit -m \"Bump version to {version}\"`\nprint(\"Done!\")\n</code></pre> <p>We include a couple of \"failure points\". We can set their condition to <code>true</code> to have them simulate an error, as the exit code of '1' indicates failure.</p> <p>Before we do that though, we can see an example of this script working correctly. Let's say we define our <code>VERSION</code> file in the same directory as the script as follows:</p> VERSION<pre><code>Version = 1\n</code></pre> <p>If we execute our script, we get the following output:</p> <pre><code>rad bump.rl 2\n</code></pre> <pre><code>\u26a1\ufe0f Running: sed -i '' \"s/Version = .*/Version = 2/\" VERSION\n\u26a1\ufe0f Running: git add VERSION\n\u26a1\ufe0f Running: git commit -m \"Bump version to 2\"\n[main 6ce2ebb] Bump version to 2\n 1 file changed, 1 insertion(+), 1 deletion(-)\nDone!\n</code></pre> <p>We can see the series of commands get run as we expect, including output from git. Notice that none of our <code>errdefer</code> blocks ran, because there were no failures.</p> <p>Now let's say that we activate failure point 1 by setting its condition to <code>true</code>. This means that, after performing the <code>sed</code> command, but before we <code>git add</code>, the script exits, and we trigger just the first <code>errdefer</code> block to 'reset' the <code>VERSION</code> file.</p> <pre><code>rad bump.rl 3\n</code></pre> <pre><code>\u26a1\ufe0f Running: sed -i '' \"s/Version = .*/Version = 3/\" VERSION\nOh no! ERROR!\nUndoing bump...\n\u26a1\ufe0f Running: git checkout -- VERSION\n</code></pre> <p>If you run this locally, you should see with <code>git status</code> that there are no changes to the <code>VERSION</code> file, thanks to our <code>errdefer</code> block rolling back the <code>sed</code> replacement.</p> <p>Next let's try deactivating failure point 1 again and enabling failure point 2, and running our script again. This time, we can expect the <code>git add</code> to run, and our failure will occur after, but before the <code>git commit</code>.</p> <pre><code>rad bump.rl 3\n</code></pre> <pre><code>\u26a1\ufe0f Running: sed -i '' \"s/Version = .*/Version = 3/\" VERSION\n\u26a1\ufe0f Running: git add VERSION\nBah! ERROR!\nResetting VERSION...\n\u26a1\ufe0f Running: git reset VERSION\nUndoing bump...\n\u26a1\ufe0f Running: git checkout -- VERSION\n</code></pre> <p>Here we see a very important detail about defer blocks that applies both to <code>defer</code> and <code>errdefer</code> - if you have multiple, they run in LIFO (last in, first out) order. In other words, the defer blocks defined later run first.</p> <p>This is typically desirable, as this example demonstrates. After we <code>git commit</code>, we need to first <code>git reset</code>, otherwise the <code>git checkout</code> to undo the bump won't work. Thanks to LIFO, our <code>git reset</code> runs first and all is good.</p>"},{"location":"guide/defer-errdefer/#errors-in-defer-blocks","title":"Errors in defer blocks","text":"<p>If a script exits successfully and has multiple <code>defer</code> blocks, and the first one to run encounters an error, the remaining defer blocks still run. This also applies to <code>errdefer</code>. However, the script will exit with a non-0 error code.</p> <p><code>errdefer</code> blocks are only triggered if the main script fails. If the main script runs successfully, but a <code>defer</code> block then errors, that does not trigger <code>errdefer</code> blocks to run.</p>"},{"location":"guide/defer-errdefer/#summary","title":"Summary","text":"<ul> <li>Use <code>defer</code> and <code>errdefer</code> blocks to run operations after your main script ends.</li> <li>They can commonly be used for clean up operations and making your scripts atomic.</li> <li>Defer blocks run in LIFO order - last in, first out.</li> </ul>"},{"location":"guide/defer-errdefer/#next","title":"Next","text":"<p>Now that you understand <code>defer</code>, you're ready to learn about stashes - Rad's built-in persistent storage that pairs perfectly with <code>defer</code> for saving state reliably.</p> <p>Continue to Stashes.</p>"},{"location":"guide/error-handling/","title":"Error Handling","text":"<p>Things go wrong in scripts - users provide invalid input, files don't exist, network requests fail. Generally, for smaller CLI scripts, it's okay if we just exit on the spot, and that's also Rad's default behavior. However, if you wish to more gracefully handle these errors or attempt recovery, Rad gives you the tools to do so.</p> <p>In Rad, errors are values. Functions that might fail return either a result or an error, and you can decide how to handle them. This makes error handling explicit, predictable, and easy to reason about.</p> <p>In this section, we'll explore:</p> <ul> <li>Error propagation - how errors bubble up by default (and why scripts exit)</li> <li>The <code>catch:</code> block - handle errors with full control (logging, reassignment, exit)</li> <li>The <code>??</code> operator - shorthand for fallback values on null or error</li> <li>The <code>catch</code> operator - like <code>??</code>, but only catches errors (null passes through)</li> <li>Creating errors - using <code>error()</code> in your own functions</li> <li>Error type unions - making fallible operations explicit with <code>T|error</code> type annotations</li> </ul>"},{"location":"guide/error-handling/#error-propagation","title":"Error Propagation","text":"<p>Let's start with a simple script that takes a user's age as input:</p> File: age<pre><code>args:\n    age_str str  # User's age as a string\n\nage = parse_int(age_str)\nprint(\"You are {age} years old\")\n</code></pre> <p>In reality, you'd instead declare the arg as an <code>int</code> and let Rad handle input validation, but for the purposes of this guide, we write it as a <code>str</code>.</p> <p>If we run this with a valid number, everything works:</p> <pre><code>rad age 25\n</code></pre> <pre><code>You are 25 years old\n</code></pre> <p>But what happens with invalid input?</p> <pre><code>rad age \"not-a-number\"\n</code></pre> <pre><code>Error at L4:7\n\nage = parse_int(age_str)\n      ^^^^^^^^^^^^^^^^^^ parse_int() failed to parse \"not-a-number\" (RAD20001)\n</code></pre> <p>The script exits immediately with an error code of 1 when <code>parse_int</code> encounters invalid input. What's happening is that <code>parse_int</code> returned an <code>error</code> value, and since we're not handling it, it immediately gets propagated up. Since we're at the root of the script and not nested within any other function call, this triggers a script exit on the spot.</p>"},{"location":"guide/error-handling/#nested-calls","title":"Nested Calls","text":"<p>Errors don't just propagate from built-in functions - they bubble up through your own function calls too. Here's an example:</p> <pre><code>fn calculate_discount(price_str: str) -&gt; float|error:\n    price = parse_float(price_str)  // Error starts here...\n    return price * 0.1\n\nfn process_order(item_price: str) -&gt; str|error:\n    discount = calculate_discount(item_price)  // ...propagates through here...\n    return \"Discount: {discount:.2} USD\"\n\nresult = process_order(\"invalid\")  // ...and exits the script here\nprint(result)\n</code></pre> <pre><code>Error at L2:13\n\n      price = parse_float(price_str)  // Error starts here...\n              ^^^^^^^^^^^^^^^^^^^^^^\n              parse_float() failed to parse \"invalid\" (RAD20002)\n</code></pre> <p>The error originates in <code>parse_float</code>, propagates through <code>calculate_discount</code>, then through <code>process_order</code>, and finally exits at the top level. At any point in this chain, we could choose to handle the error instead of letting it propagate.</p> <p>This sets up the question: how do we handle errors gracefully instead of crashing?</p>"},{"location":"guide/error-handling/#catch-blocks","title":"Catch Blocks","text":"<p>The <code>catch:</code> block gives you full control over error handling. Attach it as a suffix to any expression that might error, and you can inspect the error, log it, provide a fallback value, or decide whether to exit.</p>"},{"location":"guide/error-handling/#basic-error-handling","title":"Basic Error Handling","text":"<p>Here's how to handle our age parsing example gracefully:</p> File: age<pre><code>args:\n    age_str str\n\nage = parse_int(age_str) catch:\n    print_err(\"Invalid age, falling back to 0: {age}\")  // 'age' contains the error value\n    age = 0  // Provide fallback\n\nprint(\"Age: {age}\")\n</code></pre> <p>Now when we run it with invalid input:</p> <pre><code>rad age \"not-a-number\"\n</code></pre> <pre><code>Invalid age, falling back to 0: parse_int() failed to parse \"not-a-number\"\nAge: 0\n</code></pre> <p>The script continues running with our fallback value. Inside the <code>catch:</code> block, the <code>age</code> variable contains the error string, as returned by <code>parse_int</code>, which we can log or inspect. We then reassign <code>age</code> to a sensible default value of <code>0</code>.</p> <p>To summarize:</p> <ul> <li>Suffix form: write <code>... catch:</code> directly after the error-able expression.</li> <li>Binding: the target variable is first bound to the error value; inside the block, interpolating it (e.g. <code>{age}</code>) prints the error\u2019s message.</li> <li>Control: you can log, reassign a fallback, or exit(code).</li> <li>Flow: execution continues after the block unless you exit.</li> </ul>"},{"location":"guide/error-handling/#exiting-on-errors","title":"Exiting on Errors","text":"<p>Sometimes you want to fail fast - handle the error just enough to log a helpful message, then exit:</p> File: readconfig<pre><code>args:\n    config_file str\n\nconfig = read_file(config_file) catch:\n    print_err(\"Failed to read config: {config}\")\n    exit(1)\n\nprint(\"Config loaded successfully\")\n// Continue processing config...\n</code></pre> <p>Running this with a non-existent file:</p> <pre><code>rad readconfig \"missing.txt\"\n</code></pre> <pre><code>Failed to read config: open missing.txt: no such file or directory\n</code></pre> <p>This example is not much better than the default error propagation and exit, but you can imagine providing more useful guidance to users in a more detailed error message.</p>"},{"location":"guide/error-handling/#ignoring-errors-with-pass","title":"Ignoring Errors with <code>pass</code>","text":"<p>Sometimes you want to ignore errors entirely - the operation might fail, but that's perfectly fine and requires no action:</p> <pre><code>// Custom fn to clean up temp file if it exists\ndelete_path(temp_file) catch:\n    pass  // File already doesn't exist, that's fine\n\n// Continue with the rest of the script...\n</code></pre> <p>Here, <code>pass</code> does nothing - it's a way to explicitly say \"I know this might error, but I don't care.\" This is useful for cleanup operations where the failure itself is harmless.</p>"},{"location":"guide/error-handling/#the-operator","title":"The <code>??</code> Operator","text":"<p>For simple cases where you just want a default value without any logging or conditional logic, the <code>??</code> operator provides a concise shorthand:</p> <pre><code>age = parse_int(age_str) ?? 0\ntimeout = parse_int(get_env(\"TIMEOUT\")) ?? 30\nmax_retries = parse_int(config[\"retries\"]) ?? 5\n</code></pre> <p><code>??</code> fires when the left side is null or an error, making it a null-coalescing operator:</p> <pre><code>name = user[\"name\"] ?? \"anonymous\"   // handles both missing keys and null values\nconfig = read_file(config_path) ?? get_default_config()\n</code></pre> <p>The right side uses lazy evaluation - it's only evaluated if the left side is null or an error. This means you can safely call functions on the right without worrying about unnecessary work.</p> <p>This makes <code>??</code> useful for safely drilling into nested data. If any key along the way is missing or null, the whole expression falls back:</p> <pre><code>name = response.user.profile.display_name ?? \"anonymous\"\n</code></pre>"},{"location":"guide/error-handling/#the-catch-operator","title":"The <code>catch</code> Operator","text":"<p>The <code>catch</code> operator is similar to <code>??</code>, but only catches errors - null values pass through unchanged:</p> <pre><code>age = parse_int(age_str) catch 0      // error -&gt; 0, but null stays null\ndata = parse_json(raw_input) catch {}  // parse failure -&gt; empty map\n</code></pre> <p>This is useful when you want to handle errors but need to preserve null as a meaningful value:</p> <pre><code>m = {\"key\": null}\nm[\"key\"] ?? \"fallback\"     // -&gt; \"fallback\" (?? treats null as missing)\nm[\"key\"] catch \"fallback\"  // -&gt; null       (catch lets null through)\n</code></pre> <p>Like <code>??</code>, <code>catch</code> supports lazy evaluation and chaining:</p> <pre><code>result = risky_call() catch fallback_call() catch \"final default\"\n</code></pre> <p>Not to be confused with <code>catch:</code> blocks</p> <p>The <code>catch</code> operator is an inline expression. The <code>catch:</code> block (with a colon) is a statement-level construct covered above that gives you full control, including logging and conditional exit.</p>"},{"location":"guide/error-handling/#comparing-catch-and-catch","title":"Comparing <code>??</code>, <code>catch</code>, and <code>catch:</code>","text":"<p>These three give you different levels of control:</p> <pre><code>// ?? - fallback on null or error\nage = parse_int(age_str) ?? 0\n\n// catch - fallback on error only (null passes through)\nage = parse_int(age_str) catch 0\n\n// catch: block - full control (logging, conditional handling)\nage = parse_int(age_str) catch:\n    print_err(\"Invalid age '{age_str}': {age}\")\n    age = 0\n</code></pre> <p>When to use which</p> <p>Use <code>??</code> when you want a default for both null and error cases. Use <code>catch</code> when you only want to handle errors and null is a valid value. Use <code>catch:</code> when you need to log, inspect, or conditionally handle the error.</p>"},{"location":"guide/error-handling/#creating-your-own-errors","title":"Creating Your Own Errors","text":"<p>When writing your own functions, you can return errors using the <code>error(str)</code> function. If you're using type annotations, then functions that may return errors should reflect that in its return type: <code>T|error</code>.</p> <pre><code>fn validate_port(port: int) -&gt; int|error:\n    if port &lt; 1 or port &gt; 65535:\n        return error(\"Port must be between 1-65535, got {port}\")\n    return port\n\nfn start_server(port_str: str) -&gt; void:\n    port = parse_int(port_str) ?? 8080\n\n    validated_port = validate_port(port) catch:\n        print_err(\"Invalid port: {validated_port}\")\n        exit(1)\n\n    print(\"Starting server on port {validated_port}\")\n\nstart_server(\"99999\")\n</code></pre> <pre><code>Invalid port: Port must be between 1-65535, got 99999\n</code></pre> <p>Our custom error message provides clear feedback about what went wrong. By returning <code>int|error</code>, the type signature tells you three things:</p> <ol> <li>This function normally returns an <code>int</code></li> <li>It might return an <code>error</code> instead</li> <li>Callers should consider handling the error case (otherwise let it propagate)</li> </ol> <p>This pattern is used throughout Rad's built-in functions:</p> <ul> <li><code>parse_int(str) -&gt; int|error</code></li> <li><code>parse_float(str) -&gt; float|error</code></li> <li><code>read_file(path) -&gt; error|{ \"size_bytes\": int, \"content\": str }</code></li> <li><code>round(num, decimals) -&gt; error|int|float</code></li> </ul> <p>The error union makes your code self-documenting - anyone reading your function signature knows immediately that it can fail.</p> <p>More on Union Types</p> <p>We covered union types in detail in an earlier section: Type Annotations. Error unions are just one application of Rad's union type system.</p>"},{"location":"guide/error-handling/#summary","title":"Summary","text":"<p>Rad's error handling model gives you the tools to write robust scripts that handle failures gracefully:</p> <ul> <li>Errors are values that propagate by default, unless handled</li> <li>Scripts exit if errors propagate up to the root of the script</li> <li><code>catch:</code> blocks provide full error handling control:<ul> <li>Variable contains the error string inside the block</li> <li>You can log errors, provide fallbacks, or call <code>exit()</code></li> <li>Execution continues unless you explicitly exit</li> </ul> </li> <li><code>??</code> operator provides concise fallbacks on null or error<ul> <li>Use for simple cases without logging</li> <li>Right side only evaluated if left side is null or errors</li> </ul> </li> <li><code>catch</code> operator provides fallbacks on error only<ul> <li>Null values pass through unchanged</li> <li>Useful when null is a meaningful value you want to preserve</li> </ul> </li> <li>Create errors with <code>error(\"message\")</code> in your own functions</li> <li>Type unions (<code>T|error</code>) make fallible operations explicit in function signatures</li> </ul>"},{"location":"guide/error-handling/#next","title":"Next","text":"<p>CLI scripts and the shell go hand in hand, and Rad offers first-class support for invoking shell commands and handling its output. We explore this in the next section: Shell Commands.</p>"},{"location":"guide/functions/","title":"Functions","text":"<p>Rad offers a range of built-in functions to help you write your scripts, and also allows you to define your own. In this section, we'll take a look at the syntax and a few examples. For a complete list of built-in functions, see the reference.</p>"},{"location":"guide/functions/#syntax","title":"Syntax","text":"<p>The syntax for invoking functions is pretty standard. Here's a script with some examples:</p> <pre><code>names = [\"Bob\", \"Charlie\", \"Alice\"]\nnum_people = len(names)\nprint(\"There are {num_people} people.\")\n\nsorted_names = sort(names)\nprint(sorted_names)\n</code></pre> <pre><code>There are 3 people.\n[ \"Alice\", \"Bob\", \"Charlie\" ]\n</code></pre> <p>This example uses three different built-in functions <code>len</code>, <code>print</code>, and <code>sort</code>.</p>"},{"location":"guide/functions/#ufcs","title":"UFCS","text":"<p>Rad supports a syntax called Uniform Function Call Syntax (UFCS) that lets you call functions using dot notation. This means you can write:</p> <pre><code>upper(\"hello\")\n\n// ... is the same as ...\n\n\"hello\".upper()\n</code></pre> <p>Both styles work identically, it's just syntactic sugar, but the dot notation really shines when you're chaining multiple function calls together.</p> <p>Compare these two approaches:</p> <pre><code>// Traditional nested calls - hard to read\nresult = upper(trim(text))\n\n// UFCS chaining - reads left to right\nresult = text.trim().upper()\n</code></pre> <p>The chained version is much more readable - you can follow the data flow naturally from left to right.</p> <p>UFCS works with any function where its first parameter matches the type you're calling it on.</p> <p>Encouraged Style</p> <p>You're encouraged to use UFCS, especially when it helps you avoid nested function calls.</p>"},{"location":"guide/functions/#function-arguments","title":"Function Arguments","text":"<p>Rad functions can accept arguments in several different ways. Let's explore each pattern.</p>"},{"location":"guide/functions/#positional-arguments","title":"Positional Arguments","text":"<p>Most functions accept arguments by position - you pass values in a specific order. Here are a few examples:</p> <pre><code>// Single argument\nnum = abs(-5)\nprint(num)  // 5\n\n// Multiple arguments\ntext = \"hello world\".replace(\"world\", \"Rad\")\nprint(text)  // hello Rad\n</code></pre> <p>Many functions also have optional parameters with defaults. For example, <code>join</code> combines list items into a string:</p> <pre><code>numbers = [1, 2, 3]\n\n// Just the list - uses default separator \"\"\nprint(numbers.join())\n\n// Custom separator\nprint(numbers.join(\"... \"))\n\n// Separator and prefix\nprint(numbers.join(\"... \", \"Counting: \"))\n\n// Separator, prefix, and suffix\nprint(numbers.join(\"... \", \"Counting: \", \"!\"))\n</code></pre> <pre><code>123\n1... 2... 3\nCounting: 1... 2... 3\nCounting: 1... 2... 3!\n</code></pre> <p>The function signature for <code>join</code> shows these optional parameters: <code>join(list, sep=\"\", prefix=\"\", suffix=\"\")</code>. You can provide as many or as few as you need.</p> <p>Example using join for url query params</p> <p>The <code>prefix</code> parameter is handy for generating URL query params:</p> <pre><code>url = \"https://api.github.com/repos/amterp/rad/commits\"\nquery_params = [\"path=README.md\", \"per_page=5\"]\nurl += query_params.join(\"&amp;\", \"?\")\nprint(url)\n</code></pre> <p>This produces: <code>https://api.github.com/repos/amterp/rad/commits?path=README.md&amp;per_page=5</code></p>"},{"location":"guide/functions/#named-arguments","title":"Named Arguments","text":"<p>Some functions accept named arguments that you pass using <code>name=value</code> syntax. Named arguments always come after positional arguments and are typically optional.</p> <p>A good example is <code>http_post</code>, which performs HTTP POST requests:</p> <pre><code>// Just the URL (simplest form)\nresponse = url.http_post()\n\n// With custom headers\nmy_headers = {\n    \"Authorization\": \"Bearer {token}\",\n}\nresponse = url.http_post(headers=my_headers)\n\n// With both headers and a body\nresponse = url.http_post(headers=my_headers, body=data)\n</code></pre> <p>Named arguments make it clear what each value represents, especially when a function has many optional parameters.</p>"},{"location":"guide/functions/#variadic-arguments","title":"Variadic Arguments","text":"<p>Some functions accept unlimited arguments. For example, <code>zip</code> can combine any number of lists:</p> <pre><code>names = [\"alice\", \"bob\", \"charlie\"]\nages = [30, 40, 25]\ncities = [\"NYC\", \"LA\", \"Chicago\"]\nscores = [100, 90, 85]\n\n// Combine 2 lists\npairs = zip(names, ages)\nprint(pairs)\n\n// Combine 3 lists\ntriples = zip(names, ages, cities)\nprint(triples)\n\n// Combine 4 lists (or more!)\nquads = zip(names, ages, cities, scores)\nprint(quads)\n</code></pre> <pre><code>[ [ \"alice\", 30 ], [ \"bob\", 40 ], [ \"charlie\", 25 ] ]\n[ [ \"alice\", 30, \"NYC\" ], [ \"bob\", 40, \"LA\" ], [ \"charlie\", 25, \"Chicago\" ] ]\n[ [ \"alice\", 30, \"NYC\", 100 ], [ \"bob\", 40, \"LA\", 90 ], [ \"charlie\", 25, \"Chicago\", 85 ] ]\n</code></pre> <p>Variadic functions can also have named arguments. For example, <code>zip</code> accepts <code>strict=true</code> for ensuring that all lists have the same length.</p>"},{"location":"guide/functions/#mixed-patterns","title":"Mixed Patterns","text":"<p>Some functions combine multiple argument patterns. For example, <code>pick</code> takes positional arguments and a named argument:</p> <pre><code>options = [\"vim\", \"emacs\", \"nano\"]\neditor = pick(options, prompt=\"Choose your editor\")\n</code></pre> <p>When in doubt about how to call a function, check the Functions Reference for complete signature details.</p>"},{"location":"guide/functions/#custom-functions","title":"Custom Functions","text":"<p>Rad lets you define your own functions using the <code>fn</code> keyword. You can create either named functions that you reference by name, or lambdas (anonymous functions) that you assign to variables or pass as arguments.</p>"},{"location":"guide/functions/#named-functions","title":"Named Functions","text":"<p>Named functions include the function name as part of the definition, making them easy to call from anywhere in your code.</p>"},{"location":"guide/functions/#basic-definition","title":"Basic Definition","text":"<p>Here's a simple function that adds two numbers:</p> <pre><code>fn add(x, y):\n    return x + y\n\nresult = add(5, 3)\nprint(result)  // 8\n</code></pre> <p>Functions use the <code>return</code> keyword to send values back. If your function body is a single expression, you can use a more concise syntax:</p> <pre><code>fn add(x, y) x + y\n\nresult = add(5, 3)\nprint(result)  // 8\n</code></pre> <p>Notice there's no colon (<code>:</code>) after the parameters in the single-line form, and no <code>return</code> keyword is needed.</p>"},{"location":"guide/functions/#multiple-return-values","title":"Multiple Return Values","text":"<p>Functions can return multiple values at once using comma separation:</p> <pre><code>fn get_coords():\n    x = 10\n    y = 20\n    return x, y  // equivalent to 'return [x, y]'\n\nx_pos, y_pos = get_coords()\nprint(\"Position: ({x_pos}, {y_pos})\")\n</code></pre> <pre><code>Position: (10, 20)\n</code></pre> <p>This uses destructuring (covered in Basics) to unpack the returned values into separate variables.</p>"},{"location":"guide/functions/#type-annotations","title":"Type Annotations","text":"<p>You can optionally add type annotations to function parameters and return values:</p> <pre><code>fn calculate_area(width: int, height: int) -&gt; int:\n    return width * height\n\narea = calculate_area(5, 10)\nprint(area)  // 50\n</code></pre> <p>There are three benefits to using these.</p> <ol> <li>They serve as documentation (self-documenting code).</li> <li>They are validated at runtime i.e. the above function will error early if a string is passed into <code>calculate_area</code>.</li> <li>They help Rad's static analysis tools reason about your code, making them more useful.</li> </ol> <p>They are covered in detail in a later section: Type Annotations.</p>"},{"location":"guide/functions/#hoisting","title":"Hoisting","text":"<p>Named functions have some special scoping rules worth knowing:</p> <p>At the root level, functions are hoisted - you can call them before they're defined:</p> <pre><code>result = multiply(4, 5)\nprint(result)  // 20\n\nfn multiply(a, b):\n    return a * b\n</code></pre> <p>This works because Rad processes all root-level function definitions before executing the script.</p> <p>Inside blocks, functions are NOT hoisted - you must define them before calling:</p> <pre><code>if true:\n    print(helper())  // Error - can't call before definition\n\n    fn helper():\n        return \"I'm a helper!\"\n\n    print(helper())  // This is okay!\n</code></pre>"},{"location":"guide/functions/#lambdas","title":"Lambdas","text":"<p>Sometimes you need a quick function without giving it a name. That's where lambdas come in - they're anonymous functions you can assign to variables or pass as arguments.</p> <p>Lambdas use the same <code>fn</code> keyword, but without a name:</p> <pre><code>// Single-line lambdas\ndouble = fn(x) x * 2\nadd = fn(x, y) x + y\n\nprint(double(5))  // 10\nprint(add(3, 4))  // 7\n</code></pre> <p>For multi-line logic, use the block style with a colon:</p> <pre><code>calculate = fn(x):\n    result = x * 2 + 10\n    return result\n\nprint(calculate(5))  // 20\n</code></pre> <p>Lambdas are particularly useful for defining once-off operations and passing them as arguments. For example, with <code>map</code>, <code>filter</code>, and <code>flat_map</code>:</p> <pre><code>numbers = [1, 2, 3, 4, 5]\ndoubled = numbers.map(fn(x) x * 2)\nprint(doubled)  // [2, 4, 6, 8, 10]\n\nevens = numbers.filter(fn(x) x % 2 == 0)\nprint(evens)  // [2, 4]\n\n// flat_map is useful for transformations that produce lists\nwords = [\"hello world\", \"foo bar\"]\nall_words = words.flat_map(fn(s) s.split(\" \"))\nprint(all_words)  // [\"hello\", \"world\", \"foo\", \"bar\"]\n</code></pre> <p>Named Functions vs Lambdas</p> <ul> <li>Use named functions (<code>fn add(x, y):</code>) for reusable logic that you'll call from multiple places</li> <li>Use lambdas (<code>fn(x) x * 2</code>) for one-off operations or callbacks</li> </ul>"},{"location":"guide/functions/#reference","title":"Reference","text":"<p>There are a lot of built-in functions. If you want to see what's available and how to use them, refer to the reference.</p>"},{"location":"guide/functions/#summary","title":"Summary","text":"<ul> <li>Function invocation syntax is similar to Python, Java, and other familiar languages</li> <li>UFCS (Uniform Function Call Syntax) lets you chain functions using dot notation: <code>text.trim().upper()</code></li> <li>Functions can accept arguments in several ways:<ul> <li>Positional: passed by order, may have defaults (<code>join(list)</code>, <code>join(list, \"|\")</code>)</li> <li>Named: passed with <code>name=value</code> syntax (<code>http_get(url, headers=my_headers)</code>)</li> <li>Variadic: accept unlimited arguments (<code>zip(list1, list2, list3, ...)</code>)</li> <li>Mixed: combinations of the above patterns</li> </ul> </li> <li>You can define named functions with <code>fn name():</code> for reusable logic<ul> <li>Supports block style (with <code>:</code>) </li> <li>Supports single-line style (without <code>:</code> e.g. <code>fn add(x, y) x + y</code>)</li> <li>Can return multiple values using comma separation</li> <li>Are hoisted at the root of scripts (can be called before definition)</li> <li>Can have optional type annotations</li> </ul> </li> <li>Lambdas are anonymous functions: <code>double = fn(x) x * 2</code><ul> <li>Useful for one-off operations and callbacks - functions like <code>map()</code>, <code>filter()</code>, and <code>flat_map()</code></li> </ul> </li> </ul>"},{"location":"guide/functions/#next","title":"Next","text":"<p>We've already covered the Basics of strings, but there are some more advanced string concepts which are worth covering, such as formatting in string interpolations, raw strings, etc.</p> <p>We'll cover these in the next section: Strings (Advanced)</p>"},{"location":"guide/getting-started/","title":"Getting Started","text":""},{"location":"guide/getting-started/#what-is-rad","title":"What is Rad?","text":"<p>If you want to jump straight to programming, feel free to skip forwards to Installation.</p> <p>Rad is a modern programming language and interpreter designed to make writing CLI scripts delightful. It has a familiar, Python-like syntax with built-in concepts like declarative arguments, JSON handling, first-class shell integration, and user prompts - making common scripting tasks easy and fast to implement.</p> <p>If you've ever written scripts and felt like your tools were fighting you, you're not alone:</p> <p>With Bash, you might find yourself:</p> <ul> <li>Wrestling with <code>while getopts</code> boilerplate just to parse a few arguments</li> <li>Doing <code>curl | jq | awk</code> gymnastics to process JSON</li> <li>Skipping the \"nice-to-haves\" like <code>--help</code> or input validation because they're too painful to implement</li> <li>Delivering scripts that work, but are hard to read and harder to maintain</li> </ul> <p>With Python, you get better syntax, but:</p> <ul> <li>You need argparse boilerplate before you even start solving your problem, or reach for additional libraries</li> <li>Sharing scripts means coordinating runtimes and dependencies (virtualenvs, lockfiles)</li> <li>Simple CLI tasks feel heavier than they should</li> </ul> <p>With Rad, the language is purpose-built for CLI scripting:</p> <ul> <li>Delightful to write - familiar syntax without the footguns</li> <li>Self-documenting - automatic <code>--help</code> generation from your code comments</li> <li>Declarative arguments - type checking, validation, and parsing built into the language</li> <li>Easy to share - batteries included, no external dependencies needed</li> </ul> <p>If you ever write a CLI script, Rad is the language to do it in.</p> <p>Project Status: Rad is in early development but useful today for real scripts. Core features work well, though expect breaking changes between versions as the language evolves. Your feedback directly shapes Rad's future!</p> <p>Let's get into it.</p>"},{"location":"guide/getting-started/#installation","title":"Installation","text":""},{"location":"guide/getting-started/#macos-homebrew","title":"macOS (Homebrew)","text":"<pre><code>brew install amterp/rad/rad\n</code></pre>"},{"location":"guide/getting-started/#go-from-source-all-platforms","title":"Go (from source, all platforms)","text":"<pre><code>go install github.com/amterp/rad@latest\ngo install github.com/amterp/rad/lsp-server@latest\n</code></pre> <p>The first command installs the <code>rad</code> interpreter. The second installs <code>radls</code>, the language server for editor support.</p> <p>Note: You will need to run <code>go install</code> yourself to upgrade Rad as new versions are released. For automated updates, use one of the supported package managers that allow it.</p>"},{"location":"guide/getting-started/#binary-downloads","title":"Binary Downloads","text":"<p>Pre-built binaries for macOS, Linux, and Windows: releases page</p> <p>Each release archive includes both <code>rad</code> (the interpreter) and <code>radls</code> (the language server).</p>"},{"location":"guide/getting-started/#checking-installation","title":"Checking Installation","text":"<p>After you've installed Rad and ensured it's on your PATH, you can check your installation:</p> <pre><code>rad -h\n</code></pre> <p>If this prints the help string for Rad, you're set!</p>"},{"location":"guide/getting-started/#editor-support","title":"Editor Support","text":""},{"location":"guide/getting-started/#visual-studio-code","title":"Visual Studio Code","text":"<p>Rad has a VS Code extension here which provides:</p> <ul> <li>Syntax highlighting - makes your Rad code easy to read</li> <li>Real-time validation - catches syntax errors as you type</li> <li>Diagnostics - warnings and hints from the Rad Language Server</li> </ul> <p>Installing it is highly recommended!</p> <p></p> <p>Language Server Requirement</p> <p>The VS Code extension uses the Rad Language Server (<code>radls</code>) for real-time validation and diagnostics. This is installed automatically when you install Rad via Homebrew or <code>go install</code>.</p> <p>If you see \"Rad Language Server not found\", make sure <code>rad</code> and <code>radls</code> are on your PATH.</p>"},{"location":"guide/getting-started/#other-editors","title":"Other Editors","text":"<p>The Rad Language Server (<code>radls</code>) can be used with any editor that supports the Language Server Protocol (LSP):</p> <ul> <li>Neovim: Configure with <code>nvim-lspconfig</code> - point it to the <code>radls</code> binary</li> <li>Sublime Text: Use the LSP package with the <code>radls</code> command</li> </ul> <p>For syntax highlighting without LSP, Rad's TextMate grammar can be used in editors that support it.</p>"},{"location":"guide/getting-started/#your-first-rad-script-hello-world","title":"Your First Rad Script - Hello World","text":"<p>Let's write the classic \"Hello, World!\" program. We'll then modify it to give it a bit of a Rad twist, demoing a few features that Rad provides.</p> <p>First, create a file, let's call it simply <code>hello</code>, and give it the following contents:</p> <pre><code>print(\"Hello, World!\") \n</code></pre> <p><code>print()</code></p> <p><code>print()</code> is the go-to function for outputting to stdout. It behaves a lot like <code>print()</code> in Python.</p> <p>You can read more about it in the reference.</p> <p>File Extension</p> <p>If you want to give your Rad scripts an extension, you can use <code>.rad</code> as a convention.</p> <p>Then, run the script from your CLI by invoking <code>rad</code> on it, and you should see it print out like so:</p> <pre><code>&gt; rad hello\n</code></pre> <pre><code>Hello, World!\n</code></pre> <p>Nice! Now, let's spruce it up with a few Rad features.</p>"},{"location":"guide/getting-started/#adding-in-some-rad-features","title":"Adding In Some Rad Features","text":"<p>One of Rad's primary features is its simple, declarative style to defining script arguments.</p> <p>Let's modify the script to greet a name you input from command line.</p> <pre><code>args:\n  name str\n\nprint(\"Hello, {name}!\")\n</code></pre> <p>A couple of things to note here:</p> <ol> <li>We define an \"args block\". Right now it contains just the one line, but you can do lots of things in here.</li> <li>The modified <code>print()</code> utilizes string interpolation. String interpolation in Rad behaves a lot like it does in Python (you'll see this is a pattern).</li> </ol> <p>Now, let's try invoking the script again, and this time, input a name:</p> <pre><code>&gt; rad hello Alex\n</code></pre> <pre><code>Hello, Alex!\n</code></pre> <p>Cool! What happens if we invoke without a name?</p> <pre><code>&gt; rad hello\n</code></pre> <pre><code>Usage:\n  hello &lt;name&gt;\n\nScript args:\n      --name str\n</code></pre> <p>If you run a Rad script without providing any args to a script which expects at least one, Rad will print out the script usage, interpreting your invocation as if you had passed <code>--help</code>.</p> <p>Positional vs Flag Arguments</p> <p>Arguments can be passed positionally or via flags. For example, both <code>./hello Alice</code> and <code>./hello --name Alice</code> work identically. The help text shows both forms: <code>&lt;name&gt;</code> for positional usage and <code>--name str</code> for the flag form.</p> <p>This shows a little of the automatic script usage that Rad generates for you. Let's explore that a bit more.</p>"},{"location":"guide/getting-started/#improving-the-script-usage-string","title":"Improving The Script Usage String","text":"<p>Rad facilitates writing well-documented and easy-to-use scripts, in part through unique syntax. Let's use a couple of those now.</p> <p>First, we'll add a file header to your script.</p> <pre><code>---\nPrints a polite greeting using an input name.\n---\nargs:\n  name str\n\nprint(\"Hello, {name}!\")\n</code></pre> <p>File Headers</p> <p>File headers, as the name suggests, go at the top of Rad scripts (with the exception of shebangs, to be covered later).  They allow you to write a description for your script in between two <code>---</code> lines. The contents will get printed as part of the script's usage string.</p> <p>A couple of ideas on what to cover in your file headers:</p> <ul> <li>A brief description of what the script does and how it works</li> <li>Examples of valid invocations and what they do.</li> </ul> <p>Second, we can add comments to args that a script declares. Let's do that too:</p> <pre><code>---\nPrints a polite greeting using an input name.\n---\nargs:\n  name str  # The name of someone to greet.\n\nprint(\"Hello, {name}!\")\n</code></pre> <p>Note on <code>#</code> vs. <code>//</code></p> <p>Rad uses <code>#</code> to denote arg comments. <code>#</code> comments are special and do get passed to Rad's parser and can affect script behavior (namely in this case, adding information to the script usage string). </p> <p>Standard code comments in Rad use <code>//</code>, similar to Java or C/C++, and don't impact script behavior.</p> <p>Now, when someone reads the script, it's pretty clear what the script does and what the expected arguments are.</p> <p>But it gets better! Let's try invoking the script's usage string again (this time let's try using the <code>-h</code> flag explicitly, though it's not necessary):</p> <pre><code>&gt; rad hello -h\n</code></pre> <pre><code>Prints a polite greeting using an input name.\n\nUsage:\n  hello &lt;name&gt;\n\nScript args:\n      --name str   The name of someone to greet.\n</code></pre> <p>Not only is the script now easier to maintain for developers, it's also easier for users to understand!</p>"},{"location":"guide/getting-started/#shebang","title":"Shebang","text":"<p>Needing to manually invoke <code>rad</code> each time you want to run a Rad script can be a little cumbersome. Thankfully, Unix kernels provide a mechanism known as a \"shebang\".</p> <p>Let's add one to our script. It has to go on the very first line.</p> <pre><code>#!/usr/bin/env rad\n---\nPrints a polite greeting using an input name.\n---\nargs:\n  name str  # The name of someone to greet.\n\nprint(\"Hello, {name}!\")\n</code></pre> <p>Then, make the script executable using the following command:</p> <pre><code>chmod +x ./hello\n</code></pre> <p>Now, you can invoke the script directly:</p> <pre><code>&gt; ./hello Bob\n</code></pre> <pre><code>Hello, Bob!\n</code></pre> <p>When you invoke an executable script this way, the kernel scans for a shebang (<code>#!</code>) in the first line. If it finds a path to an interpreter (in this case, it will find <code>rad</code>, if set up correctly in your <code>PATH</code>), then it will invoke said interpreter on the script (equivalent to <code>rad hello</code> like we were doing before).</p> <p>rad new</p> <p>Rad has a command <code>rad new &lt;script&gt;</code> which saves you repeating these steps. It creates a ready-to-edit executable file with a <code>rad</code> shebang on the top.</p>"},{"location":"guide/getting-started/#a-complete-example","title":"A Complete Example","text":"<p>Now that you've seen the basics, let's skip ahead a little with our example, to get a better idea of what Rad can really do. Don't worry - we'll cover everything in detail in later sections. For now, just observe what Rad gives you for free.</p> <p>Update your <code>hello</code> script to this:</p> <pre><code>#!/usr/bin/env rad\n---\nPrints a polite greeting using an input name.\n---\nargs:\n  name str                # The name of someone to greet.\n  times t int = 1         # How many times to greet them.\n  style s str = \"normal\"  # Greeting style.\n\n  times range (0, 10]\n  style enum [\"normal\", \"excited\", \"formal\"]\n\ngreeting = switch style:\n  case \"excited\" -&gt; \"HEY\"\n  case \"formal\" -&gt; \"Good day\"\n  default -&gt; \"Hello\"\n\nfor i in range(times):\n  print(\"{greeting}, {name}!\")\n</code></pre> <p>What we added:</p> <ul> <li>Two more arguments with default values (<code>times</code> and <code>style</code>)</li> <li>Short flag aliases (<code>-t</code> and <code>-s</code>) for convenience</li> <li>Argument constraints<ul> <li><code>times</code> must be greater than 0, and max 10 (inclusive)</li> <li><code>style</code> must be one of three values</li> </ul> </li> <li>A switch expression to map style to greeting text</li> <li>A for loop to repeat the greeting</li> </ul> <p>All of this in ~20 lines, with zero validation boilerplate.</p>"},{"location":"guide/getting-started/#try-it-out","title":"Try it out","text":"<p>Normal usage with short flags:</p> <pre><code>&gt; ./hello Alice -t 3 -s excited\n</code></pre> <pre><code>HEY, Alice!\nHEY, Alice!\nHEY, Alice!\n</code></pre> <p>Check the automatically generated help:</p> <pre><code>&gt; ./hello -h\n</code></pre> <pre><code>Prints a polite greeting using an input name.\n\nUsage:\n  hello &lt;name&gt; [times] [style] [OPTIONS]\n\nScript args:\n      --name str    The name of someone to greet.\n  -t, --times int   How many times to greet them. Range: (0, 10] (default 1)\n  -s, --style str   Greeting style. Valid values: [normal, excited, formal] (default normal)\n</code></pre> <p>Note how the constraints appear in the help automatically.</p>"},{"location":"guide/getting-started/#what-about-invalid-input","title":"What about invalid input?","text":"<p>Try providing an invalid range:</p> <pre><code>&gt; ./hello Bob -t 15\n</code></pre> <pre><code>'times' value 15 is &gt; maximum 10\n</code></pre> <p>Try an invalid enum value:</p> <pre><code>&gt; ./hello Bob -s casual\n</code></pre> <pre><code>Invalid 'style' value: casual (valid values: normal, excited, formal)\n</code></pre> <p>You didn't write any of this validation code. Rad enforced the constraints you declared and generated helpful error messages automatically.</p>"},{"location":"guide/getting-started/#summary","title":"Summary","text":"<p>In this section, we were introduced to several key features:</p> <ul> <li>String interpolation with <code>{variable}</code> syntax for readable output</li> <li>args blocks for declarative argument definitions</li> <li>File headers and arg comments for self-documenting scripts</li> <li>Shebangs to make scripts more convenient to run</li> <li>Argument constraints (range, enum) with automatic validation - no manual validation needed</li> <li>Short flag aliases for better user experience</li> <li>Automatic <code>--help</code> generation from your code comments</li> </ul> <p>Features you'd normally skip in Bash, or need external dependencies for in other languages, come built-in with Rad's declarative syntax. \ud83e\udd19</p> <p>Note on Rad script content ordering</p> <p>Rad expects a certain order between shebangs, file headers, arg blocks, and the rest of your code.</p> <p>It's important to adhere to the following ordering in Rad scripts, or you'll see errors:</p> <p>1) Shebang (if present)</p> <p>2) File header (if present)</p> <p>3) Args block (if present)</p> <p>4) Rest of the file</p>"},{"location":"guide/getting-started/#next","title":"Next","text":"<p>Great job on getting this far! You've gotten a small peek at what Rad has to offer.</p> <p>From here, you have a couple of options:</p> <ol> <li> <p>Continue your Rad journey: dive into more details with the next section: Basics.</p> </li> <li> <p>If you'd like to see additional unique Rad features, here are some sections you can jump to:</p> <ul> <li>Args</li> <li>Rad Blocks</li> <li>Shell Commands</li> <li>Example: brewi</li> </ul> </li> </ol>"},{"location":"guide/global-flags/","title":"Global Flags","text":"<p>Rad offers a range of global flags that are available with every Rad script. We'll explore some of them in this section.</p>"},{"location":"guide/global-flags/#help","title":"<code>help</code>","text":"<p>The most basic global flag is <code>--help</code> or <code>-h</code>. All Rad scripts automatically generate a usage string that can be displayed by invoking this flag.</p> <p><code>--help</code> also prints available global flags:</p> <pre><code>Global flags:\n  -h, --help                   Print usage string.\n  -d, --debug                  Enables debug output. Intended for Rad script developers.\n      --rad-debug              Enables Rad debug output. Intended for Rad developers.\n      --color mode             Control output colorization. Valid values: [auto, always, never]. (default auto)\n  -q, --quiet                  Suppresses some output.\n      --shell                  Outputs shell/bash exports of variables, so they can be eval'd\n  -v, --version                Print rad version information.\n      --stdin script-name      Enables reading Rad from stdin, and takes a string arg to be treated as the 'script name'.\n      --confirm-shell          Confirm all shell commands before running them.\n      --src                    Instead of running the target script, just print it out.\n      --src-tree               Instead of running the target script, print out its syntax tree.\n      --mock-response string   Add mock response for json requests (pattern:filePath)\n</code></pre> <p>Note that, outside of <code>help</code>, all the global flags are ALL CAPS.</p>"},{"location":"guide/global-flags/#debug","title":"<code>debug</code>","text":"<p><code>debug</code> is an built-in function which behaves exactly like <code>print</code>, except that it only prints if the global flag <code>--debug</code> is enabled. You can use them in your script for debugging as desired.</p> <p>For example, given this example:</p> debug.rad<pre><code>print(\"1\")\ndebug(\"2\")\nprint(\"3\")\n</code></pre> <p>the following invocations will give the respective outputs:</p> <pre><code>rad debug.rad\n</code></pre> <pre><code>1\n3\n</code></pre> <pre><code>rad debug.rad -d\n</code></pre> <pre><code>1\nDEBUG: 2\n3\n</code></pre>"},{"location":"guide/global-flags/#quiet","title":"<code>quiet</code>","text":"<p>Use <code>--quiet</code> or <code>-q</code> to suppress some outputs, including print statements and errors. Some outputs still get printed e.g. shell command outputs.</p>"},{"location":"guide/global-flags/#color","title":"<code>color</code>","text":"<pre><code>--color mode\n    Control output colorization.\n    Valid values: [auto, always, never].\n    (default auto)\n</code></pre> <p>A lot of Rad's outputs have colors e.g. <code>pick</code> interaction or <code>pprint</code> JSON formatted output. By default (<code>auto</code>), Rad checks your terminal to detect if it's appropriate to enable colors or not. Things like piping or redirecting output will disable coloring.</p> <p>However, you can override the automatic detection by explicitly setting <code>--color=always</code> or <code>--color=never</code> to force having colors, or force not having colors, respectively. </p>"},{"location":"guide/global-flags/#mock-response","title":"<code>mock-response</code>","text":"<p>You might be writing a script which hits a JSON API and uses its output e.g. formatting it into a table using a <code>rad</code> block.</p> <p>In writing said script, you may wish to test it against certain responses that the live API isn't giving you at the moment, perhaps because the server is down. To accomplish this, you can use the <code>mock-response</code> flag.</p> <p><code>mock-response</code> takes an argument in a <code>&lt;url regex&gt;:&lt;file path&gt;</code> format. In other words, you can mock responses based on a regex match of the queried URL, and make them return the contents of a specified file.</p> <p>For example, if you wanted to mock a response from GitHub's API, you could define an example response in a file:</p> commits.json<pre><code>[\n  {\n    \"sha\": \"306f3a4ddb3b09747d61a5eab264c3d72fbbc36e\",\n    \"commit\": {\n      \"author\": {\n        \"name\": \"Alice Smith\",\n        \"date\": \"2025-01-11T04:15:06Z\"\n      }\n    }\n  },\n  {\n    \"sha\": \"2b642c482b32e4d87924839b2f5a9592670dee69\",\n    \"commit\": {\n      \"author\": {\n        \"name\": \"Charlie Johnson\",\n        \"date\": \"2025-01-10T12:21:03Z\"\n      }\n    }\n  }\n]\n</code></pre> <p>And then define it as the mock response with the following example invocation:</p> <pre><code>rad commits.rl --mock-response \"api.github.*:commits.json\"\n</code></pre> <p>Before executing the HTTP request, Rad checks for defined mock responses and if there's a regex match against the URL, it will short circuit, avoiding the HTTP request, and simply returning the contents of the mocked response.</p> <p>Match all URLs with .*</p> <p>It's common for scripts to perform just one API query, in which case the regex filter doesn't need to be specific. Instead, you can just write <code>.*</code> e.g. <code>.*:commits.json</code>.</p>"},{"location":"guide/global-flags/#summary","title":"Summary","text":"<ul> <li>Rad provides several global flags that can be used across all Rad scripts.</li> <li>Use <code>mock-response</code> to test your scripts.</li> </ul> <p>Script args can shadow global flags</p> <p>If a script defines an arg such as <code>debug</code>, conflicting with an existing global flag, then the script arg will shadow the global flag.</p> <p>This means that the global flag's functionality is effectively disabled for the script. It gets removed from the script's usage string, and the script itself defines the behavior of the flag.</p>"},{"location":"guide/global-flags/#next","title":"Next","text":"<p>Sometimes you may wish to run commands before your script ends, either normally or via an error, such as cleanups. Rad provides a way to do this that we will explore in the next section: Defer &amp; Errdefer.</p>"},{"location":"guide/rad-blocks/","title":"Rad Blocks","text":"<p>Working with JSON APIs is a common scripting task. You might need to query GitHub for repository info, check the status of your cloud services, or pull data from internal APIs. Typically, this involves making HTTP requests, parsing JSON responses, extracting the fields you care about, and formatting everything for display.</p> <p>Rad makes this entire workflow concise and declarative with rad blocks - a special syntax that lets you query JSON APIs and display results as formatted tables in just a few lines of code. Instead of writing imperative parsing logic, you declare what you want, and Rad handles the rest.</p>"},{"location":"guide/rad-blocks/#basic-example","title":"Basic Example","text":"<p>This concept will become clearer with an example.</p> <p>Below is a simple script capable of querying a given GitHub repo (leveraging GitHub's public API) for information about its latest commits.</p> File: commits<pre><code>args:\n    repo str        # The repo to query. Format: user/project\n    limit int = 20  # The max commits to return.\n\nurl = \"https://api.github.com/repos/{repo}/commits?per_page={limit}\"\n\nTime = json[].commit.author.date\nAuthor = json[].commit.author.name\nSHA = json[].sha\n\nrad url:\n    fields Time, Author, SHA\n</code></pre> <p>And running it looks something like this:</p> <pre><code>rad commits amterp/rad 5\n</code></pre> <pre><code>Querying url: https://api.github.com/repos/amterp/rad/commits?per_page=5\nTime                  Author          SHA\n2025-01-11T04:15:06Z  Alexander Terp  306f3a4ddb3b09747d61a5eab264c3d72fbbc36e\n2025-01-11T03:07:56Z  Alexander Terp  304a914644dfd73a59b85a191481f9c429b4d25e\n2025-01-11T01:00:42Z  Alexander Terp  7171ec92ae729f9d04e224e16272c9b888dffe41\n2025-01-10T12:11:08Z  Alexander Terp  4b64f585d08d9a5ee40549b6b9624530ac713eb1\n2025-01-09T11:34:51Z  Alexander Terp  abfcf2d940a18b819f7ae9e9040550a9644e5120\n</code></pre> <p>This is a simple example, but it demonstrates the ability to query GitHub's API (which returns JSON), extracting fields we're interested in (commits' time, author, and SHA).</p> <p>And that's with just a few lines of code! Let's break it down piece by piece.</p>"},{"location":"guide/rad-blocks/#arg-block","title":"Arg Block","text":"<pre><code>args:\n    repo str        # The repo to query. Format: user/project\n    limit int = 20  # The max commits to return.\n\nurl = \"https://api.github.com/repos/{repo}/commits?per_page={limit}\"\n</code></pre> <p>Here we have an args block where we declare a <code>repo</code> string and a <code>limit</code> int with a default of 20. After the args block, we create a <code>url</code> string using string interpolation to fill in the repo name, and the limit for how many commits we want GitHub to give us.</p>"},{"location":"guide/rad-blocks/#json-paths","title":"Json Paths","text":"<pre><code>Time = json[].commit.author.date\nAuthor = json[].commit.author.name\nSHA = json[].sha\n</code></pre> <p>This is where things get more interesting. The above definitions correspond to expected paths in the JSON response i.e. a series of keys to look up.</p> <p>In Rad nomenclature, we refer to these as json path definitions.</p> <p>If you query GitHub's API and take a look at the JSON response, you can see how these paths correspond to the data. Example URL if you want to see for yourself:</p> <p>https://api.github.com/repos/amterp/rad/commits?per_page=2</p> <p>Here's a simplified example response with two commits, showing the structure we're interested in:</p> <pre><code>[\n  {\n    \"sha\": \"306f3a4ddb3b09747d61a5eab264c3d72fbbc36e\",\n    \"commit\": {\n      \"author\": {\n        \"name\": \"Alexander Terp\",\n        \"date\": \"2025-01-11T04:15:06Z\"\n      }\n    }\n  },\n  {\n    \"sha\": \"2b642c482b32e4d87924839b2f5a9592670dee69\",\n    \"commit\": {\n      \"author\": {\n        \"name\": \"Alexander Terp\",\n        \"date\": \"2025-01-10T12:21:03Z\"\n      }\n    }\n  }\n]\n</code></pre> <p>You can see how the path for <code>Author = json[].commit.author.name</code> corresponds to a final value of \"Alexander Terp\".</p> <p>Json paths leverage a special syntax that Rad offers. They always start with <code>json</code>. <code>json</code> can be thought of as representing the JSON blob as a whole, or its root, if you want to think of the JSON data as a tree.</p> <p>The <code>[]</code> after <code>json</code> tells Rad that you expect the <code>json</code> blob to be a list, and to \"unwrap\" it and dig into individual items in that list for the remainder of the path. <code>commit</code> then tells it to look up a key of that name (literally <code>commit</code>), and to then look up <code>author</code> next, and then finally <code>name</code>.</p>"},{"location":"guide/rad-blocks/#basic-path-syntax-summary","title":"Basic Path Syntax Summary","text":"<p>The examples above demonstrate the core JSON path patterns you'll use most often:</p> <ul> <li>Dot notation: <code>json.field</code> or <code>json.commit.author.name</code> for nested fields</li> <li>Array unwrapping: <code>json[]</code> tells Rad to iterate through a list</li> <li>Combined: <code>json[].field.nested</code> extracts nested data from each array item</li> </ul> <p>Advanced JSON Path Features</p> <p>The JSON path syntax supports additional powerful features like wildcards (<code>json[].*</code>), indexed access (<code>json[0]</code>, <code>json.items[2]</code>), and multiple levels of array unwrapping (<code>json[].items[][].related[]</code>). We'll cover these in a later section: JSON Paths (Advanced).</p> <p>When a json path declaration is executed, its variable (<code>Author</code> for example) is initialized as an empty list. It's a \"special\" list though, as it has a json field definition tied to it, which can be used in a rad block, let's look at that one next.</p>"},{"location":"guide/rad-blocks/#rad-block","title":"Rad Block","text":"<pre><code>rad url:\n    fields Time, Author, SHA\n</code></pre> <p>Why 'rad'?</p> <p>The project name Rad comes from its original core use case: Request And Display. This workflow - querying data from APIs and displaying it in readable tables - is exactly what <code>rad</code> blocks are designed for. It's not just the project name, it's what the keyword does!</p> <p><code>rad</code> is a keyword that executes a \"Request And Display\" workflow.</p> <p>Following the <code>rad</code> keyword, we provide the <code>url</code> variable which will get used to execute an <code>HTTP GET</code> request. Then, inside the rad block itself, using the keyword <code>fields</code>, we specify the earlier json fields that we defined. Listing them here will tell the rad block to extract data from the resulting JSON blob according to the json field paths that you defined. The ordering in which the fields are listed also controls the ordering of columns in the ensuing table that gets printed.</p> <p>When run, this will print the table we saw earlier; here it is again for reference (with a limit of 3).</p> <pre><code>Time                  Author          SHA\n2025-01-11T04:15:06Z  Alexander Terp  306f3a4ddb3b09747d61a5eab264c3d72fbbc36e\n2025-01-11T03:07:56Z  Alexander Terp  304a914644dfd73a59b85a191481f9c429b4d25e\n2025-01-11T01:00:42Z  Alexander Terp  7171ec92ae729f9d04e224e16272c9b888dffe41\n</code></pre> <p>Note that the variable names we choose for the json field definitions become the header names in the table.</p>"},{"location":"guide/rad-blocks/#additional-rad-block-options","title":"Additional Rad Block Options","text":"<p>Rad blocks include options to control the resulting table.</p>"},{"location":"guide/rad-blocks/#sorting","title":"Sorting","text":"<p>By default, the rows in your table are sorted by their original order in the JSON blob. However, you can control this.</p> <p>Let's say we have the following table by default:</p> <pre><code>City         Country  Population\nLos Angeles  USA      3800000\nLondon       England  8800000\nHouston      USA      2300000\nCopenhagen   Denmark  640000\n</code></pre> <p>The simplest sorting option is alphabetically, across the whole row.</p> <pre><code>rad url:\n    fields City, Country, Population\n    sort\n</code></pre> <pre><code>City         Country  Population\nCopenhagen   Denmark  640000\nHouston      USA      2300000\nLondon       England  8800000\nLos Angeles  USA      3800000\n</code></pre> <p>What if we wanted to sort by Country, though? And then break ties with City? We can do that:</p> <pre><code>rad url:\n    fields City, Country, Population\n    sort Country, City\n</code></pre> <pre><code>City         Country  Population\nCopenhagen   Denmark  640000\nLondon       England  8800000\nHouston      USA      2300000\nLos Angeles  USA      3800000\n</code></pre> <p>If we wanted to sort by descending population, you can add <code>desc</code> after the name of the column:</p> <pre><code>rad url:\n    fields City, Country, Population\n    sort Population desc\n</code></pre> <pre><code>City         Country  Population\nLondon       England  8800000\nLos Angeles  USA      3800000\nHouston      USA      2300000\nCopenhagen   Denmark  640000\n</code></pre> <p>'asc' is the default</p> <p><code>sort City</code> and <code>sort City asc</code> are both valid and identical in functionality - you can include it if you want to be explicit.</p>"},{"location":"guide/rad-blocks/#mapping","title":"Mapping","text":"<p>You can also transform a column's values before it gets printed.</p> <p>For example, let's say you wanted the 'Population' column in the above example to be in millions, and to display one decimal place, you can do that with a <code>map</code> column modifier:</p> <pre><code>rad url:\n    fields City, Country, Population\n    Population:\n        map fn(p) \"{p/1e6:.1}\"\n</code></pre> <p>The syntax here is <code>map &lt;lambda&gt;</code>. In this example, the lambda is <code>fn(p) \"{p/1e6:.1}\"</code>.</p> <p>You can read about lambdas in an earlier section here: Functions: Lambdas.</p> <p>If we run this, you'll see the change:</p> <pre><code>City         Country  Population\nLos Angeles  USA      3.8\nLondon       England  8.8\nHouston      USA      2.3\nCopenhagen   Denmark  0.6\n</code></pre> <p>Let's break down this syntax more. After declaring the fields:</p> <pre><code>Population:\n    map fn(p) \"{p/1e6:.1}\"\n</code></pre> <p><code>Population:</code> begins a column modifier block. The identifier prior to the colon is expected to be one of the fields. Inside one of these blocks, you can apply modifiers on that column, such as <code>map</code> or <code>color</code>.</p> <p><code>map</code> is considered a keyword in the context of rad blocks. After <code>map</code>, a lambda expression is expected, which you can think of as a mini-function.</p> <p>In this case, we've written <code>fn(p) \"{p/1e6:.1}\"</code>. The lambda takes a variable <code>p</code> (name could be any valid identifier). This will represent an individual value in the <code>Population</code> list. The expression that follows is what will get evaluated and decide the final value in each cell. It is the output of your lambda mini-function. In this example, we turn it into a string, created using string interpolation.</p> <p>Inside the string interpolation expression, we first divide it by one million (<code>p/1e6</code>, using scientific notation), and then use formatting syntax (right of the colon) to specify that we want the resulting float to be stringified with one decimal place (<code>.1</code>).</p> <p>Modifier Execution Order</p> <p>Field modifiers execute in a specific order: filter \u2192 sort \u2192 map</p> <ul> <li>Filter first: Removes unwanted rows before sorting</li> <li>Sort middle: Sorts the filtered data in its original form</li> <li>Map last: Transforms values for display only</li> </ul> <p>This means sorting and filtering see the original extracted values, not the transformed display values from <code>map</code>.</p>"},{"location":"guide/rad-blocks/#lambda-context-parameter","title":"Lambda Context Parameter","text":"<p>When transforming columns with <code>map</code>, your lambda can optionally accept a second parameter to access context information about the transformation:</p> <pre><code>rad url:\n    fields City, Country, Population\n    Population:\n        map fn(p, ctx) \"{p / sum(ctx.src) * 100:.1}%\"\n</code></pre> <p>This shows each city's population as a percentage of the total.</p> <p>The context object provides three fields:</p> <ul> <li><code>ctx.idx</code> - The current row index (0-based)</li> <li><code>ctx.src</code> - An immutable snapshot of the full column data (as a list)</li> <li><code>ctx.field</code> - The name of the field being transformed (e.g., \"Population\")</li> </ul> <p>This is useful for operations that need to know about the overall dataset:</p> <pre><code>// Highlight the largest city\nCity:\n    map fn(city, ctx) ctx.idx == 0 ? \"{city} \u2605\" : city\n</code></pre> <p>The <code>field</code> property is especially helpful when applying the same transformation to multiple columns:</p> <pre><code>// Apply to multiple columns, with field-specific logic\ntimestamp, strategy, fund:\n    map fn(x, ctx):\n        if ctx.field == \"timestamp\":\n            return format_time(x)\n        return str(x)\n</code></pre> <p>Context is Optional</p> <p>Single-parameter lambdas continue to work exactly as before. The context parameter is completely optional:</p> <pre><code>Population:\n    map fn(p) p / 1e6  // No context needed\n</code></pre>"},{"location":"guide/rad-blocks/#filtering","title":"Filtering","text":"<p>You can also filter rows based on conditions. This is useful when you only want to display data that matches certain criteria.</p> <p>For example, let's say you're querying an API that returns users, but you only want to see active users over 18 years old:</p> <pre><code>rad url:\n    fields Name, Age, Status\n    Age:\n        filter fn(age) age &gt;= 18\n    Status:\n        filter fn(s) s == \"active\"\n</code></pre> <p>The syntax is <code>filter &lt;function&gt;</code>. The function receives each value from that column and returns a boolean (or truthy value). If it returns true, that row is kept. If false, the entire row is discarded.</p> <p>In this example, we're applying two filters:</p> <ul> <li><code>Age</code>: Keep only rows where age is 18 or greater</li> <li><code>Status</code>: Keep only rows where status equals \"active\"</li> </ul> <p>When multiple fields have filters, a row must pass all filters to be displayed (AND logic). In our example, both the age and status filters must pass.</p> <p>Let's see this in action with some mock data:</p> <pre><code>Ages = [25, 15, 30, 20, 12]\nNames = [\"Alice\", \"Bob\", \"Charlie\", \"Diana\", \"Eve\"]\nStatus = [\"active\", \"active\", \"inactive\", \"active\", \"active\"]\n\ndisplay:\n    fields Names, Ages, Status\n    Ages:\n        filter fn(a) a &gt;= 18\n    Status:\n        filter fn(s) s == \"active\"\n</code></pre> <pre><code>Names   Ages  Status\nAlice   25    active\nDiana   20    active\n</code></pre> <p>Notice that Charlie doesn't appear (age &gt;= 18 but status is inactive), Bob doesn't appear (active but age &lt; 18), and Eve doesn't appear (active but age &lt; 18).</p> <p>Like with sorting and mapping, the filter predicate can be a lambda expression or a function reference:</p> <pre><code>display:\n    fields Name, Age\n    Age:\n        filter is_adult\n\nfn is_adult(age):\n    return age &gt;= 18\n</code></pre> <p>Just like <code>map</code>, filter lambdas can accept an optional context parameter with <code>idx</code>, <code>src</code>, and <code>field</code>:</p> <pre><code>// Keep only even-indexed rows\nNames:\n    filter fn(n, ctx) ctx.idx % 2 == 0\n\n// Keep values below the column average\nAge:\n    filter fn(age, ctx) age &lt; sum(ctx.src) / ctx.src.len()\n</code></pre> <p>Execution Order: filter \u2192 sort \u2192 map</p> <p>Filtering happens before sorting and mapping. This means: - Filters see the original extracted values (not transformed by <code>map</code>) - Sorting operates on already-filtered data - Mapping transforms the final filtered+sorted values for display</p> <p>This order ensures your filters work on raw data and your sorts only process rows that will actually be displayed.</p>"},{"location":"guide/rad-blocks/#color","title":"Color","text":"<p>Another column modifier uses the keyword <code>color</code>. You can tell Rad to color a cell's value depending on its contents by using a regex.</p> <p>For example:</p> <pre><code>rad url:\n    fields City, Country, Population\n    Country:\n        color \"pink\" \".*\"\n        color \"red\" \"Denmark\"\n        color \"blue\" \"USA\"\n</code></pre> <p>The syntax is <code>color &lt;color&gt; &lt;regex&gt;</code>. You can apply multiple rules, and later rules override earlier ones.  For example, here we start off by coloring everything pink. Then, we add three more rules: any sequence \"Denmark\" should be colored red, and \"USA\" should be colored blue.</p> <p></p> <p>This screenshot from a terminal demonstrates the colors. England is colored pink because the initial <code>.*</code> rule is the only regex that matched it.</p> <p>Note that the specific colors that appear varies between terminals and user settings.</p> <p>Valid colors: <code>plain</code>, <code>black</code>, <code>red</code>, <code>green</code>, <code>yellow</code>, <code>blue</code>, <code>magenta</code>, <code>cyan</code>, <code>white</code>, <code>orange</code>, <code>pink</code>.</p>"},{"location":"guide/rad-blocks/#multi-column-modifiers","title":"Multi-Column Modifiers","text":"<p>You can apply the same modifiers to multiple columns at once by listing them together:</p> <pre><code>rad url:\n    fields Status, Priority, Assignee, DueDate\n    Status, Priority:\n        color \"green\" \"complete|high\"\n        color \"red\" \"blocked|low\"\n    Status, Priority, Assignee:\n        map fn(s) upper(s)\n</code></pre> <p>This example applies color rules to both <code>Status</code> and <code>Priority</code>, then transforms three columns to uppercase with a single <code>map</code> block. This is much more concise than writing separate modifier blocks for each column.</p> <p>Any column modifier (<code>filter</code>, <code>map</code>, <code>color</code>) can be applied to multiple columns this way.</p>"},{"location":"guide/rad-blocks/#if-statements","title":"If Statements","text":"<p>Rad blocks can contain if statements, so if you want slightly different behavior for your rad block based on some condition, you don't need to copy and paste the whole block into two separate if blocks.</p> <p>Let's say your script had a flag for sorting by population or not. Here's an example of how that could look:</p> <pre><code>args:\n    sort_by_population p bool  # Enable to sort by population.\n\n// ... some script stuff here\n\nrad url:\n    fields City, Country, Population\n    if sort_by_population:\n        sort Population desc\n    else:\n        sort\n</code></pre> <p>If the flag is enabled, we sort by descending population, otherwise we sort rows alphabetically.</p> <p>You can put any rad block statements into these if blocks, including <code>fields</code>, column modifiers, etc.</p>"},{"location":"guide/rad-blocks/#other-block-types","title":"Other Block Types","text":"<p>So far we've seen the <code>rad</code> block, which performs an HTTP request, extracts data, and displays it as a table. Rad also offers two variants that give you more control over this workflow: request blocks and display blocks.</p>"},{"location":"guide/rad-blocks/#request-no-display","title":"request: No Display","text":"<p>A request block is like a <code>rad</code> block, but it doesn't print a table. It performs the HTTP request and extracts fields into lists, then stops. This is useful when you want to process the data further before displaying it, or use it for something other than display.</p> <pre><code>request url:\n    fields City, Country, Population\n    sort Population desc\n\n// From here, the field lists are populated and sorted\n// City[0] is now the city with the largest population\nlargest_city = City[0]\nprint(\"The largest city is {largest_city}\")\n</code></pre> <p>Note that <code>filter</code>, <code>sort</code>, and <code>map</code> all work in request blocks since they modify the underlying data. However, <code>color</code> is display-only and has no effect since nothing gets displayed.</p>"},{"location":"guide/rad-blocks/#display-no-request","title":"display: No Request","text":"<p>A display block takes already-populated data and formats it as a table. It's the opposite of request blocks - no HTTP request is made, just formatting and display.</p> <p>Display with manual data:</p> <pre><code>Nums = [1, 2]\nWords = [\"hi\", \"hello\"]\ndisplay:\n    fields Nums, Words\n</code></pre> <pre><code>Nums  Words\n1     hi\n2     hello\n</code></pre> <p>Display with a data source:</p> <p>Display blocks can also take a variable containing JSON data (like the response from <code>http_get</code>). This is particularly useful when you need custom headers or authentication:</p> <pre><code>// Fetch data with custom headers\nresp = http_get(url, headers=my_headers)\n\n// Define JSON paths\nName = json[].name\nAge = json[].age\n\n// Display the data\ndisplay resp.body:\n    fields Name, Age\n    sort Age desc\n</code></pre>"},{"location":"guide/rad-blocks/#when-to-use-each","title":"When to Use Each","text":"<ul> <li><code>rad</code>: When you want to query and display in one step (most common case)</li> <li><code>request</code>: When you need to process data before displaying or use it for non-display purposes</li> <li><code>display</code>: When you have data from manual sources, <code>http_get()</code> with custom headers, or derived from <code>request</code> blocks</li> </ul> <p>Modifier Mutation Across Block Types</p> <p>Field modifiers like (<code>filter</code>, <code>sort</code>, <code>map</code>) may or may not mutate underlying data depending on the block type:</p> <ul> <li>In <code>rad</code> and <code>request</code> blocks: Permanently modify the field arrays</li> <li>In <code>display</code> blocks: Applied for rendering, but does not change underlying data.</li> </ul> <p>This means you can use <code>request</code> blocks to filter, sort, or transform data for further processing, while <code>display</code> blocks let you format data for viewing without altering the original values.</p>"},{"location":"guide/rad-blocks/#understanding-http-requests","title":"Understanding HTTP Requests","text":"<p>When you write <code>rad</code> or <code>request</code> blocks, Rad automatically performs an HTTP GET request to the URL and expects a JSON response. This happens behind the scenes - you don't need to explicitly call any HTTP functions.</p>"},{"location":"guide/rad-blocks/#headers-and-authentication","title":"Headers and Authentication","text":"<p>Currently, <code>rad</code> and <code>request</code> blocks don't support custom headers or authentication directly. If you need to add headers (for example, to authenticate with an API), use the <code>http_get</code> or <code>http_post</code> functions first, then pass the result to a <code>display</code> block:</p> <pre><code>args:\n    token str  # API authentication token\n\nheaders = {\n    \"Authorization\": \"Bearer {token}\",\n    \"Accept\": \"application/json\"\n}\n\nurl = \"https://api.github.com/user/repos\"\nresp = http_get(url, headers=headers)\n\n// Define JSON paths for the response\nName = json[].name\nStars = json[].stargazers_count\n\n// Display the data we fetched\ndisplay resp.body:\n    fields Name, Stars\n    sort Stars desc\n</code></pre> <p>This pattern gives you full control over the HTTP request while still leveraging rad blocks for data extraction and display.</p>"},{"location":"guide/rad-blocks/#summary","title":"Summary","text":"<ul> <li>Rad blocks make working with JSON APIs concise and declarative - request, extract, and display data in just a few lines</li> <li>Three block types serve different needs:<ul> <li><code>rad url:</code> - Request and display in one step</li> <li><code>request url:</code> - Request and extract data without displaying</li> <li><code>display:</code> - Display already-populated data as a table</li> </ul> </li> <li>JSON field definitions use special path syntax to extract data from JSON responses<ul> <li>Basic patterns: <code>json.field</code>, <code>json[]</code>, <code>json[].nested.path</code></li> <li>Advanced features exist (wildcards, indexing) for complex extraction needs</li> </ul> </li> <li>Table customization options:<ul> <li>Filtering: Remove rows based on conditions</li> <li>Sorting: <code>sort</code>, <code>sort Field</code>, <code>sort Field desc</code></li> <li>Transforming: Map functions to modify column values</li> <li>Styling: Color cells based on regex patterns</li> <li>Multi-column: Apply same modifiers to multiple columns at once</li> <li>Conditional: Use <code>if</code> statements for dynamic behavior</li> <li>Execution order: filter \u2192 sort \u2192 map</li> </ul> </li> <li>HTTP control: rad blocks perform GET automatically; use <code>http_get()</code>/<code>http_post()</code> with <code>display</code> for more advanced queries (e.g. requiring headers/auth)</li> </ul>"},{"location":"guide/rad-blocks/#next","title":"Next","text":"<p>Next, we'll cover an important concept for keeping your scripts maintainable: Type Annotations.</p>"},{"location":"guide/resources/","title":"Resources","text":"<p>Depending on your script, you may wish to look up values at some point, such as URL endpoints depending on your input. Rad offers a function for this, <code>pick_from_resource</code>, but before we dive into it, we'll first cover a couple of related functions.</p>"},{"location":"guide/resources/#pick","title":"<code>pick</code>","text":"<p><code>pick</code> is an in-built function which allows you to choose one value from a list of inputs, using some filter. If the filter has several matches, Rad will enter an interactive mode which allows the user to pick a single value to continue with.</p> <p>You can try it yourself with this example:</p> <pre><code>options = [\"chicken burger\", \"chicken sandwich\", \"ham sandwich\"]\noutput = pick(options, \"sandwich\")\nprint(\"You chose: {output}\")\n</code></pre> <p>When you initially run this, the <code>sandwich</code> filter should exclude <code>chicken burger</code> and ask you to select between two remaining options.</p> <p>Note: You can enable exact match priority with <code>prefer_exact=true</code>. When enabled, if your filter exactly matches one of the options (case-insensitive), that option will be selected immediately without entering interactive mode. For example, <code>pick([\"r\", \"red\", \"rose\"], \"r\", prefer_exact=true)</code> would immediately select \"r\" without prompting.</p> <pre><code>\u2503 Pick an option\n\u2503 &gt; chicken sandwich\n\u2503   ham sandwich\n</code></pre> <p>After you choose, you get the final output:</p> <pre><code>You chose: chicken sandwich\n</code></pre>"},{"location":"guide/resources/#pick_kv","title":"<code>pick_kv</code>","text":"<p>A similar function is <code>pick_kv</code>. However, instead of the values you're filtering and picking between also being the output, <code>pick_kv</code> performs the filtering/picking on a list of keys, each which map to a value that will get output from the function if its associated key is picked. For example:</p> <pre><code>keys = [\"chicken burger\", \"chicken sandwich\", \"ham sandwich\"]\nvalues = [\"CHICKEN\", \"CHICKEN\", \"HAM\"]\n\noutput = pick_kv(keys, values)\n\nprint(\"We'll need {output}!\")\n</code></pre> <p>In this example, we leave out the filter, as it's optional, which will launch us into an interactive select between all the key values:</p> <pre><code>\u2503 Pick an option\n\u2503   chicken burger\n\u2503   chicken sandwich\n\u2503 &gt; ham sandwich\n</code></pre> <p>If we pick this third option, this is the final output of the script:</p> <pre><code>We'll need HAM!\n</code></pre> <p>Notice that the function did not output the key <code>ham sandwich</code> that was selected, but instead the value <code>HAM</code> that it mapped to.</p>"},{"location":"guide/resources/#pick_from_resource","title":"<code>pick_from_resource</code>","text":"<p>Now we'll look at actually using what this section is about - resources. <code>pick_from_resource</code> allows you to pre-define a resource file (using JSON) which contains a range of key-value pairs. When invoked, it will behave similarly to the two previous <code>pick</code> functions i.e. it lets you apply an optional filter, and will launch into an interactive picking mode to narrow down a single choice, if needed. Unlike <code>pick</code> and <code>pick_kv</code>, <code>pick_from_resource</code> has <code>prefer_exact=true</code> by default\u2014if your filter exactly matches one of the keys (case-insensitive), that option will be selected immediately.</p> <p>Let's do a simple example. As mentioned, a resource file is simply a JSON file. We'll create an example where we look up a url based on user input:</p> websites.json<pre><code>{\n  \"options\": [\n    {\n      \"keys\": [\"gl\", \"lab\"],\n      \"values\": [\"gitlab.com\", \"GitLab\"]\n    },\n    {\n      \"keys\": [\"gh\", \"hub\"],\n      \"values\": [\"github.com\", \"GitHub\"]\n    }\n  ]\n}\n</code></pre> <p>You may see some similarity here to what we did with <code>pick_kv</code>. We're defining two options: one which can get matched by either <code>gl</code> or <code>lab</code>, and one which gets matched by <code>gh</code> or <code>hub</code>. In the first case, if chosen, <code>pick_from_resource</code> will return two values: <code>gitlab.com</code> and <code>GitLab</code>. Similarly it will return <code>github.com</code> and <code>GitHub</code> for the latter.</p> <p>Let's create a Rad script to use this resource:</p> example.rad<pre><code>args:\n    website str = \"\"\n\nurl, name = pick_from_resource(\"./resources/websites.json\", website)\nprint(\"url: {url}, name: {name}\")\n</code></pre> <p>Note that the first argument to <code>pick_from_resource</code> is a path to a resource file. This path is relative to the script's path. This allows you to store your resources with your scripts. In this example, we'll place our files like so:</p> <pre><code>.\n\u251c\u2500\u2500 example.rad\n\u2514\u2500\u2500 resources\n    \u2514\u2500\u2500 websites.json\n</code></pre> <p>This means that it doesn't matter where on your computer you invoke your script from including if it's on your PATH - the script will consistently look in the same spot for resource files.</p> <p>TBC</p>"},{"location":"guide/resources/#summary","title":"Summary","text":"<ul> <li><code>pick</code> and <code>pick_kv</code> are built-in functions that allow users to select one option from many, allowing for an optional filter.</li> <li><code>pick_from_resource</code> is similar, but uses a pre-defined resource file to define the options.</li> <li>The resource file is defined in JSON.</li> <li>The resource file path can be defined relative to the script's path.</li> </ul>"},{"location":"guide/resources/#next","title":"Next","text":"<p>The shell offers a ton of useful utilities, and Rad allows you to leverage them from within your scripts.</p> <p>We'll look at that in the next section: Shell Commands.</p>"},{"location":"guide/script-commands/","title":"Script Commands","text":"<p>When you think of powerful CLI tools - <code>git</code>, <code>docker</code>, <code>kubectl</code> - they all share a common pattern: they're organized around commands. You don't just run <code>git</code> with flags; you run <code>git commit</code>, <code>git push</code>, <code>git branch</code> - each a distinct operation with its own arguments.</p> <p>Rad lets you build tools like this through first-class command support. You can define multiple commands in a single script, each with their own arguments and implementation.</p>"},{"location":"guide/script-commands/#basic-syntax","title":"Basic Syntax","text":"<p>Let's start with a very simple example:</p> <pre><code>#!/usr/bin/env rad\n\ncommand greet:\n    name str\n    calls greet_user\n\nfn greet_user():\n    print(\"Hello, {name}!\")\n</code></pre> <p>This script defines a single command called <code>greet</code> that takes a <code>name</code> argument.</p> <p>Invoke it by specifying the command name followed by its arguments:</p> <pre><code>&gt; ./script.rad greet Alice\n</code></pre> <pre><code>Hello, Alice!\n</code></pre> <p>Let's break down the syntax:</p> <ol> <li><code>command greet:</code> - Defines a command named <code>greet</code></li> <li><code>name str</code> - The command takes one required string argument called <code>name</code></li> <li><code>calls greet_user</code> - Specifies which function to execute when this command runs</li> <li><code>fn greet_user():</code> - Defines the function that implements the command logic (defined after commands)</li> </ol> <p>Command arguments (like <code>name</code>) become script-wide variables, accessible throughout your script.</p> <p>Underscores become hyphens</p> <p>Command names with underscores are automatically converted to hyphens for CLI invocation. This matches standard CLI conventions (like <code>kubectl</code>, <code>docker-compose</code>).</p> <p>For example, <code>command deploy_staging:</code> is invoked as <code>deploy-staging</code>:</p> <pre><code>&gt; ./script.rad deploy-staging\n</code></pre> <p>This is the same convention used for argument names.</p>"},{"location":"guide/script-commands/#multiple-commands","title":"Multiple Commands","text":"<p>The power of commands emerges when you define several in one script. Let's create a simple deployment tool:</p> <pre><code>#!/usr/bin/env rad\n\ncommand deploy:\n    env str\n    calls do_deploy\n\ncommand status:\n    env str\n    calls do_status\n\nfn do_deploy():\n    print(\"Deploying to {env}...\".yellow())\n    print(\"Deployment complete!\".green())\n\nfn do_status():\n    print(\"Checking status of {env}...\".yellow())\n    print(\"Environment {env} is healthy\".green())\n</code></pre> <p>Now you can invoke either command:</p> <pre><code>&gt; ./tool.rad deploy staging\n</code></pre> <pre><code>Deploying to staging...\nDeployment complete!\n</code></pre> <pre><code>&gt; ./tool.rad status production\n</code></pre> <pre><code>Checking status of production...\nEnvironment production is healthy\n</code></pre> <p>Each command has its own arguments and implementation, but they live in the same script and can share code.</p>"},{"location":"guide/script-commands/#adding-descriptions","title":"Adding Descriptions","text":"<p>Commands should include descriptions to make your tool self-documenting. Use the familiar <code>--- ... ---</code> header syntax:</p> <pre><code>#!/usr/bin/env rad\n\ncommand deploy:\n    ---\n    Deploy the application to an environment\n    ---\n    env str\n    calls do_deploy\n\ncommand status:\n    ---\n    Check the health of an environment\n    ---\n    env str\n    calls do_status\n\nfn do_deploy():\n    print(\"Deploying to {env}...\".yellow())\n\nfn do_status():\n    print(\"Environment {env} is healthy\".green())\n</code></pre> <p>These descriptions appear in the help output:</p> <pre><code>&gt; ./tool.rad -h\n</code></pre> <pre><code>Usage:\n  tool.rad [command] [OPTIONS]\n\nCommands:\n  deploy    Deploy the application to an environment\n  status    Check the health of an environment\n</code></pre> <p>Notice how Rad automatically generates a usage string listing all available commands.</p> <p>Multi-line descriptions</p> <p>Just like script headers, command descriptions can span multiple lines:</p> <pre><code>command deploy:\n    ---\n    Deploy the application to an environment.\n    This will build, test, and deploy your application.\n    ---\n</code></pre> <p>Important: The first line appears in the script's overall help output, so keep it concise. Additional lines only appear when you request help for that specific command (<code>./tool.rad deploy -h</code>).</p>"},{"location":"guide/script-commands/#command-arguments","title":"Command Arguments","text":"<p>Each command can define its own arguments using the same syntax you learned in Args. Let's expand our deployment tool:</p> <pre><code>#!/usr/bin/env rad\n\ncommand deploy:\n    ---\n    Deploy the application to an environment\n    ---\n    env str              # Environment to deploy to\n    branch str = \"main\"  # Branch to deploy from\n    skip_tests bool      # Skip running tests before deploy\n    calls do_deploy\n\nfn do_deploy():\n    if skip_tests:\n        print(\"\u26a0\ufe0f  Skipping tests\".yellow())\n    else:\n        print(\"Running tests...\".yellow())\n\n    print(\"Deploying {branch} to {env}...\".yellow())\n    print(\"\u2705 Deployment complete!\".green())\n</code></pre> <p>The arguments work exactly as they do in the <code>args:</code> block - you can use defaults, optional types, constraints, and comments for help text.</p> <p>Invoke with positional arguments:</p> <pre><code>&gt; ./tool.rad deploy staging feature-branch\n</code></pre> <pre><code>Running tests...\nDeploying feature-branch to staging...\n\u2705 Deployment complete!\n</code></pre> <p>Or use flags (especially for booleans):</p> <pre><code>&gt; ./tool.rad deploy --env=production --skip-tests\n</code></pre> <pre><code>\u26a0\ufe0f  Skipping tests\nDeploying main to production...\n\u2705 Deployment complete!\n</code></pre>"},{"location":"guide/script-commands/#shared-args","title":"Shared Args","text":"<p>Often you want arguments that apply to all commands - like a <code>--verbose</code> flag or a <code>--config</code> path. Define these in an <code>args:</code> block to share them across commands:</p> <pre><code>#!/usr/bin/env rad\n\nargs:\n    verbose v bool   # Enable verbose output\n    config str = \"~/.config/tool.yaml\"\n\ncommand deploy:\n    ---\n    Deploy the application\n    ---\n    env str\n    calls do_deploy\n\ncommand status:\n    ---\n    Check environment status\n    ---\n    env str\n    calls do_status\n\nfn do_deploy():\n    if verbose:\n        print(\"Config: {config}\".yellow())\n        print(\"Deploying to {env}...\".yellow())\n    print(\"\u2705 Deployed!\".green())\n\nfn do_status():\n    if verbose:\n        print(\"Config: {config}\".yellow())\n        print(\"Checking {env}...\".yellow())\n    print(\"Environment healthy\".green())\n</code></pre> <p>Shared args are available to all commands:</p> <pre><code>&gt; ./tool.rad deploy staging --verbose\n</code></pre> <pre><code>Config: ~/.config/tool.yaml\nDeploying to staging...\n\u2705 Deployed!\n</code></pre> <pre><code>&gt; ./tool.rad status production --verbose\n</code></pre> <pre><code>Config: ~/.config/tool.yaml\nChecking production...\nEnvironment healthy\n</code></pre> <p>Shared args are flag-only</p> <p>When commands exist, shared args can only be passed as flags (like <code>--verbose</code>, <code>-v</code>, or <code>--config=value</code>), not positionally. This keeps the invocation clear: the first positional argument is always the command name.</p> <p>Both long form (<code>--verbose</code>) and short form (<code>-v</code>) work for shared args.</p> <p>Command-specific args can be positional or flags, just like regular script args.</p>"},{"location":"guide/script-commands/#command-callbacks","title":"Command Callbacks","text":"<p>We've been using function references (<code>calls on_deploy</code>), which is the recommended approach for most commands. However, for very short implementations, you can also use inline lambdas:</p> <pre><code>#!/usr/bin/env rad\n\ncommand deploy:\n    ---\n    Deploy the application\n    ---\n    env str\n    calls on_deploy\n\ncommand rollback:\n    ---\n    Rollback a deployment\n    ---\n    env str\n    calls fn():\n        print(\"Rolling back {env}...\".yellow())\n        print(\"\u2705 Rollback complete!\".green())\n\nfn on_deploy():\n    print(\"Deploying to {env}...\".yellow())\n    print(\"\u2705 Done!\".green())\n</code></pre>"},{"location":"guide/script-commands/#shared-logic","title":"Shared Logic","text":"<p>You can write code after all command blocks that runs before any callback is invoked. This is useful for setup logic that all commands need:</p> <pre><code>#!/usr/bin/env rad\n\ncommand deploy:\n    env str\n    calls on_deploy\n\ncommand rollback:\n    env str\n    calls on_rollback\n\n// This runs before any callback\nprint(\"Initializing...\".yellow())\nconfig = read_file(\"config.yaml\")\nprint(\"Config loaded\".green())\n\nfn on_deploy():\n    // config is available here\n    print(\"Deploying to {env} using config...\")\n\nfn on_rollback():\n    // config is available here too\n    print(\"Rolling back {env}...\")\n</code></pre> <p>When you run <code>./script.rad deploy staging</code>, the flow is:</p> <ol> <li>Parse arguments</li> <li>Run shared logic (lines 12-14)</li> <li>Run the callback (<code>on_deploy</code>)</li> </ol> <p>This pattern is useful for loading configuration files, setting up connections, or validating preconditions that apply to all commands.</p>"},{"location":"guide/script-commands/#getting-help","title":"Getting Help","text":"<p>Rad automatically generates help documentation for your commands. There are two levels of help:</p> <p>Script-level help shows all available commands:</p> <pre><code>&gt; ./tool.rad -h\n</code></pre> <pre><code>Usage:\n  tool.rad [command] [OPTIONS]\n\nCommands:\n  deploy      Deploy the application\n  rollback    Rollback a deployment\n  status      Check environment status\n</code></pre> <p>Command-level help shows arguments for a specific command:</p> <pre><code>&gt; ./tool.rad deploy -h\n</code></pre> <pre><code>Deploy the application\n\nUsage:\n  deploy &lt;env&gt; [branch] [OPTIONS]\n\nCommand args:\n      --env str       Environment to deploy to\n      --branch str    Branch to deploy from (default \"main\")\n      --skip-tests    Skip running tests before deploy\n  -v, --verbose       Enable verbose output\n      --config str    (default \"~/.config/tool.yaml\")\n</code></pre> <p>Notice how the help includes:</p> <ul> <li>The command description</li> <li>Required and optional arguments</li> <li>Default values</li> <li>Shared args (like <code>--verbose</code> and <code>--config</code>)</li> <li>Help text from <code>#</code> comments</li> </ul>"},{"location":"guide/script-commands/#practical-example","title":"Practical Example","text":"<p>Here's a concise, realistic example that demonstrates the \"dev script\" pattern - a common use case for replacing messy <code>Makefile</code>s or complex <code>package.json</code> script sections with a single, readable CLI entry point.</p>"},{"location":"guide/script-commands/#dev-script","title":"Dev Script","text":"<p>Instead of remembering different commands for building, testing, and running your project, you can wrap them in a single <code>dev.rad</code> script. This demonstrates shared arguments, boolean flags, and how to pass arguments down to underlying tools:</p> <pre><code>#!/usr/bin/env rad\n---\nFacilitates working with this repo's project.\n---\n\nargs:\n    verbose v bool   # Enable verbose output\n\ncommand start:\n    ---\n    Start the local development server\n    ---\n    port int = 3000    # Port to listen on\n    detach d bool      # Run in background\n    calls on_start\n\ncommand test:\n    ---\n    Run the test suite\n    ---\n    grep str?      # Filter tests by name\n    watch w bool   # Re-run on file changes\n    calls on_test\n\ncommand build:\n    ---\n    Compile for production\n    ---\n    calls on_build\n\n// Shared setup logic runs before any callback\nif verbose:\n    print(\"Checking project structure...\".yellow())\n\nif not path_exists(\"package.json\"):\n    print_err(\"Error: package.json not found\".red())\n    print_err(\"Run this script from the project root\".yellow())\n    exit(1)\n\nfn on_start():\n    print(\"\ud83d\ude80 Starting server on http://localhost:{port}...\")\n\n    cmd = \"npm start -- --port {port}\"\n\n    if detach:\n        $`{cmd} &amp;`\n        print(\"Server started in background\".green())\n    else:\n        $`{cmd}`\n\nfn on_test():\n    opts = \"\"\n    if watch:\n        opts = \"{opts} --watch\"\n    if grep: \n        opts = \"{opts} -t '{grep}'\"\n\n    if verbose:\n        print(\"Running: pytest {opts}\".yellow())\n\n    print(\"\ud83e\uddea Running tests...\")\n    $`pytest {opts}` catch:\n        print_err(\"Tests failed!\".red())\n        exit(1)\n\nfn on_build():\n    print(\"\ud83d\udce6 Building for production...\".yellow())\n\n    $`rm -rf ./dist`\n    $`npm run build` catch:\n        print_err(\"Build failed\".red())\n        exit(1)\n\n    print(\"\u2705 Build complete in ./dist\".green())\n</code></pre> <p>Usage:</p> <pre><code>&gt; ./dev.rad start\n\ud83d\ude80 Starting server on http://localhost:3000...\n\n&gt; ./dev.rad start --port 8080 --detach\n\ud83d\ude80 Starting server on http://localhost:8080...\nServer started in background\n\n&gt; ./dev.rad test --grep \"login_flow\" --watch\n\ud83e\uddea Running tests...\n\n&gt; ./dev.rad build\n\ud83d\udce6 Building for production...\n\u2705 Build complete in ./dist\n</code></pre> <p>Notice how this example uses:</p> <ul> <li>Shared args (<code>--verbose</code>) available to all commands</li> <li>Command-specific arguments with defaults (<code>port</code>, <code>detach</code>, <code>grep</code>, <code>watch</code>)</li> <li>Shared logic that runs before any callback</li> <li>Function references for callbacks (<code>calls on_start</code>, etc.)</li> <li>Integration with shell commands to wrap existing tools</li> <li>Clear, self-documenting help text</li> </ul>"},{"location":"guide/script-commands/#summary","title":"Summary","text":"<ul> <li>Script commands partition scripts into operations using <code>command name:</code> blocks</li> <li>Each command has:<ul> <li>Its own arguments (using standard <code>args</code> syntax)</li> <li>A description block (<code>--- ... ---</code>)</li> <li>A callback implementation (function reference or inline lambda)</li> </ul> </li> <li>Shared args (from <code>args:</code> block) are available to all commands<ul> <li>Must be passed as flags when commands exist</li> </ul> </li> <li>Shared logic runs before any callback. Write code after command blocks for setup that all commands need.</li> <li>Help is automatic:<ul> <li><code>./script -h</code> lists available commands</li> <li><code>./script command -h</code> shows command-specific help</li> </ul> </li> <li>Callbacks:<ul> <li>Function references: <code>calls function_name</code> (recommended)</li> <li>Inline lambdas: <code>calls fn():</code> (for short implementations)</li> </ul> </li> <li>Use script commands to build CLI tools, not just scripts</li> </ul>"},{"location":"guide/script-commands/#next","title":"Next","text":"<p>Rad provides a powerful system for looking up values from predefined resource files, which is particularly useful for building interactive tools.</p> <p>We'll explore this in the next section: Resources.</p>"},{"location":"guide/shell-commands/","title":"Shell Commands","text":"<p>The shell offers a wide range of utilities and is essential for CLI scripting - from file operations to invoking installed programs like git, make, or docker.</p> <p>Rad has rich built-in functionality (<code>http_get</code>, <code>read_file</code>, <code>write_file</code>, etc.), but sometimes you need to invoke system tools or installed programs. Rad makes this safe and ergonomic through first-class shell command support.</p>"},{"location":"guide/shell-commands/#invoking-commands","title":"Invoking Commands","text":"<p>Shell commands are invoked by prefixing a string with <code>$</code>:</p> <pre><code>$`ls -la`\n</code></pre> <p>You can also pre-define the command as a string variable:</p> <pre><code>cmd = `ls -la`\n$cmd\n</code></pre> <p>By default, the stdout/stderr will be printed directly to the user's terminal as if they had invoked it directly themselves.</p> <p>Prefer backticks for shell command strings</p> <p>Shell commands often use 'single' and \"double\" quotes, so backticks minimize delimiter conflicts. However, you can use any string delimiter.</p>"},{"location":"guide/shell-commands/#capturing-output","title":"Capturing Output","text":"<p>Shell commands return three values: exit code, stdout, and stderr. You can capture anywhere from zero to all three of these values, depending on what you need.</p>"},{"location":"guide/shell-commands/#capture-modes","title":"Capture Modes","text":"<p>There are four levels of capture:</p> <p>1. No capture - output goes to terminal</p> <p>When you don't assign any variables, all output goes to the terminal:</p> <pre><code>$`ls -la`\n</code></pre> <p>2. Capture exit code only</p> <p>Assign to one variable to capture just the exit code:</p> <pre><code>code = $`make test`\n</code></pre> <p>The exit code is captured as an <code>int</code>, but stdout and stderr still go to the terminal.</p> <p>3. Capture exit code + stdout</p> <p>Assign to two variables to capture the exit code and stdout:</p> <pre><code>code, stdout = $`git show 0dd21e6`\n</code></pre> <p>The exit code and stdout are captured as an <code>int</code> and <code>str</code> respectively. Stderr still goes to the terminal. Important: When you capture stdout, it doesn't print to the terminal - it's redirected to your variable.</p> <p>4. Capture all three</p> <p>Assign to three variables to capture everything:</p> <pre><code>code, stdout, stderr = $`npm install`\n</code></pre> <p>All three values are captured. Nothing is printed to the terminal automatically.</p>"},{"location":"guide/shell-commands/#named-assignment","title":"Named Assignment","text":"<p>Rad supports a special form of assignment when working with shell commands. When all your variables are named exactly <code>code</code>, <code>stdout</code>, or <code>stderr</code>, then assignment happens by name rather than by position. This means the order doesn't matter:</p> <pre><code>// Named assignment - order independent\nstdout, code = $`echo hi`           // code=0, stdout=\"hi\\n\"\nstderr = $`bad-command`             // Just capture stderr\ncode, stderr = $`make format`       // code=1, stderr=\"\"\nstderr, stdout, code = $`ls`        // All three, any order\n</code></pre> <p>This improves readability - you can capture exactly what you need with clear, self-documenting variable names.</p> <p>The rule: If ALL variables use exactly <code>code</code>, <code>stdout</code>, or <code>stderr</code>, assignment is by name. Otherwise, it's positional:</p> <pre><code>// Positional - 'output' isn't a special name\ncode, output = $`echo hi`           // output = stdout (by position)\nexit_code, out, err = $`ls`         // Assigned in order\n</code></pre> <p>This lets you write clear code like <code>stderr = $cmd</code> instead of <code>_, _, stderr = $cmd</code>.</p> <p>Silencing outputs</p> <p>You can use <code>_</code> to ignore specific outputs: <code>code, _ = $cmd</code> captures the code and ignores stdout. For silent execution, capture everything: <code>_, _, _ = $cmd</code> - nothing will print to the terminal.</p>"},{"location":"guide/shell-commands/#error-handling","title":"Error Handling","text":"<p>Now that you understand how to capture output, let's talk about error handling.</p> <p>When a shell command exits with a non-zero exit code, it triggers error propagation - just like functions that return errors. This means you can handle potential failures using <code>catch:</code> blocks:</p> <pre><code>// Handle errors with catch block\n$`make build` catch:\n    print_err(\"Build failed!\".red())\n    exit(1)\n\n// Or ignore failures\n$`make build` catch:\n    pass  // Continue on failure\n</code></pre> <p>You can combine capturing with error handling. When the <code>catch:</code> block runs, your variables are already assigned their actual values, so you can inspect them:</p> <pre><code>// Capture the exit code AND handle errors\ncode = $`make test` catch:\n    print_err(\"Command failed to run. Error code {code}\")\n    exit(1)\n\nprint(\"Tests passed!\")\n</code></pre> <p>This works with any capture pattern:</p> <pre><code>code, stdout = $`git tag --list` catch:\n    print_err(\"Failed to get tags\")\n    exit(1)\n\nversion = stdout.trim()\n</code></pre> <p>This uses the same error model covered in Error Handling - errors propagate by default, so you need <code>catch:</code> blocks to handle them.</p>"},{"location":"guide/shell-commands/#string-interpolation","title":"String Interpolation","text":"<p>You can build commands dynamically using string interpolation:</p> <pre><code>args:\n    version str\n    message str\n\n// Interpolate variables into commands\n$`git tag v{version}` catch:\n    print_err(\"Failed to create tag\")\n    exit(1)\n\n$`git commit -m \"{message}\"` catch:\n    print_err(\"Commit failed\")\n    exit(1)\n</code></pre> <p>This is particularly useful for constructing commands based on script arguments or other runtime values.</p>"},{"location":"guide/shell-commands/#modifiers","title":"Modifiers","text":"<p>Rad provides two modifiers that can be applied to shell commands.</p>"},{"location":"guide/shell-commands/#the-quiet-modifier","title":"The <code>quiet</code> Modifier","text":"<p>By default, Rad announces each shell command with a \u26a1\ufe0f prefix. For example, this command:</p> <pre><code>$`touch hello.txt` catch:\n    print_err(\"Failed to create file\")\n    exit(1)\n</code></pre> <p>Shows in the terminal:</p> <pre><code>\u26a1\ufe0f touch hello.txt\n</code></pre> <p>To suppress this announcement, use the <code>quiet</code> modifier:</p> <pre><code>quiet $`touch hello.txt` catch:\n    print_err(\"Failed to create file\")\n    exit(1)\n</code></pre> <pre><code>(no output - unless there's an error)\n</code></pre> <p>This is useful for scripts that run many commands or when you want minimal output.</p>"},{"location":"guide/shell-commands/#the-confirm-modifier","title":"The <code>confirm</code> Modifier","text":"<p>The <code>confirm</code> modifier prompts the user before running a command:</p> <pre><code>confirm $`rm -rf node_modules`\n</code></pre> <p>This is particularly useful for destructive operations.</p>"},{"location":"guide/shell-commands/#practical-examples","title":"Practical Examples","text":"<p>Let's look at some real-world patterns that combine these features.</p>"},{"location":"guide/shell-commands/#development-workflow","title":"Development Workflow","text":"<p>Here's a script inspired by a typical development workflow:</p> <pre><code>---\nValidates code, checks git status, and optionally pushes changes.\n---\nargs:\n    push p bool  # Push changes after validation\n\n// Run validation steps\nsteps = [\"go mod tidy\", \"make format\", \"make build\", \"make test\"]\n\nfor step in steps:\n    $step catch:\n        print_err(\"\u274c {step} failed\".red())\n        exit(1)\n    print(\"\u2705 {step} passed\".green())\n\nif push:\n    // Check for uncommitted changes\n    stdout = $`git status --porcelain` catch:\n        print_err(\"Failed to check git status\")\n        exit(1)\n\n    if stdout.trim() != \"\":\n        print_err(\"Working directory has uncommitted changes!\")\n        print_err(\"Commit your changes before pushing.\")\n        exit(1)\n\n    // Get current branch and push\n    stdout = $`git branch --show-current` catch:\n        print_err(\"Failed to get current branch\")\n        exit(1)\n\n    branch = stdout.trim()\n    print(\"Pushing to {branch}...\".yellow())\n\n    $`git push origin {branch}` catch:\n        print_err(\"Push failed\")\n        exit(1)\n\n    print(\"\u2705 Pushed to {branch}\".green())\n\nprint(\"\u2705 Done!\".green())\n</code></pre>"},{"location":"guide/shell-commands/#conditional-construction","title":"Conditional Construction","text":"<p>Building commands dynamically based on script arguments:</p> <pre><code>args:\n    verbose v bool\n    output o str?\n\ncmd = \"docker build .\"\n\nif verbose:\n    cmd += \" --progress=plain\"\n\nif output:\n    cmd += \" -t {output}\"\n\n$`{cmd}` catch:\n    print_err(\"Docker build failed\")\n    exit(1)\n\nprint(\"Docker image built successfully\".green())\n</code></pre>"},{"location":"guide/shell-commands/#checking-prerequisites","title":"Checking Prerequisites","text":"<p>Verifying that required tools are installed:</p> <pre><code>tools = [\"git\", \"docker\", \"make\"]\n\nfor tool in tools:\n    _, _, _ = $`which {tool}` catch:\n        print_err(\"Required tool not found: {tool}\")\n        print_err(\"Please install {tool} before running this script\")\n        exit(1)\n\nprint(\"All prerequisites installed \u2705\".green())\n</code></pre>"},{"location":"guide/shell-commands/#summary","title":"Summary","text":"<ul> <li>Shell commands use the <code>$</code> prefix and follow the same error model as functions</li> <li>Error handling: Non-zero exit codes propagate errors unless handled with <code>catch:</code> blocks</li> <li>Capture modes:<ul> <li>None: output goes to terminal</li> <li>Code only: <code>code = $cmd</code> (stdout/stderr to terminal)</li> <li>Code + stdout: <code>code, stdout = $cmd</code> (stderr to terminal)</li> <li>All three: <code>code, stdout, stderr = $cmd</code> (nothing to terminal)</li> </ul> </li> <li>Assignment semantics:<ul> <li>Named when ALL variables are <code>code</code>, <code>stdout</code>, or <code>stderr</code> (order-independent)</li> <li>Positional otherwise (order matters)</li> </ul> </li> <li>Output routing: Captured values don't print to the terminal (they're redirected to variables)</li> <li>String interpolation works in commands for dynamic construction</li> <li>Backticks are preferred for shell command strings to avoid delimiter conflicts</li> </ul>"},{"location":"guide/shell-commands/#next","title":"Next","text":"<p>Shell commands let you invoke external programs, but what if you want to organize your script into multiple operations - like <code>git commit</code>, <code>docker build</code>, or <code>kubectl apply</code>?</p> <p>That's where commands come in. We'll explore them in the next section: Script Commands.</p>"},{"location":"guide/stashes/","title":"Stashes","text":"<p>Sometimes your script needs to remember things between runs - user preferences, counters, cached data, or configuration. Stashes are Rad's built-in mechanism for persistent, per-script storage.</p>"},{"location":"guide/stashes/#the-basics","title":"The Basics","text":"<p>Every script can have its own stash - a dedicated storage area that persists between runs. To use a stash, you need to declare a stash ID in your script's file header using the <code>@stash_id</code> macro:</p> counter.rad<pre><code>#!/usr/bin/env rad\n---\nA simple counter that remembers how many times it's been run.\n@stash_id = JJRNBOSKHpa\n---\n\nstate = load_state()\ndefer save_state(state)\n\ncount = state[\"count\"] ?? 0\ncount++\nstate[\"count\"] = count\n\nprint(\"This script has been run {count} time(s)!\")\n</code></pre> <p>Let's run it a few times:</p> <pre><code>rad counter.rad\n</code></pre> <pre><code>This script has been run 1 time(s)!\n</code></pre> <pre><code>rad counter.rad\n</code></pre> <pre><code>This script has been run 2 time(s)!\n</code></pre> <p>The count persists because it's saved to the stash.</p>"},{"location":"guide/stashes/#generating-a-stash-id","title":"Generating a Stash ID","text":"<p>You might wonder what that <code>JJRNBOSKHpa</code> string is. It's a unique identifier for your script's stash. You can use any string you like, but Rad provides a built-in command to generate collision-resistant IDs:</p> <pre><code>rad gen-id\n</code></pre> <pre><code>K7mPqR2xNfL\n</code></pre> <p>Using <code>rad gen-id</code> is recommended, especially if you plan to share your scripts. It ensures your stash ID won't accidentally collide with another script's stash on someone else's machine.</p>"},{"location":"guide/stashes/#the-defer-save-state-pattern","title":"The Defer Save State Pattern","text":"<p>The example above demonstrates the recommended pattern for working with stashes:</p> <pre><code>state = load_state()\ndefer save_state(state)\n\n// ... use and modify state ...\n</code></pre> <p>The <code>defer</code> ensures your state is saved even if the script exits early or encounters an error. This pattern is so common that you'll want to use it almost every time you work with stashes.</p>"},{"location":"guide/stashes/#state-storage","title":"State Storage","text":"<p>The primary way to use stashes is through state - a map that gets persisted as JSON.</p>"},{"location":"guide/stashes/#loading-state","title":"Loading State","text":"<p><code>load_state()</code> returns your script's saved state as a map. If no state exists yet (first run), it returns an empty map <code>{}</code>:</p> <pre><code>state = load_state()\nprint(state)  // {} on first run, or previously saved data\n</code></pre>"},{"location":"guide/stashes/#saving-state","title":"Saving State","text":"<p><code>save_state(map)</code> persists the map to disk:</p> <pre><code>state = {\"username\": \"alice\", \"theme\": \"dark\"}\nsave_state(state)\n</code></pre> <p>The state is stored as JSON at <code>~/.rad/stashes/&lt;stash_id&gt;/state.json</code>, making it easy to inspect or debug.</p>"},{"location":"guide/stashes/#working-with-state","title":"Working with State","text":"<p>Since state is just a map, you can use all of Rad's map operations. The <code>??</code> fallback operator is particularly useful for providing default values:</p> preferences.rad<pre><code>#!/usr/bin/env rad\n---\nRemembers user preferences.\n@stash_id = K7mPqR2xNfL\n---\nargs:\n    set_editor str?  # Set preferred editor\n    set_theme str?   # Set color theme\n\nstate = load_state()\ndefer save_state(state)\n\n// Update preferences if provided\nif set_editor:\n    state[\"editor\"] = set_editor\n    print(\"Editor set to: {set_editor}\")\n\nif set_theme:\n    state[\"theme\"] = set_theme\n    print(\"Theme set to: {set_theme}\")\n\n// Show current preferences\neditor = state[\"editor\"] ?? \"vim\"\ntheme = state[\"theme\"] ?? \"dark\"\nprint(\"Current preferences: editor={editor}, theme={theme}\")\n</code></pre> <pre><code>rad preferences.rad\n</code></pre> <pre><code>Current preferences: editor=vim, theme=dark\n</code></pre> <pre><code>rad preferences.rad --set-editor nano --set-theme light\n</code></pre> <pre><code>Editor set to: nano\nTheme set to: light\nCurrent preferences: editor=nano, theme=light\n</code></pre> <pre><code>rad preferences.rad\n</code></pre> <pre><code>Current preferences: editor=nano, theme=light\n</code></pre>"},{"location":"guide/stashes/#file-storage","title":"File Storage","text":"<p>Beyond state, stashes can also store arbitrary files. This is useful for caching larger data, storing user-created content, or managing configuration files.</p>"},{"location":"guide/stashes/#writing-files","title":"Writing Files","text":"<p><code>write_stash_file(path, content)</code> writes a file to your stash:</p> <pre><code>write_stash_file(\"cache.json\", '{\"data\": [1, 2, 3]}')\nwrite_stash_file(\"logs/run.log\", \"Script executed at {now().time}\")\n</code></pre> <p>Nested paths work automatically - Rad creates any necessary directories.</p>"},{"location":"guide/stashes/#loading-files","title":"Loading Files","text":"<p><code>load_stash_file(path, default)</code> loads a file from your stash, creating it with the default content if it doesn't exist:</p> <pre><code>result = load_stash_file(\"config.txt\", \"# Default config\\nkey=value\")\nprint(\"Path: {result.full_path}\")\nprint(\"Was just created: {result.created}\")\nprint(\"Content: {result.content}\")\n</code></pre> <p>The return value is a map containing:</p> <ul> <li><code>full_path</code> - the absolute path to the file</li> <li><code>created</code> - <code>true</code> if the file was just created, <code>false</code> if it already existed</li> <li><code>content</code> - the file's contents</li> </ul> <p>The <code>created</code> field is particularly useful for first-time setup:</p> notes.rad<pre><code>#!/usr/bin/env rad\n---\nA simple notes manager.\n@stash_id = N4xPmK8wQrT\n---\nargs:\n    add str?  # Add a new note\n\nresult = load_stash_file(\"notes.txt\", \"\")\n\nif result.created:\n    print(\"Created new notes file!\")\n\nif add:\n    // Append the new note\n    new_content = result.content + add + \"\\n\"\n    write_stash_file(\"notes.txt\", new_content)\n    print(\"Note added!\")\nelse:\n    if result.content:\n        print(\"Your notes:\")\n        print(result.content)\n    else:\n        print(\"No notes yet. Use --add to create one.\")\n</code></pre>"},{"location":"guide/stashes/#getting-the-stash-path","title":"Getting the Stash Path","text":"<p><code>get_stash_path(subpath?)</code> returns the path to your stash directory:</p> <pre><code>stash_path = get_stash_path()\nprint(stash_path)  // ~/.rad/stashes/&lt;stash_id&gt;\n\nfile_path = get_stash_path(\"data/config.json\")\nprint(file_path)  // ~/.rad/stashes/&lt;stash_id&gt;/data/config.json\n</code></pre> <p>This is useful when you need to work with stash files using other Rad functions like <code>read_file</code> or <code>get_path</code>.</p>"},{"location":"guide/stashes/#stash-structure","title":"Stash Structure","text":"<p>Your stash lives at <code>~/.rad/stashes/&lt;stash_id&gt;/</code> with this structure:</p> <pre><code>~/.rad/stashes/&lt;stash_id&gt;/\n\u251c\u2500\u2500 state.json          # Your state map (from save_state)\n\u2514\u2500\u2500 files/              # Your stash files\n    \u251c\u2500\u2500 config.txt\n    \u251c\u2500\u2500 cache.json\n    \u2514\u2500\u2500 logs/\n        \u2514\u2500\u2500 run.log\n</code></pre> <p>State and files are kept separate - <code>state.json</code> is managed by <code>load_state</code>/<code>save_state</code>, while the <code>files/</code> subdirectory is managed by <code>load_stash_file</code>/<code>write_stash_file</code>.</p>"},{"location":"guide/stashes/#managing-stashes","title":"Managing Stashes","text":"<p>Rad provides a built-in command to inspect and manage stashes for scripts on your PATH:</p> <pre><code>rad stash myscript --state   # View the script's state\nrad stash myscript --id      # Show the stash ID\nrad stash myscript --delete  # Delete the stash\n</code></pre> <p>Scripts Must Be on PATH</p> <p>The <code>rad stash</code> command looks up scripts on your PATH. For scripts not on your PATH, you can inspect the stash directly at <code>~/.rad/stashes/&lt;stash_id&gt;/</code>.</p>"},{"location":"guide/stashes/#summary","title":"Summary","text":"<ul> <li>Stashes provide persistent, per-script storage that survives between runs.</li> <li>Declare a stash ID in the file header with <code>@stash_id = &lt;id&gt;</code>.</li> <li>Use <code>rad gen-id</code> to generate collision-resistant IDs.</li> <li>State storage: Use <code>load_state()</code> and <code>save_state(map)</code> for map-based data.</li> <li>File storage: Use <code>load_stash_file()</code> and <code>write_stash_file()</code> for arbitrary files.</li> <li>The recommended pattern is <code>state = load_state()</code> followed by <code>defer save_state(state)</code>.</li> <li>Stashes live at <code>~/.rad/stashes/&lt;stash_id&gt;/</code>.</li> </ul>"},{"location":"guide/strings-advanced/","title":"Strings (Advanced)","text":"<p>Strings are everywhere in scripting - from building messages to formatting output. In the Basics section, we covered simple string operations, but Rad offers much more powerful features for working with text.</p> <p>In this section, we'll explore:</p> <ul> <li>String interpolation - embed expressions directly in strings</li> <li>Formatting - control how values are displayed (padding, fill characters, zero-padding, precision, thousands separators)</li> <li>Multiline strings - work with text spanning multiple lines</li> <li>Raw strings - disable interpolation and escaping when you need literal text</li> <li>Escape sequences - include special characters like newlines and tabs</li> <li>String attributes - add color, bold, and other terminal styling</li> </ul> <p>These features make it easy to generate well-formatted output, build complex strings, and create polished CLI experiences.</p>"},{"location":"guide/strings-advanced/#string-interpolation","title":"String Interpolation","text":"<p>Rad allows embedding expressions inside your strings that will get evaluated and replaced to produce the 'final' string.</p> <p>Some examples:</p> <pre><code>name = \"Alice\"\nprint(\"Hi, {name}!\")\n\nprint(\"Uppercase: {name.upper()}\")\n\nprint(\"Conditions: {name.len() &gt; 5 ? 'long name' : 'short name'}!\")\n</code></pre> <pre><code>Hi, Alice!\nUppercase: ALICE\nConditions: short name!\n</code></pre> <p>String interpolation expressions can be as simple as just an identifier, or can involve function calls, math, list comprehensions, etc (though you should consider extracting complex expressions into named variables beforehand for the sake of clarity).</p> <p>Note the use of single quote <code>'</code> strings inside the last line of the above example. Using double quotes would've closed the \"outer\" string prematurely, but using another delimiter allows us to avoid that without also needing to escape anything.</p>"},{"location":"guide/strings-advanced/#formatting","title":"Formatting","text":"<p>You can format expression results while doing string interpolation. To do so, follow your expression with a colon <code>:</code> and then the relevant syntax for the formatting you want to do. We'll demonstrate through some examples:</p> <pre><code>pi = 3.14159265359\n\nprint(\"Pi: {pi}_\")       // no formatting\nprint(\"Pi: {pi:20}_\")    // left-pad to 20 places (default)\nprint(\"Pi: {pi:&lt;20}_\")   // right-pad to 20 places\nprint(\"Pi: {pi:.3}_\")    // print to 3 decimal places\nprint(\"Pi: {pi:10.2}_\")  // left-pad to 10 places, including 2 decimal places\n</code></pre> <pre><code>Pi: 3.14159265359_\nPi:             3.141593_\nPi: 3.141593            _\nPi: 3.142_\nPi:       3.14_\n</code></pre>"},{"location":"guide/strings-advanced/#fill-characters","title":"Fill Characters","text":"<p>By default, padding uses spaces. You can specify a different fill character by placing it before the alignment indicator (<code>&gt;</code> or <code>&lt;</code>):</p> <pre><code>name = \"Alice\"\nnum = 42\n\nprint(\"_{name:*&gt;10}_\")   // fill with *, right-align\nprint(\"_{name:.&lt;10}_\")   // fill with ., left-align\nprint(\"_{num:-&gt;8}_\")     // fill with -, right-align\n</code></pre> <pre><code>_*****Alice_\n_Alice....._\n_------42_\n</code></pre> <p>The fill character can be any single character. The <code>&gt;</code> and <code>&lt;</code> after it control the alignment, just like without a fill character.</p>"},{"location":"guide/strings-advanced/#zero-padding","title":"Zero-Padding","text":"<p>You can use the zero-pad shorthand by placing <code>0</code> before the width. This works on any type:</p> <pre><code>name = \"alice\"\nnum = 42\nneg = -7\n\nprint(\"_{name:08}_\")     // pad string with zeros to width 8\nprint(\"_{num:05}_\")      // pad number with zeros to width 5\nprint(\"_{neg:06}_\")      // sign-aware for numbers: sign before zeros\nprint(\"_{num:08.2}_\")    // combine with precision\n</code></pre> <pre><code>_000alice_\n_00042_\n_-00007_\n_00042.00_\n</code></pre> <p>You can also combine zero-padding with thousands separators:</p> <pre><code>num = 7000\nprint(\"_{num:010,}_\")\n</code></pre> <pre><code>_00,007,000_\n</code></pre> <p>For numbers, zero-pad is sign-aware (signs placed before zeros). For non-numbers, it simply prepends zeros (same as explicit zero fill <code>{x:0&gt;5}</code>).</p>"},{"location":"guide/strings-advanced/#thousands-separator","title":"Thousands Separator","text":"<p>For large numbers, you can add comma separators using <code>,</code> in your formatting:</p> <pre><code>population = 1234567\nprice = 1234.56\n\nprint(\"Population: {population:,}\")\nprint(\"Price: {price:,.2}\")\nprint(\"Large: {population:20,.0}\")  // combine padding, comma, and precision\n</code></pre> <pre><code>Population: 1,234,567\nPrice: 1,234.56\nLarge:            1,234,567\n</code></pre>"},{"location":"guide/strings-advanced/#number-vs-string-formatting","title":"Number vs String Formatting","text":"<p>Decimal place formatting (<code>.X</code>) and thousands separators (<code>,</code>) only work on numbers. Using them on strings will cause an error:</p> <pre><code>name = \"Alice\"\nprint(\"{name:.2}\")   // Error: cannot format string with decimal places\nprint(\"{name:,}\")    // Error: cannot format string with thousands separator\n</code></pre> <p>However, padding, fill characters, and zero-padding work on all types:</p> <pre><code>print(\"{name:10}\")     // \"     Alice\" (padded to 10 chars)\nprint(\"{name:*&gt;10}\")   // \"*****Alice\" (fill with *, any type)\nprint(\"{name:08}\")     // \"000Alice\"   (zero-pad shorthand, any type)\n</code></pre>"},{"location":"guide/strings-advanced/#multiline-strings","title":"Multiline Strings","text":"<p>Sometimes you want to write strings that contain several lines. These strings may themselves also contain string delimiters e.g. <code>\"</code> or <code>'</code>. For these scenarios, Rad offers <code>\"\"\"</code> multiline string syntax. To demonstrate:</p> <pre><code>text = \"\"\"\nThis is an\nexample of text\nthat \"may contain quotes\"!\nIt also supports interpolation:\nOne plus one equals {1 + 1}\n\"\"\"\nprint(text)\n</code></pre> <pre><code>This is an\nexample of text\nthat \"may contain quotes\"!\nOne plus one equals 2\n</code></pre> <p>Multiline strings must follow some rules:</p> <ol> <li>The opening <code>\"\"\"</code> must not be followed by any non-comment tokens on the same line.</li> <li>The newline after the opening <code>\"\"\"</code> is excluded from the contents of the string. Contents begin on the next line.</li> <li>The closing <code>\"\"\"</code> must not be preceded by any non-whitespace characters on that same line.</li> <li>Whitespace preceding the closing <code>\"\"\"</code> will get removed from the front of each line in the string block.<ul> <li>In other words, you can use the indentation of the closing <code>\"\"\"</code> to control the desired indentation of your contents.</li> <li>If the closing <code>\"\"\"</code> is preceded by more whitespace than exists on any line of string contents, that means we cannot remove that amount of whitespace from the line, leading to an error.</li> </ul> </li> </ol> <p>Below, we demonstrate the 4th point. Note that to make the \"whitespaces\" more visible, I've replaced them with dots, but keep in mind they do represent spaces:</p> <pre><code>text = \"\"\"\n....This is an\n.....example of text\n..that \"may contain quotes\"!\n..\"\"\"  // &lt; 2 preceding spaces. will get removed from each line in the contents.\nprint(text)\n</code></pre> <pre><code>..This is an\n...example of text\nthat \"may contain quotes\"!\n</code></pre>"},{"location":"guide/strings-advanced/#raw-strings","title":"Raw Strings","text":"<p>Rad also supports raw strings. Raw strings don't perform string interpolation and do not allow any escaping (including the delimiter used to create them). Use them when you want your contents to remain as \"raw\" and unprocessed as possible.</p> <p>To use them, just prefix the delimiter of your choice (single/double quotes or backticks) with <code>r</code>.</p> <pre><code>text = r\"Hello\\n{name}\"\nprint(text)\n</code></pre> <pre><code>Hello\\n{name}\n</code></pre> <p>Notice the printed string is exactly as written in code - the newline character and string interpolation are left as-is.</p> <p>You can use any of the string delimiters for raw strings, including multiline <code>\"\"\"</code>:</p> <pre><code>text = r\"Hello\\n{name}\"\ntext = r'Hello\\n{name}'\ntext = r`Hello\\n{name}`\ntext = r\"\"\"\nHello\\n{name}\n\"\"\"\n</code></pre> <p>Common uses for raw strings</p> <p>Raw strings can be quite handy for file paths, especially Windows-style ones that use backslashes:</p> <pre><code>path = r\"C:\\Users\\Documents\\notes.txt\"\n</code></pre> <p>They can also be useful for text containing lots of braces <code>{}</code>, in order to disable string interpolation:</p> <pre><code>json_str = r\"{ 'my_key': { 'my_key2' : 3 } }\"\n</code></pre>"},{"location":"guide/strings-advanced/#escape-sequences","title":"Escape Sequences","text":"<p>When you need special characters in your strings, you can use backslash <code>\\</code> to escape them:</p> <pre><code>print(\"Line 1\\nLine 2\")      // newline\nprint(\"Col1\\tCol2\")          // tab\nprint(\"Path: C:\\\\Users\")     // backslash\nprint(\"She said \\\"Hi!\\\"\")    // quote (though prefer using a different delimiter, or raw strings)\n</code></pre> <pre><code>Line 1\nLine 2\nCol1    Col2\nPath: C:\\Users\nShe said \"Hi!\"\n</code></pre> <p>Available escape sequences:</p> <ul> <li><code>\\n</code> - newline</li> <li><code>\\t</code> - tab</li> <li><code>\\\\</code> - literal backslash</li> <li><code>\\\"</code> <code>\\'</code> <code>\\`</code> - the delimiter itself (though prefer using a different delimiter)</li> <li><code>\\{</code> - literal brace (prevents interpolation, but consider using raw strings)</li> </ul>"},{"location":"guide/strings-advanced/#string-attributes","title":"String Attributes","text":"<p>Strings in Rad can carry attributes like color, bold, italic, and underline. These attributes are preserved through string interpolation and concatenation:</p> <pre><code>name = \"Alice\".green()\nprint(\"Hello, {name}!\")  // \"Alice\" appears green in terminal\nprint(\"Status: \" + \"ACTIVE\".bold())  // \"ACTIVE\" appears bold\n</code></pre> <p>You can apply multiple attributes by chaining function calls:</p> <pre><code>title = \"Important\".underline().bold()\nwarning = \"WARNING\".bold().red()\nprint(title)\nprint(warning)\n</code></pre> <p>Rad provides color functions (<code>red</code>, <code>green</code>, <code>blue</code>, <code>yellow</code>, etc.), style functions (<code>bold</code>, <code>italic</code>, <code>underline</code>), and the <code>hyperlink</code> function for creating clickable terminal links. See the functions reference.</p> <p>When Attributes Are Preserved</p> <ul> <li>Preserved: Interpolation, concatenation, index lookup, slicing, <code>upper()</code>, <code>lower()</code>, <code>trim()</code>, <code>trim_prefix()</code>, <code>trim_suffix()</code>, <code>trim_left()</code>, <code>trim_right()</code>, and <code>reverse()</code></li> <li>Not preserved: <code>replace()</code>, <code>split()</code></li> </ul> <p>String Manipulation Functions</p> <p>In addition to the syntax features covered here, Rad provides many built-in functions for working with strings. Use UFCS (dot notation) for cleaner, more readable code:</p> <ul> <li><code>text.upper()</code>, <code>text.lower()</code> - change case</li> <li><code>text.replace(old, new)</code>, <code>text.split(sep)</code>, <code>items.join(sep)</code> - transform and combine strings</li> <li><code>text.trim()</code>, <code>text.trim_left()</code>, <code>text.trim_right()</code> - strip matching characters</li> <li><code>text.trim_prefix(prefix)</code>, <code>text.trim_suffix(suffix)</code> - remove a literal prefix/suffix</li> <li><code>text.starts_with(prefix)</code>, <code>text.ends_with(suffix)</code> - check string prefixes/suffixes</li> <li><code>text.count(substr)</code> - count substring occurrences</li> <li>And many more!</li> </ul> <p>See the Functions Reference for the complete list with examples.</p>"},{"location":"guide/strings-advanced/#summary","title":"Summary","text":"<ul> <li>We learned about escape sequences like <code>\\n</code>, <code>\\t</code>, and <code>\\{</code> for including special characters in strings.</li> <li>We covered string interpolation, which lets us put expressions directly into strings for evaluation.</li> <li>We saw how to format interpolated expressions using padding, fill characters, zero-padding, precision, and more. Example: <code>{num:0&gt;10,.3}</code>.</li> <li>We explored multiline strings using <code>\"\"\"</code> syntax, which support both quotes and interpolation.</li> <li>We learned about raw strings (prefixed with <code>r</code>) that prevent interpolation and escaping.</li> <li>We covered string attributes like color and bold that are preserved through interpolation and concatenation.</li> <li>Rad also provides many built-in string manipulation functions covered in the Functions Reference.</li> </ul>"},{"location":"guide/strings-advanced/#next","title":"Next","text":"<p>Next, let's look at another Rad feature which makes it uniquely suited to certain types of scripting: Rad Blocks.</p>"},{"location":"guide/type-annotations/","title":"Type Annotations","text":"<p>As your scripts grow beyond quick one-offs, type annotations become increasingly valuable. They help catch errors early, make your code self-documenting, and keep scripts maintainable as they evolve or get shared with others.</p> <p>In the Functions section, we briefly introduced type annotations for function parameters and return values. Now let's explore Rad's complete type system - from basic primitives to advanced types like unions, structs, and function signatures.</p>"},{"location":"guide/type-annotations/#the-basics","title":"The Basics","text":"<p>Type annotations let you declare what types of values your function parameters accept and what type of value your function returns. The syntax follows a pattern you may recognize from TypeScript or Python's type hints:</p> <pre><code>fn calculate_area(width: int, height: int) -&gt; int:\n    return width * height\n\narea = calculate_area(5, 10)\nprint(area)  // 50\n</code></pre> <p>Here, <code>width: int</code> and <code>height: int</code> specify that both parameters must be integers, and <code>-&gt; int</code> declares that the function returns an integer.</p>"},{"location":"guide/type-annotations/#why-use-type-annotations","title":"Why Use Type Annotations?","text":"<p>Type annotations provide three key benefits:</p> <ol> <li>Self-documenting code - The function signature clearly communicates what types it expects and returns</li> <li>Runtime validation - Rad checks types at runtime and produces helpful error messages when types don't match</li> <li>Tooling support - IDEs and linters can provide better autocomplete and catch errors before you run your code</li> </ol> <p>Let's see runtime validation in action:</p> <pre><code>fn greet(name: str) -&gt; str:\n    return \"Hello, {name}!\"\n\nmessage = greet(42)  // Error!\nprint(message)\n</code></pre> <pre><code>Error at L4:17\n\nmessage = greet(42)  // Error!\n                ^^ Value '42' (int) is not compatible with expected type 'str'\n</code></pre> <p>The error message clearly identifies the problem - we passed an integer when the function expects a string.</p>"},{"location":"guide/type-annotations/#basic-primitive-types","title":"Basic Primitive Types","text":"<p>Rad supports the standard primitive types you'd expect: <code>str</code>, <code>int</code>, <code>float</code>, and <code>bool</code></p> <pre><code>fn process_data(\n    name: str,\n    age: int,\n    salary: float,\n    is_active: bool\n) -&gt; str:\n    status = is_active ? \"active\" : \"inactive\"\n    return \"{name} ({age}) earns ${salary:.2} - {status}\"\n\nresult = process_data(\"Alice\", 30, 75000.50, true)\nprint(result)\n</code></pre> <pre><code>Alice (30) earns $75000.50 - active\n</code></pre>"},{"location":"guide/type-annotations/#special-types-void-and-null","title":"Special Types: void and null","text":"<p>Two additional types appear throughout Rad but work differently from the primitives:</p> <p><code>void</code>: Indicates a function returns nothing. Functions marked <code>-&gt; void</code> don't return a value, and attempting to return a value is an error:</p> <pre><code>fn log_message(msg: str) -&gt; void:\n    print(msg)                 // OK\n\nfn log_message(msg: str) -&gt; void:\n    return msg                 // Error: can't return values\n</code></pre> <p><code>null</code>: The single value representing \"no value\" or \"absence.\" Important: <code>null</code> is only a valid value for optional types marked with <code>?</code>:</p> <pre><code>fn get_name() -&gt; str:\n    return null          // Error: can't return null from str function\n\nfn get_name() -&gt; str?:\n    return null          // OK: str? can return null\n</code></pre> <p>Think of <code>null</code> as belonging exclusively to optional types - it's the way to represent \"this optional value is absent.\"</p>"},{"location":"guide/type-annotations/#collection-types","title":"Collection Types","text":"<p>Rad also lets you specify collection types, with their contents being either typed or untyped.</p>"},{"location":"guide/type-annotations/#typed-lists","title":"Typed Lists","text":"<p>You can specify what type of values a list contains using the <code>&lt;type&gt;[]</code> syntax:</p> <pre><code>fn sum_numbers(nums: int[]) -&gt; int:\n    total = 0\n    for num in nums:\n        total += num\n    return total\n\nresult = sum_numbers([1, 2, 3, 4, 5])\nprint(result)  // 15\n</code></pre> <p>The <code>int[]</code> annotation means \"a list of integers\". Like with other type annotations, if you try to pass a list containing non-integers, you'll get a runtime error.</p> <p>More examples with different types:</p> <pre><code>fn join_words(words: str[]) -&gt; str:\n    return words.join(\" \")\n\nfn average(numbers: float[]) -&gt; float:\n    return sum(numbers) / len(numbers)\n\nsentence = join_words([\"Hello\", \"from\", \"Rad\"])\nprint(sentence)\n</code></pre> <pre><code>Hello from Rad\n</code></pre>"},{"location":"guide/type-annotations/#typed-maps","title":"Typed Maps","text":"<p>Maps can also be typed, specifying both key and value types using <code>{ &lt;key type&gt;: &lt;value type&gt; }</code> syntax:</p> <pre><code>fn count_words(text: str) -&gt; { str: int }:\n    words = text.split(\" \")\n    counts = {}\n    for word in words:\n        if word in counts:\n            counts[word] += 1\n        else:\n            counts[word] = 1\n    return counts\n\nresult = count_words(\"hello world hello\")\nprint(result)\n</code></pre> <pre><code>{ \"hello\": 2, \"world\": 1 }\n</code></pre> <p>The <code>{ str: int }</code> annotation means \"a map with string keys and integer values\".</p>"},{"location":"guide/type-annotations/#generic-collections","title":"Generic Collections","text":"<p>When you don't want to specify what's inside a collection, use the generic forms:</p> <pre><code>fn print_items(items: list) -&gt; void:\n    for item in items:\n        print(item)\n\nfn lookup(data: map, key: str) -&gt; any:\n    return data[key]\n</code></pre> <p>Here, <code>list</code> accepts a list with any types of values, and <code>map</code> accepts a map with any keys and values.</p> <p>The <code>any</code> type means \"any type of value\" - it's the most permissive type and accepts strings, numbers, booleans, lists, maps, or any other value.</p> <p>Generic collections are useful when your types are mixed or you don't wish to overcomplicate your type annotations unnecessarily.</p>"},{"location":"guide/type-annotations/#nested-collections","title":"Nested Collections","text":"<p>Types can be nested for complex data structures:</p> <pre><code>fn organize_by_category(items: str[]) -&gt; { str: str[] }:\n    categories = {}\n    for item in items:\n        category = item[0].upper()  // First letter\n        if category not in categories:\n            categories[category] = []\n        categories[category] += [item]\n    return categories\n\nitems = [\"apple\", \"banana\", \"apricot\", \"blueberry\"]\nresult = organize_by_category(items)\nprint(result)\n</code></pre> <pre><code>{ \"A\": [ \"apple\", \"apricot\" ], \"B\": [ \"banana\", \"blueberry\" ] }\n</code></pre> <p>The return type <code>{ str: str[] }</code> describes a map where each key is a string and each value is a list of strings.</p>"},{"location":"guide/type-annotations/#optional-types","title":"Optional Types","text":"<p>Sometimes a parameter might not always be needed. Rad's optional type syntax with <code>?</code> makes parameters completely optional - you can pass a value, pass <code>null</code>, or omit the parameter entirely:</p> <pre><code>fn greet(name: str, title: str?) -&gt; str:\n    if title == null:\n        return \"Hello, {name}!\"\n    else:\n        return \"Hello, {title} {name}!\"\n\nprint(greet(\"Alice\", \"Dr.\"))     // Pass a value\nprint(greet(\"Bob\", null))        // Explicitly pass null\nprint(greet(\"Charlie\"))          // Omit the parameter entirely\n</code></pre> <pre><code>Hello, Dr. Alice!\nHello, Bob!\nHello, Charlie!\n</code></pre> <p>The <code>str?</code> annotation means \"an optional string parameter\". When omitted or explicitly set to <code>null</code>, the parameter will be <code>null</code> inside the function. This makes it clear that the <code>title</code> parameter is optional and the function knows how to handle its absence.</p> <p>Optional types work with any type:</p> <pre><code>fn find_user(id: int, users: map[]) -&gt; map?:\n    for user in users:\n        if user[\"id\"] == id:\n            return user\n    return null\n\nusers = [{\"id\": 1, \"name\": \"Alice\"}, {\"id\": 2, \"name\": \"Bob\"}]\nuser = find_user(1, users)\nprint(user)  // {\"id\": 1, \"name\": \"Alice\"}\n\nmissing = find_user(999, users)\nprint(missing)  // null\n</code></pre> <p>The <code>map?</code> return type indicates the function might return a map or might return null if no user is found.</p>"},{"location":"guide/type-annotations/#defaults","title":"Defaults","text":"<p>Parameters can have default values, making them optional to provide when calling the function. This works whether or not the parameter is marked with <code>?</code>:</p> <pre><code>fn greet(name: str, greeting: str = \"Hello\") -&gt; str:\n    return \"{greeting}, {name}!\"\n\nprint(greet(\"Alice\"))                // Uses default \"Hello\"\nprint(greet(\"Bob\", \"Hi\"))            // Uses provided \"Hi\"\n</code></pre> <pre><code>Hello, Alice!\nHi, Bob!\n</code></pre> <p>The <code>greeting</code> parameter has a default value of <code>\"Hello\"</code>. When you omit it, the default is used. Note that <code>greeting</code> is not marked with <code>?</code> - it always has a string value, never <code>null</code>.</p>"},{"location":"guide/type-annotations/#defaults-optionals","title":"Defaults &amp; Optionals","text":"<p>When you combine defaults with optional types (<code>?</code>), you can choose whether the default should be <code>null</code> or something else:</p> <pre><code>fn format_price(amount: float, currency: str? = \"USD\") -&gt; str:\n    if currency == null:\n        return \"${amount:.2}\"\n    return \"{amount:.2} {currency}\"\n\nprint(format_price(19.99))           // Uses default \"USD\"\nprint(format_price(19.99, \"EUR\"))    // Uses provided \"EUR\"\nprint(format_price(19.99, null))     // Explicitly passes null\n</code></pre> <pre><code>19.99 USD\n19.99 EUR\n$19.99\n</code></pre> <p>With <code>str?</code> alone, omitting the parameter means it defaults to <code>null</code>. With <code>str? = \"USD\"</code>, you can provide a non-null default value, but callers can still explicitly pass <code>null</code> if they want.</p>"},{"location":"guide/type-annotations/#union-types","title":"Union Types","text":"<p>Sometimes a function can accept or return multiple different types. Union types express this with the <code>|</code> operator:</p> <pre><code>fn to_string(val: int|float|str) -&gt; str:\n    return str(val)\n\nprint(to_string(42))\nprint(to_string(3.14))\nprint(to_string(\"hello\"))\n</code></pre> <pre><code>42\n3.14\nhello\n</code></pre> <p>The <code>int|float|str</code> annotation means \"accepts an int, float, or string\" - any of these three types is valid.</p>"},{"location":"guide/type-annotations/#error-union-types","title":"Error Union Types","text":"<p>A common union pattern in Rad is combining <code>error</code> with another type to represent operations that might fail:</p> <pre><code>fn divide(a: float, b: float) -&gt; float|error:\n    if b == 0:\n        return error(\"Cannot divide by zero\")\n    return a / b\n\nresult = divide(10, 2)\nprint(result)  // 5\n</code></pre> <p>The <code>float|error</code> return type signals that this function returns either a float (on success) or an error value (on failure).</p> <p>Error Handling in Rad</p> <p>Rad has a comprehensive error handling model. We'll cover error handling in detail in a later section: Error Handling.</p>"},{"location":"guide/type-annotations/#advanced-types","title":"Advanced Types","text":"<p>Rad's type system includes several advanced features for expressing complex data structures and constraints.</p>"},{"location":"guide/type-annotations/#enum-types","title":"Enum Types","text":"<p>When a value should be restricted to specific strings, use enum types:</p> <pre><code>fn set_log_level(level: [\"debug\", \"info\", \"warn\", \"error\"]) -&gt; str:\n    return \"Log level set to: {level}\"\n\nprint(set_log_level(\"info\"))\n// set_log_level(\"trace\")  // Error: \"trace\" not in enum\n</code></pre> <pre><code>Log level set to: info\n</code></pre> <p>The <code>[\"debug\", \"info\", \"warn\", \"error\"]</code> annotation restricts the parameter to exactly these four string values. Any other string will cause a runtime type error.</p> <p>This is particularly useful for configuration options, status values, and other cases where only certain strings are valid:</p> <pre><code>fn create_connection(\n    host: str,\n    protocol: [\"http\", \"https\", \"ws\", \"wss\"] = \"https\"\n) -&gt; str:\n    return \"{protocol}://{host}\"\n\nurl = create_connection(\"api.example.com\")\nprint(url)\n</code></pre> <pre><code>https://api.example.com\n</code></pre>"},{"location":"guide/type-annotations/#structured-maps","title":"Structured Maps","text":"<p>For maps with specific named fields, use the struct syntax with quoted keys:</p> <pre><code>fn create_user(name: str, age: int, email: str) -&gt;\n        { \"name\": str, \"age\": int, \"email\": str, \"id\": int }:\n    return {\n        \"name\": name,\n        \"age\": age,\n        \"email\": email,\n        \"id\": rand_int(1000, 9999)\n    }\n\nuser = create_user(\"Alice\", 30, \"alice@example.com\")\nprint(user)\n</code></pre> <pre><code>{ \"name\": \"Alice\", \"age\": 30, \"email\": \"alice@example.com\", \"id\": 7234 }\n</code></pre> <p>The <code>{ \"name\": str, \"age\": int, \"email\": str, \"id\": int }</code> annotation describes a map with exactly these four fields, each with a specific type. Notice the quoted keys - this distinguishes named fields from the typed map syntax we saw earlier.</p>"},{"location":"guide/type-annotations/#optional-fields-in-structs","title":"Optional Fields in Structs","text":"<p>Fields can be marked as optional with <code>?</code>:</p> <pre><code>fn get_user_profile(id: int) -&gt;\n        { \"name\": str, \"age\": int, \"bio\"?: str, \"avatar\"?: str }:\n    // Fetch user... in this example, we'll return mock data\n    return {\n        \"name\": \"Bob\",\n        \"age\": 25,\n        \"bio\": \"Software engineer\"\n        // avatar field is omitted\n    }\n\nprofile = get_user_profile(123)\nprint(profile)\n</code></pre> <pre><code>{ \"name\": \"Bob\", \"age\": 25, \"bio\": \"Software engineer\" }\n</code></pre> <p>The <code>\"bio\"?: str</code> and <code>\"avatar\"?: str</code> fields are optional - the map might or might not contain them.</p>"},{"location":"guide/type-annotations/#nested-structures","title":"Nested Structures","text":"<p>Struct types can be nested for complex data:</p> <pre><code>fn fetch_article() -&gt; {\n    \"title\": str,\n    \"author\": { \"name\": str, \"id\": int },\n    \"metadata\": { \"views\": int, \"likes\": int },\n}:\n    return {\n        \"title\": \"Getting Started with Rad\",\n        \"author\": {\"name\": \"Alice\", \"id\": 1},\n        \"metadata\": {\"views\": 1234, \"likes\": 56}\n    }\n\narticle = fetch_article()\nprint(\"Article: {article.title} by {article.author.name}\")\nprint(\"Stats: {article.metadata.views} views, {article.metadata.likes} likes\")\n</code></pre> <pre><code>Article: Getting Started with Rad by Alice\nStats: 1234 views, 56 likes\n</code></pre>"},{"location":"guide/type-annotations/#function-types","title":"Function Types","text":"<p>Functions themselves can be typed, which is especially useful when passing functions as parameters:</p> <pre><code>fn apply_to_list(items: str[], transform: fn(str) -&gt; str) -&gt; str[]:\n    result = []\n    for item in items:\n        result += [transform(item)]\n    return result\n\nwords = [\"hello\", \"world\"]\nupper_words = apply_to_list(words, upper)\nprint(upper_words)\n</code></pre> <pre><code>[ \"HELLO\", \"WORLD\" ]\n</code></pre> <p>The <code>fn(str) -&gt; str</code> annotation describes a function that takes a string parameter and returns a string.</p> <p>Other examples of valid function type annotations:</p> <pre><code>fn() -&gt; int\nfn(str, str) -&gt; str\nfn(str[]) -&gt; void\n</code></pre>"},{"location":"guide/type-annotations/#variadic-and-named-parameters","title":"Variadic and Named Parameters","text":"<p>Type annotations work seamlessly with Rad's parameter patterns, as seen earlier in Functions.</p>"},{"location":"guide/type-annotations/#variadic-parameters","title":"Variadic Parameters","text":"<p>When a function accepts unlimited arguments, you can type the variadic parameter:</p> <pre><code>fn sum_all(*numbers: int) -&gt; int:\n    total = 0\n    for num in numbers:\n        total += num\n    return total\n\nresult = sum_all(1, 2, 3, 4, 5)\nprint(result)\n</code></pre> <pre><code>15\n</code></pre> <p>The <code>*numbers: int</code> annotation means \"zero or more integer arguments\". All arguments passed to this variadic parameter must be integers.</p>"},{"location":"guide/type-annotations/#named-only-parameters","title":"Named-Only Parameters","text":"<p>Named-only parameters (those after <code>*</code>) can also be typed:</p> <pre><code>fn format_text(\n    text: str,\n    *,\n    uppercase: bool = false,\n    prefix: str = \"\",\n    suffix: str = \"\"\n) -&gt; str:\n    result = prefix + text + suffix\n    return uppercase ? upper(result) : result\n\noutput = format_text(\"hello\", uppercase=true, prefix=\"&gt;&gt;&gt; \")\nprint(output)\n</code></pre> <pre><code>&gt;&gt;&gt; HELLO\n</code></pre>"},{"location":"guide/type-annotations/#combining-everything","title":"Combining Everything","text":"<p>Here's a function that combines positional, variadic, and named-only parameters with types:</p> <pre><code>fn create_report(\n    title: str,\n    *data_points: int|float,\n    *,\n    format: [\"text\", \"html\", \"json\"] = \"text\",\n    include_summary: bool = true\n) -&gt; str:\n    total = sum(data_points)\n    avg = total / len(data_points)\n\n    report = \"=== {title} ===\\n\"\n    report += \"Data: {data_points.join(', ')}\\n\"\n\n    if include_summary:\n        report += \"Total: {total}, Average: {avg:.2}\"\n\n    return report\n\noutput = create_report(\n    \"Q4 Sales\",\n    100, 150, 200, 175,\n    format=\"text\",\n    include_summary=true\n)\nprint(output)\n</code></pre> <pre><code>=== Q4 Sales ===\nData: 100, 150, 200, 175\nTotal: 625, Average: 156.25\n</code></pre> <p>This example demonstrates:</p> <ul> <li>A required positional parameter (<code>title: str</code>)</li> <li>A typed variadic parameter accepting multiple numeric values (<code>*data_points: int|float</code>)</li> <li>Named-only parameters with enum and boolean types</li> <li>A clear, self-documenting function signature</li> </ul>"},{"location":"guide/type-annotations/#summary","title":"Summary","text":"<p>Type annotations are an optional but powerful tool for keeping your Rad scripts maintainable and self-documenting, especially as they grow in complexity or get reused across projects.</p> <p>Key takeaways:</p> <ul> <li>Syntax: Parameter types use <code>param: &lt;type&gt;</code>, return types use <code>-&gt; &lt;type&gt;</code></li> <li>Benefits: Self-documenting code, runtime validation, better tooling support</li> <li>Primitive types: <code>str</code>, <code>int</code>, <code>float</code>, <code>bool</code> for basic values</li> <li>Special types: <code>void</code> (function returns nothing), <code>null</code> (only valid for optional types marked with <code>?</code>)</li> <li>Collection types:<ul> <li><code>T[]</code> for typed lists (e.g., <code>str[]</code>, <code>int[]</code>, <code>float[]</code>)</li> <li><code>{ &lt;key type&gt;: &lt;value type&gt; }</code> for typed maps (e.g., <code>{ str: int }</code>)</li> <li><code>list</code> and <code>map</code> for generic collections (any contents)</li> <li>Nested collections like <code>int[][]</code> and <code>{ str: str[] }</code></li> </ul> </li> <li>Optional types: <code>T?</code> for nullable values (e.g., <code>str?</code>, <code>int?</code>)</li> <li>Union types: <code>T|U</code> for multiple acceptable types (e.g., <code>int|float</code>, <code>str|list</code>)</li> <li>Advanced types:<ul> <li>Enums: <code>[\"value1\", \"value2\", \"value3\"]</code> for restricted string values</li> <li>Structs: <code>{ \"field1\": type1, \"field2\"?: type2 }</code> for structured maps with named fields (quoted keys) and optional fields</li> <li>Function types: <code>fn(&lt;param_type&gt;) -&gt; &lt;return_type&gt;</code> for function parameters and variables</li> <li>Nested structures: Complex combinations of the above</li> </ul> </li> <li>Special parameters: Work with variadic (<code>*param: &lt;type&gt;</code>) and named-only parameters</li> </ul> <p>Type annotations make your code clearer to both humans and tools, catching errors early and making your intentions explicit.</p>"},{"location":"guide/type-annotations/#next","title":"Next","text":"<p>We've briefly seen <code>error|T</code> union types in this section - functions that return either a value or an error.</p> <p>In the next section, we'll explore Rad's comprehensive error handling model in depth: Error Handling.</p>"},{"location":"migrations/v0.7/","title":"Migrating to Rad v0.7","text":"<p>Version 0.7 introduces a breaking change to for-loop syntax. This guide will help you update your scripts.</p>"},{"location":"migrations/v0.7/#breaking-change-for-loop-index-syntax","title":"Breaking Change: For-Loop Index Syntax","text":""},{"location":"migrations/v0.7/#what-changed","title":"What Changed","text":"<p>The old implicit index syntax\u2014where adding a second variable would make the first variable the index\u2014has been removed. This syntax was confusing because adding a variable changed the meaning of existing variables.</p>"},{"location":"migrations/v0.7/#old-syntax-no-longer-works","title":"Old Syntax (No Longer Works)","text":"<pre><code>// This no longer works:\nfor idx, item in items:\n    print(idx, item)\n\n// Also broken:\nfor i, name, age in zip(names, ages):\n    print(i, name, age)\n</code></pre>"},{"location":"migrations/v0.7/#new-syntax","title":"New Syntax","text":"<p>Use the <code>with &lt;identifier&gt;</code> clause to access loop context:</p> <pre><code>// New way to access index:\nfor item in items with loop:\n    print(loop.idx, item)\n\n// With zip:\nfor name, age in zip(names, ages) with loop:\n    print(loop.idx, name, age)\n</code></pre> <p>The context object provides:</p> <ul> <li><code>loop.idx</code> - Current iteration index (0-based)</li> <li><code>loop.src</code> - Immutable snapshot of the original collection</li> </ul>"},{"location":"migrations/v0.7/#migration-steps","title":"Migration Steps","text":"<ol> <li> <p>Find all for-loops with two or more variables</p> </li> <li> <p>Determine if the first variable is an index</p> </li> <li>If yes \u2192 use the <code>with loop</code> syntax</li> <li> <p>If no (it's unpacking nested lists) \u2192 no change needed</p> </li> <li> <p>Update the syntax</p> </li> </ol>"},{"location":"migrations/v0.7/#example-1-simple-index-access","title":"Example 1: Simple Index Access","text":"<pre><code>// Before\nfor idx, name in names:\n    print(idx, name)\n\n// After\nfor name in names with loop:\n    print(loop.idx, name)\n</code></pre>"},{"location":"migrations/v0.7/#example-2-with-zip","title":"Example 2: With zip","text":"<pre><code>// Before\nfor idx, name, age in zip(names, ages):\n    print(idx, name, age)\n\n// After\nfor name, age in zip(names, ages) with loop:\n    print(loop.idx, name, age)\n</code></pre>"},{"location":"migrations/v0.7/#example-3-unpacking-no-change-needed","title":"Example 3: Unpacking (No Change Needed)","text":"<pre><code>// This still works - unpacking nested lists\npairs = [[\"a\", 1], [\"b\", 2]]\nfor letter, number in pairs:\n    print(letter, number)\n\n// Can add context if you want the index too\nfor letter, number in pairs with loop:\n    print(loop.idx, letter, number)\n</code></pre>"},{"location":"migrations/v0.7/#example-4-map-iteration","title":"Example 4: Map Iteration","text":"<pre><code>// Before (if you had this pattern)\nfor idx, key in myMap:\n    print(idx, key)\n\n// After\nfor key in myMap with loop:\n    print(loop.idx, key)\n\n// Key-value iteration is unchanged\nfor key, value in myMap:\n    print(key, value)\n\n// With context\nfor key, value in myMap with loop:\n    print(loop.idx, key, value)\n</code></pre>"},{"location":"migrations/v0.7/#error-messages","title":"Error Messages","text":"<p>If Rad detects you might be using the old syntax, it will show a helpful error:</p> <pre><code>Error: Cannot unpack 'int' into 2 values\n\nNote: The for-loop syntax changed. It looks like you may be using the old syntax.\nOld: for idx, item in items:\nNew: for item in items with loop:\n         print(loop.idx, item)\n</code></pre>"},{"location":"migrations/v0.7/#why-this-change","title":"Why This Change?","text":"<p>The old syntax had several problems:</p> <ol> <li>Confusing: Adding a variable changed the meaning of the first variable</li> <li>Inconsistent: Didn't work well with <code>zip()</code> and unpacking</li> <li>Error-prone: Easy to accidentally shift variable meanings</li> </ol> <p>The new syntax is explicit, consistent, and works the same way in all contexts.</p>"},{"location":"migrations/v0.7/#bonus-rad-block-lambda-context","title":"Bonus: Rad Block Lambda Context","text":"<p>As part of this release, rad block <code>map</code> and <code>filter</code> lambdas can now accept an optional context parameter:</p> <pre><code>Population:\n    map fn(p, ctx) \"{p / sum(ctx.src) * 100:.1}%\"\n</code></pre> <p>The context provides:</p> <ul> <li><code>ctx.idx</code> - Current row index</li> <li><code>ctx.src</code> - Full column data (immutable snapshot)</li> <li><code>ctx.field</code> - Field name being transformed</li> </ul> <p>See the Rad Blocks guide for details.</p>"},{"location":"migrations/v0.8/","title":"Migrating to Rad v0.8","text":"<p>Version 0.8 removes the <code>get_default</code> function. This guide will help you update your scripts.</p>"},{"location":"migrations/v0.8/#breaking-change-get_default-removed","title":"Breaking Change: <code>get_default</code> Removed","text":""},{"location":"migrations/v0.8/#what-changed","title":"What Changed","text":"<p>The <code>get_default(map, key, default)</code> function has been removed. Use the <code>??</code> fallback operator instead.</p>"},{"location":"migrations/v0.8/#old-syntax-no-longer-works","title":"Old Syntax (No Longer Works)","text":"<pre><code>// These no longer work:\nvalue = get_default(config, \"timeout\", 30)\nvalue = config.get_default(\"timeout\", 30)\n</code></pre>"},{"location":"migrations/v0.8/#new-syntax","title":"New Syntax","text":"<pre><code>// Use the ?? operator:\nvalue = config[\"timeout\"] ?? 30\nvalue = config.timeout ?? 30\n</code></pre>"},{"location":"migrations/v0.8/#migration-steps","title":"Migration Steps","text":"<ol> <li>Find all uses of <code>get_default</code> in your scripts</li> <li>Replace with <code>??</code> syntax:</li> <li><code>get_default(m, \"key\", val)</code> becomes <code>m[\"key\"] ?? val</code></li> <li><code>m.get_default(\"key\", val)</code> becomes <code>m[\"key\"] ?? val</code> or <code>m.key ?? val</code></li> </ol>"},{"location":"migrations/v0.8/#example-1-basic-usage","title":"Example 1: Basic Usage","text":"<pre><code>// Before\ndata = {\"name\": \"Alice\"}\nname = get_default(data, \"name\", \"Unknown\")\ncity = get_default(data, \"city\", \"Unknown\")\n\n// After\ndata = {\"name\": \"Alice\"}\nname = data[\"name\"] ?? \"Unknown\"\ncity = data[\"city\"] ?? \"Unknown\"\n</code></pre>"},{"location":"migrations/v0.8/#example-2-ufcs-style","title":"Example 2: UFCS Style","text":"<pre><code>// Before\nstate = load_state()\ncount = state.get_default(\"count\", 0)\n\n// After\nstate = load_state()\ncount = state[\"count\"] ?? 0\n</code></pre>"},{"location":"migrations/v0.8/#example-3-chained-fallbacks","title":"Example 3: Chained Fallbacks","text":"<p>The <code>??</code> operator also supports chaining, which wasn't possible with <code>get_default</code>:</p> <pre><code>// Try multiple keys, fall back to default\nvalue = config[\"new_key\"] ?? config[\"old_key\"] ?? \"default\"\n</code></pre>"},{"location":"migrations/v0.8/#why-this-change","title":"Why This Change?","text":"<p>The <code>??</code> operator provides the same functionality with several advantages:</p> <ul> <li>More concise: <code>m[\"k\"] ?? d</code> vs <code>get_default(m, \"k\", d)</code></li> <li>Lazy evaluation: The default value is only evaluated if the key is missing</li> <li>Chainable: Multiple fallbacks can be chained together</li> <li>Familiar: Standard null-coalescing syntax from other languages</li> </ul>"},{"location":"migrations/v0.8/#error-messages","title":"Error Messages","text":"<p>If you run a script that still uses <code>get_default</code>, you'll see a helpful error:</p> <pre><code>Error at L3:1\n\n  get_default(m, \"b\", 0)\n  ^^^^^^^^^^^ Cannot invoke unknown function: get_default\n\nNote: get_default was removed. Use the ?? operator instead:\n  Old: get_default(map, \"key\", default)\n  New: map[\"key\"] ?? default\n\nSee: https://amterp.github.io/rad/migrations/v0.8/\n</code></pre>"},{"location":"migrations/v0.9/","title":"Migrating to Rad v0.9","text":"<p>Version 0.9 introduces changes to error handling operators and renames a built-in function. This guide covers what changed and how to update your scripts.</p>"},{"location":"migrations/v0.9/#breaking-change-get_stash_dir-renamed","title":"Breaking Change: <code>get_stash_dir</code> Renamed","text":""},{"location":"migrations/v0.9/#what-changed","title":"What Changed","text":"<p><code>get_stash_dir</code> was renamed to <code>get_stash_path</code> to better reflect its behavior - it returns a path (often to a file), not necessarily a directory.</p>"},{"location":"migrations/v0.9/#old-syntax-no-longer-works","title":"Old Syntax (No Longer Works)","text":"<pre><code>path = get_stash_dir()\npath = get_stash_dir(\"data/config.json\")\n</code></pre>"},{"location":"migrations/v0.9/#new-syntax","title":"New Syntax","text":"<pre><code>path = get_stash_path()\npath = get_stash_path(\"data/config.json\")\n</code></pre>"},{"location":"migrations/v0.9/#migration-steps","title":"Migration Steps","text":"<ol> <li>Find all uses of <code>get_stash_dir</code> in your scripts</li> <li>Replace with <code>get_stash_path</code> - the signature and behavior are identical</li> </ol>"},{"location":"migrations/v0.9/#breaking-change-now-fires-on-null","title":"Breaking Change: <code>??</code> Now Fires on Null","text":""},{"location":"migrations/v0.9/#what-changed_1","title":"What Changed","text":"<p><code>??</code> is now a true null-coalescing operator. It fires when the left side is null or an error, where previously it only fired on errors.</p>"},{"location":"migrations/v0.9/#before-v08","title":"Before (v0.8)","text":"<pre><code>m = {\"key\": null}\nprint(m[\"key\"] ?? \"fallback\")   // printed: null\nprint(null ?? \"default\")         // printed: null\n</code></pre>"},{"location":"migrations/v0.9/#after-v09","title":"After (v0.9)","text":"<pre><code>m = {\"key\": null}\nprint(m[\"key\"] ?? \"fallback\")   // prints: fallback\nprint(null ?? \"default\")         // prints: default\n</code></pre>"},{"location":"migrations/v0.9/#why","title":"Why","text":"<p>This aligns <code>??</code> with developer expectations from JS/Kotlin/Swift where <code>??</code> is a null-coalescing operator. The old error-only behavior is now available via the new <code>catch</code> operator (see below).</p>"},{"location":"migrations/v0.9/#migration","title":"Migration","text":"<p>If you relied on null passing through <code>??</code>, use <code>catch</code> instead:</p> <pre><code>// If you want error-only catching (old behavior), use catch:\nresult = maybe_error_value catch \"default\"\n</code></pre>"},{"location":"migrations/v0.9/#new-catch-operator","title":"New: <code>catch</code> Operator","text":"<p>The <code>catch</code> operator provides the old <code>??</code> error-only behavior as an inline expression. It catches errors but lets null values pass through.</p> <pre><code>count = parse_int(input_str) catch 0\ndata = parse_json(raw) catch {}\n</code></pre> <p>This is distinct from the <code>catch:</code> block syntax. The operator form is an inline expression; <code>catch:</code> is a block attached to statements.</p>"},{"location":"migrations/v0.9/#breaking-change-strict-concatenation","title":"Breaking Change: Strict <code>+</code> Concatenation","text":""},{"location":"migrations/v0.9/#what-changed_2","title":"What Changed","text":"<p>The <code>+</code> operator no longer implicitly converts <code>int</code>, <code>float</code>, or <code>bool</code> to strings. Both operands must be the same type (with the exception that errors behave like strings for concatenation).</p>"},{"location":"migrations/v0.9/#before-v08_1","title":"Before (v0.8)","text":"<pre><code>print(\"count: \" + 5)       // printed: count: 5\nprint(\"pi: \" + 3.14)       // printed: pi: 3.14\nprint(\"flag: \" + true)     // printed: flag: true\n\nerr = error(\"oops\")\nprint(err + 123)            // printed: oops123\n</code></pre>"},{"location":"migrations/v0.9/#after-v09_1","title":"After (v0.9)","text":"<pre><code>print(\"count: \" + 5)       // error: RAD30002\nprint(\"pi: \" + 3.14)       // error: RAD30002\nprint(\"flag: \" + true)     // error: RAD30002\n\nerr = error(\"oops\")\nprint(err + 123)            // error: RAD30002\n</code></pre>"},{"location":"migrations/v0.9/#why_1","title":"Why","text":"<p>Implicit coercion was asymmetric (<code>\"hi\" + 5</code> worked, but <code>5 + \"hi\"</code> errored) and used a different conversion path from string interpolation. Making <code>+</code> strict catches type bugs at the point of error rather than silently producing unexpected strings.</p>"},{"location":"migrations/v0.9/#migration_1","title":"Migration","text":"<p>Use interpolation (preferred) or <code>str()</code> for explicit conversion:</p> <pre><code>// Interpolation - handles any type, recommended\nprint(\"count: {5}\")\nprint(\"pi: {3.14}\")\n\n// Explicit conversion with str()\nprint(\"count: \" + str(5))\nprint(\"pi: \" + str(3.14))\n</code></pre> <p>Note: errors still behave like strings for concatenation (<code>\"s\" + error(\"e\")</code>, <code>error(\"e\") + \"s\"</code>, and <code>error(\"a\") + error(\"b\")</code> all work).</p>"},{"location":"migrations/v0.9/#error-messages","title":"Error Messages","text":"<p>If you run a script that still uses <code>get_stash_dir</code>, you'll see a helpful error:</p> <pre><code>error: Cannot invoke unknown function: get_stash_dir\n\n  hint: get_stash_dir was renamed to get_stash_path.\n  See: https://amterp.github.io/rad/migrations/v0.9/\n</code></pre>"},{"location":"reference/functions/","title":"Functions","text":"<p>This page aims to concisely document all in-built Rad functions.</p>"},{"location":"reference/functions/#how-to-read-this-document","title":"How to Read This Document","text":""},{"location":"reference/functions/#function-signatures","title":"Function Signatures","text":"<p>You'll see notation like this for function signatures (below are not real functions in Rad; just examples):</p> <pre><code>greet(name: str, times: int = 10) -&gt; string\n</code></pre> <p>This means the function <code>greet</code> takes one required string argument <code>name</code>, and an optional int argument <code>times</code> which defaults to 10 if not specified. It returns a string.</p> <pre><code>greet_many(names: list[string] | ...string) -&gt; none\n</code></pre> <p>This means that <code>greet_many</code> can be called in two ways: either with a single argument that is a list of strings, or <code>|</code> a variable number of string arguments. In both cases, the function returns nothing.</p> <pre><code>do_something(input: any, log: string?) -&gt; any, error?!\n</code></pre> <p>This means the function <code>do_something</code> takes a required argument <code>input</code> which can be of any type. It also has an optional argument <code>log</code> which will default to <code>null</code> if left unspecified.</p> <p>The values it returns depends on how the function is called. If it's being assigned to two variables e.g.</p> <pre><code>foo, bar = do_something(myvar)\n</code></pre> <p>then it will return some <code>any</code> value for <code>foo</code>, and it returns a nullable <code>error</code> for <code>bar</code>.</p> <p>The exclamation point <code>!</code> signifies that, if the call is only assigned to one variable e.g.</p> <pre><code>foo = do_something(myvar)\n</code></pre> <p>and the function fails i.e. would return a non-<code>null</code> <code>error</code> value, then it will instead panic and exit the script with said error.</p>"},{"location":"reference/functions/#error","title":"<code>error</code>","text":"<p><code>error</code> may be referenced as a return type for some functions. <code>error</code> is really a <code>map</code> with the following keys:</p> <ul> <li><code>code: string</code> - An error code (e.g. <code>RAD20003</code>). Use <code>rad explain &lt;code&gt;</code> to learn more.</li> <li><code>msg: string</code> - A description of the error.</li> </ul> <p>Lastly, you may also see <code>number</code> referenced as a type -- this just means <code>int | float</code>, i.e. any numeric type.</p>"},{"location":"reference/functions/#output","title":"Output","text":""},{"location":"reference/functions/#print","title":"print","text":"<p>Prints zero or more items to stdout, separated by a delimiter.</p> <pre><code>print(*_items: any, *, sep: str = \" \", end: str = \"\\n\") -&gt; void\n</code></pre> <pre><code>print(\"Hello!\")                    // -&gt; Hello!\nprint()                            // -&gt; (just newline)\nprint(\"Hello\", \"world\")            // -&gt; Hello world\nprint(1, 2, 3, sep=\", \")           // -&gt; 1, 2, 3\nprint(\"No newline\", end=\"\")        // -&gt; No newline\n</code></pre>"},{"location":"reference/functions/#print_err","title":"print_err","text":"<p>Behaves like <code>print</code> but outputs to stderr instead of stdout.</p> <pre><code>print_err(*_items: any, *, sep: str = \" \", end: str = \"\\n\") -&gt; void\n</code></pre>"},{"location":"reference/functions/#pprint","title":"pprint","text":"<p>Pretty prints data in JSON format with indentation and colors.</p> <pre><code>pprint(_item: any?) -&gt; void\n</code></pre> <pre><code>item = { \"name\": \"Alice\", \"age\": 30 }\npprint(item)\n// Output:\n// {\n//   \"name\": \"Alice\", \n//   \"age\": 30\n// }\n</code></pre>"},{"location":"reference/functions/#debug","title":"debug","text":"<p>Behaves like <code>print</code> but only outputs when debug mode is enabled via <code>--debug</code> flag.</p> <pre><code>debug(*_items: any, *, sep: str = \" \", end: str = \"\\n\") -&gt; void\n</code></pre>"},{"location":"reference/functions/#misc","title":"Misc","text":""},{"location":"reference/functions/#sleep","title":"sleep","text":"<p>Pauses execution for the specified duration.</p> <pre><code>sleep(_duration: int|float|str, *, title: str?) -&gt; void\n</code></pre> <p>Integer and float values are treated as seconds. String values support Go duration format like \"2h45m\", \"1.5s\", \"500ms\". If <code>title</code> is provided, it's printed before sleeping.</p> <p>Duration string suffixes:</p> Suffix Description <code>h</code> Hours <code>m</code> Minutes <code>s</code> Seconds <code>ms</code> Milliseconds <code>us</code> or <code>\u00b5s</code> Microseconds <code>ns</code> Nanoseconds <p>Examples:</p> <pre><code>sleep(2.5)              // -&gt; Sleep for 2.5 seconds\nsleep(\"1h30m\")          // -&gt; Sleep for 1 hour 30 minutes  \nsleep(\"500ms\")          // -&gt; Sleep for 500 milliseconds\nsleep(5, title=\"Waiting...\") // -&gt; Prints \"Waiting...\" then sleeps 5 seconds\n</code></pre>"},{"location":"reference/functions/#len","title":"len","text":"<p>Returns the length of a string, list, or map.</p> <pre><code>len(input: str|list|map) -&gt; int\n</code></pre> <pre><code>len(\"hello\")        // -&gt; 5\nlen([1, 2, 3, 4])   // -&gt; 4\nlen({\"a\": 1, \"b\": 2}) // -&gt; 2\n</code></pre>"},{"location":"reference/functions/#range","title":"range","text":"<p>Generates a list of numbers in a specified range. Useful in for loops.</p> <pre><code>range(_arg1: float|int, _arg2: float?|int?, _step: float|int = 1) -&gt; list[float|int]\n</code></pre> <p>Single argument generates 0 to <code>_arg1</code> (exclusive). Two arguments generate <code>_arg1</code> to <code>_arg2</code> (exclusive). Step cannot be zero. Returns float list if any argument is float, otherwise int list.</p> <p>Examples:</p> <pre><code>range(5)            // -&gt; [0, 1, 2, 3, 4]\nrange(2, 5)         // -&gt; [2, 3, 4]\nrange(0.5, 3)       // -&gt; [0.5, 1.5, 2.5]\nrange(10, 5, -2)    // -&gt; [10, 8, 6]\n</code></pre>"},{"location":"reference/functions/#join","title":"join","text":"<p>Joins a list into a string with separator, prefix, and suffix.</p> <pre><code>join(_list: list, *, sep: str = \"\", prefix: str = \"\", suffix: str = \"\") -&gt; str\n</code></pre> <pre><code>join([1, 2, 3], sep=\", \")           // -&gt; \"1, 2, 3\"\njoin([\"a\", \"b\"], prefix=\"[\", suffix=\"]\")  // -&gt; \"[ab]\"\njoin([\"x\", \"y\", \"z\"], sep=\"-\", prefix=\"(\", suffix=\")\")  // -&gt; \"(x-y-z)\"\n</code></pre>"},{"location":"reference/functions/#zip","title":"zip","text":"<p>Combines multiple lists into a list of lists, pairing elements by index.</p> <pre><code>zip(*lists: list, *, strict: bool = false, fill: any?) -&gt; list[list]|error\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>*lists</code> <code>list</code> Variable number of lists to zip together <code>strict</code> <code>bool = false</code> If true, error on different list lengths <code>fill</code> <code>any?</code> Value to fill shorter lists (optional) <ul> <li>By default, truncates to the shortest list length</li> <li>Cannot use <code>strict=true</code> with <code>fill</code> parameter (mutually exclusive)</li> <li>Returns error if <code>strict=true</code> and lists have different lengths</li> </ul> <p>Examples:</p> <pre><code>// Basic usage\nzip([1, 2, 3], [\"a\", \"b\", \"c\"])           // -&gt; [[1, \"a\"], [2, \"b\"], [3, \"c\"]]\nzip([1, 2, 3, 4], [\"a\", \"b\"])             // -&gt; [[1, \"a\"], [2, \"b\"]]\n\n// With fill value for unequal lengths\nzip([1, 2, 3, 4], [\"a\", \"b\"], fill=\"-\")   // -&gt; [[1, \"a\"], [2, \"b\"], [3, \"-\"], [4, \"-\"]]\n\n// Strict mode (errors on length mismatch)  \nzip([1, 2, 3], [\"a\", \"b\"], strict=true)   // -&gt; Error: Lists must have the same length\n</code></pre>"},{"location":"reference/functions/#unique","title":"unique","text":"<p>Returns a list with duplicate values removed, preserving first occurrence order.</p> <pre><code>unique(_list: list[any]) -&gt; list[any]\n</code></pre> <pre><code>unique([2, 1, 2, 3, 1, 3, 4])  // -&gt; [2, 1, 3, 4]\nunique([\"a\", \"b\", \"a\", \"c\"])    // -&gt; [\"a\", \"b\", \"c\"]\n</code></pre>"},{"location":"reference/functions/#sort","title":"sort","text":"<p>Sorts a list or string. When multiple lists are provided, performs parallel sorting where additional lists are reordered to match the primary list's sort permutation.</p> <pre><code>sort(_primary: list|str) -&gt; list|str\nsort(_primary: list|str, *_others: list, *, reverse: bool = false) -&gt; list[list]\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>_primary</code> <code>list\\|str</code> Primary data to sort (determines sort order) <code>*_others</code> <code>list</code> Additional lists to reorder in parallel <code>reverse</code> <code>bool = false</code> Sort in descending order <p>Parallel Sorting Behavior:</p> <ul> <li>The first list (<code>_primary</code>) determines the sort order</li> <li>All other lists are reordered to match the same permutation</li> <li>All lists must be the same length</li> <li>Returns a list containing all sorted lists: <code>[sorted_primary, sorted_other1, sorted_other2, ...]</code></li> </ul> <p>Examples:</p> <pre><code>// Basic sorting\nsort([3, 4, 2, 1])                    // -&gt; [1, 2, 3, 4]\nsort([3, 4, 2, 1], reverse=true)      // -&gt; [4, 3, 2, 1]\nsort([3, 4, \"2\", 1, true])            // -&gt; [true, 1, 3, 4, \"2\"]\nsort(\"hello\")                         // -&gt; \"ehllo\"\n\n// Parallel sorting\nnumbers = [2, 1, 4, 3]\nletters = [\"a\", \"b\", \"c\", \"d\"] \nbools = [true, false, true, false]\nsorted_nums, sorted_letters, sorted_bools = sort(numbers, letters, bools)\n// -&gt; [1, 2, 3, 4], [\"b\", \"a\", \"d\", \"c\"], [false, true, false, true]\n</code></pre>"},{"location":"reference/functions/#type_of","title":"type_of","text":"<p>Returns the type of a value as a string.</p> <pre><code>type_of(_var: any) -&gt; str\n</code></pre> <pre><code>type_of(\"hi\")    // -&gt; \"str\"\ntype_of([2])     // -&gt; \"list\" \ntype_of(42)      // -&gt; \"int\"\ntype_of(3.14)    // -&gt; \"float\"\ntype_of({\"a\": 1}) // -&gt; \"map\"\n</code></pre>"},{"location":"reference/functions/#str","title":"str","text":"<p>Converts any value to a string representation. Useful when you need to concatenate non-string values with <code>+</code>, though interpolation (<code>\"value: {x}\"</code>) is generally preferred.</p> <pre><code>str(_var: any) -&gt; str\n</code></pre> <pre><code>str(42)        // -&gt; \"42\"\nstr(3.14)      // -&gt; \"3.14\"\nstr([1, 2])    // -&gt; \"[1, 2]\"\nstr(true)      // -&gt; \"true\"\n</code></pre>"},{"location":"reference/functions/#int","title":"int","text":"<p>Converts a value to an integer. Does not work on strings - use <code>parse_int</code> for string parsing.</p> <pre><code>int(_var: any) -&gt; int|error\n</code></pre> <pre><code>int(3.14)     // -&gt; 3\nint(true)     // -&gt; 1\nint(false)    // -&gt; 0\nint(\"42\")     // -&gt; Error: cannot convert string\n</code></pre>"},{"location":"reference/functions/#float","title":"float","text":"<p>Converts a value to a float. Does not work on strings - use <code>parse_float</code> for string parsing.</p> <pre><code>float(_var: any) -&gt; float|error\n</code></pre> <pre><code>float(42)      // -&gt; 42.0\nfloat(true)    // -&gt; 1.0\nfloat(false)   // -&gt; 0.0  \nfloat(\"3.14\")  // -&gt; Error: cannot convert string\n</code></pre>"},{"location":"reference/functions/#is_defined","title":"is_defined","text":"<p>Checks if a variable with the given name exists in the current scope.</p> <pre><code>is_defined(_var: str) -&gt; bool\n</code></pre> <pre><code>name = \"Alice\"\nis_defined(\"name\")     // -&gt; true\nis_defined(\"age\")      // -&gt; false\n</code></pre>"},{"location":"reference/functions/#map","title":"map","text":"<p>Applies a function to every element of a list or entry of a map.</p> <pre><code>map(_coll: list|map, _fn: fn(any) -&gt; any | fn(any, any) -&gt; any) -&gt; list|map\n</code></pre> <p>For lists, function receives <code>fn(value)</code>. For maps, function receives <code>fn(key, value)</code>.</p> <p>Examples:</p> <pre><code>map([1, 2, 3], fn(x) x * 2)              // -&gt; [2, 4, 6]\nmap({\"a\": 1, \"b\": 2}, fn(k, v) v * 10)   // -&gt; {\"a\": 10, \"b\": 20}\n</code></pre>"},{"location":"reference/functions/#filter","title":"filter","text":"<p>Applies a predicate function to filter elements of a list or map. Keeps only elements where the function returns true.</p> <pre><code>filter(_coll: list|map, _fn: fn(any) -&gt; bool | fn(any, any) -&gt; bool) -&gt; list|map\n</code></pre> <p>For lists, function receives <code>fn(value)</code>. For maps, function receives <code>fn(key, value)</code>.</p> <p>Examples:</p> <pre><code>filter([1, 2, 3, 4], fn(x) x % 2 == 0)      // -&gt; [2, 4]\nfilter({\"a\": 1, \"b\": 2}, fn(k, v) v &gt; 1)    // -&gt; {\"b\": 2}\n</code></pre>"},{"location":"reference/functions/#flat_map","title":"flat_map","text":"<p>Flattens a list of lists, or applies a mapping function that returns lists and flattens the results.</p> <pre><code>flat_map(_coll: list|map, _fn: any?) -&gt; list\n</code></pre> <p>For lists without function: All elements must be lists. Flattens one level.</p> <p>With function: The function must return a list. Results are flattened.</p> <p>For lists, function receives <code>fn(value)</code>. For maps, function receives <code>fn(key, value)</code> and is required.</p> <p>Examples:</p> <pre><code>// Flatten list of lists (all elements must be lists)\n[[1, 2], [3, 4]].flat_map()              // -&gt; [1, 2, 3, 4]\n[[], [1], []].flat_map()                 // -&gt; [1]\n\n// Only one level\n[[[1]], [[2]]].flat_map()                // -&gt; [[1], [2]]\n\n// Map then flatten (function must return a list)\n[\"a-b\", \"c-d\"].flat_map(fn(e) e.split(\"-\"))  // -&gt; [\"a\", \"b\", \"c\", \"d\"]\n[1, 2].flat_map(fn(x) [x, x * 10])           // -&gt; [1, 10, 2, 20]\n[1, 2].flat_map(fn(x) range(x))              // -&gt; [0, 0, 1]\n\n// Map collection - function required, must return list\n{\"a\": [1, 2], \"b\": [3, 4]}.flat_map(fn(k, v) v)  // -&gt; [1, 2, 3, 4]\n{\"a\": 1, \"b\": 2}.flat_map(fn(k, v) [k, v])       // -&gt; [\"a\", 1, \"b\", 2]\n\n// Errors:\n// [1, [2], 3].flat_map()           // Error: element 0 is not a list\n// [1, 2].flat_map(fn(x) x * 2)     // Error: function must return a list\n</code></pre>"},{"location":"reference/functions/#load","title":"load","text":"<p>Loads a value into a map using lazy evaluation. If key exists, returns cached value; otherwise runs loader function.</p> <pre><code>load(_map: map, _key: any, _loader: fn() -&gt; any) -&gt; any|error\nload(_map: map, _key: any, _loader: fn() -&gt; any, *, reload: bool = false) -&gt; any|error\nload(_map: map, _key: any, _loader: fn() -&gt; any, *, override: any?) -&gt; any|error\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>_map</code> <code>map</code> Map to store/retrieve cached values <code>_key</code> <code>any</code> Key to lookup in the map <code>_loader</code> <code>fn() -&gt; any</code> Function to call if key doesn't exist <code>reload</code> <code>bool = false</code> Force reload even if key exists <code>override</code> <code>any?</code> Use this value instead of calling loader <p>If key doesn't exist, <code>_loader</code> is called and result is cached. Cannot use <code>reload=true</code> with <code>override</code> (mutually exclusive).</p> <p>Examples:</p> <pre><code>cache = {}\nload(cache, \"data\", fn() expensive_calculation())    // -&gt; Runs loader, caches result\nload(cache, \"data\", fn() expensive_calculation())    // -&gt; Returns cached value\n\n// Force reload\nload(cache, \"data\", fn() new_calculation(), reload=true)\n\n// Override with specific value  \nload(cache, \"data\", fn() ignored(), override=\"forced\")\n</code></pre>"},{"location":"reference/functions/#input","title":"Input","text":""},{"location":"reference/functions/#input_1","title":"input","text":"<p>Gets a line of text input from the user with optional prompt, default, hint, and secret mode.</p> <pre><code>input(prompt: str = \"&gt; \") -&gt; str|error\ninput(prompt: str = \"&gt; \", *, hint: str = \"\", default: str = \"\", secret: bool = false) -&gt; str|error\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>prompt</code> <code>str = \"&gt; \"</code> The text prompt to display to the user <code>hint</code> <code>str = \"\"</code> Placeholder text shown in input field <code>default</code> <code>str = \"\"</code> Default value if user doesn't enter anything <code>secret</code> <code>bool = false</code> If true, hides input (useful for passwords) <p>If <code>secret</code> is true, input is hidden (useful for passwords). The <code>hint</code> parameter has no effect when <code>secret</code> is enabled.</p> <p>Examples:</p> <pre><code>// Basic input\nname = input(\"What's your name? \")                    // -&gt; Prompts and waits for input\n\n// With default value\ncolor = input(\"Favorite color? \", default=\"blue\")     // -&gt; Returns \"blue\" if user presses enter\n\n// With hint text\nemail = input(\"Email: \", hint=\"user@example.com\")     // -&gt; Shows placeholder text\n\n// Hidden input for passwords\npassword = input(\"Password: \", secret=true)           // -&gt; Hides typed characters\n</code></pre>"},{"location":"reference/functions/#confirm","title":"confirm","text":"<p>Gets a boolean confirmation from the user (y/n prompt). Accepts \"y\", \"yes\", or Enter (empty input) as confirmation.</p> <pre><code>confirm(prompt: str = \"Confirm? [Y/n] &gt; \") -&gt; bool|error\n</code></pre> <pre><code>if confirm():                        // -&gt; Uses default \"Confirm? [Y/n] &gt; \" prompt\n    print(\"Confirmed!\")\n\nif confirm(\"Delete file? [Y/n] \"):   // -&gt; Custom prompt\n    print(\"File deleted\")\n</code></pre>"},{"location":"reference/functions/#parsing","title":"Parsing","text":""},{"location":"reference/functions/#parse_int","title":"parse_int","text":"<p>Parses a string to an integer.</p> <pre><code>parse_int(_str: str) -&gt; int|error\n</code></pre> <pre><code>parse_int(\"42\")    // -&gt; 42\nparse_int(\"3.14\")  // -&gt; Error: invalid syntax\nparse_int(\"abc\")   // -&gt; Error: invalid syntax\n</code></pre>"},{"location":"reference/functions/#parse_float","title":"parse_float","text":"<p>Parses a string to a float.</p> <pre><code>parse_float(_str: str) -&gt; float|error\n</code></pre> <pre><code>parse_float(\"3.14\")  // -&gt; 3.14\nparse_float(\"42\")    // -&gt; 42.0\nparse_float(\"abc\")   // -&gt; Error: invalid syntax\n</code></pre>"},{"location":"reference/functions/#parse_json","title":"parse_json","text":"<p>Parses a JSON string into Rad data structures.</p> <pre><code>parse_json(_str: str) -&gt; any|error\n</code></pre> <pre><code>parse_json('{\"name\": \"Alice\", \"age\": 30}')  // -&gt; {\"name\": \"Alice\", \"age\": 30}\nparse_json('[1, 2, 3]')                     // -&gt; [1, 2, 3]\nparse_json('invalid json')                  // -&gt; Error: invalid JSON\n</code></pre>"},{"location":"reference/functions/#text","title":"Text","text":""},{"location":"reference/functions/#upper","title":"upper","text":"<p>Converts a string to uppercase. Preserves color attributes.</p> <pre><code>upper(_val: str) -&gt; str\n</code></pre> <pre><code>upper(\"hello\")          // -&gt; \"HELLO\"\nupper(\"Hello World\")    // -&gt; \"HELLO WORLD\"\n</code></pre>"},{"location":"reference/functions/#lower","title":"lower","text":"<p>Converts a string to lowercase. Preserves color attributes.</p> <pre><code>lower(_val: str) -&gt; str\n</code></pre> <pre><code>lower(\"HELLO\")          // -&gt; \"hello\"\nlower(\"Hello World\")    // -&gt; \"hello world\"\n</code></pre>"},{"location":"reference/functions/#replace","title":"replace","text":"<p>Replaces text using regex patterns. Does not preserve string color attributes.</p> <pre><code>replace(_original: str, _find: str, _replace: str) -&gt; str\n</code></pre> <p>The <code>_find</code> parameter is a regex pattern. The <code>_replace</code> parameter can use regex capture groups like <code>$1</code>.</p> <p>Examples:</p> <pre><code>replace(\"hello world\", \"world\", \"Rad\")        // -&gt; \"hello Rad\"\nreplace(\"Name: Charlie Brown\", \"Charlie (.*)\", \"Alice $1\")  // -&gt; \"Name: Alice Brown\"\nreplace(\"abc123def\", \"\\\\d+\", \"XXX\")           // -&gt; \"abcXXXdef\"\n</code></pre>"},{"location":"reference/functions/#starts_with","title":"starts_with","text":"<p>Checks if a string starts with a given substring.</p> <pre><code>starts_with(_val: str, _start: str) -&gt; bool\n</code></pre> <pre><code>starts_with(\"hello world\", \"hello\")  // -&gt; true\nstarts_with(\"hello world\", \"world\")  // -&gt; false\n</code></pre>"},{"location":"reference/functions/#ends_with","title":"ends_with","text":"<p>Checks if a string ends with a given substring.</p> <pre><code>ends_with(_val: str, _end: str) -&gt; bool\n</code></pre> <pre><code>ends_with(\"hello world\", \"world\")    // -&gt; true\nends_with(\"hello world\", \"hello\")    // -&gt; false\n</code></pre>"},{"location":"reference/functions/#truncate","title":"truncate","text":"<p>Truncates a string to a maximum length, adding an ellipsis if truncated. Requires length of at least 1.</p> <pre><code>truncate(_str: str, _len: int) -&gt; str|error\n</code></pre> <pre><code>truncate(\"hello world\", 8)   // -&gt; \"hello w\u2026\"\ntruncate(\"short\", 10)        // -&gt; \"short\" (no truncation needed)\ntruncate(\"test\", 0)          // -&gt; Error: Requires at least 1\n</code></pre>"},{"location":"reference/functions/#split","title":"split","text":"<p>Splits a string using regex pattern as delimiter. Does not preserve string color attributes.</p> <pre><code>split(_val: str, _sep: str) -&gt; list[str]\n</code></pre> <p>The <code>_sep</code> parameter is treated as a regex pattern if valid, otherwise as literal string.</p> <pre><code>split(\"a,b,c\", \",\")            // -&gt; [\"a\", \"b\", \"c\"]\nsplit(\"word1 word2\", \"\\\\s+\")   // -&gt; [\"word1\", \"word2\"]\nsplit(\"abc123def\", \"\\\\d+\")     // -&gt; [\"abc\", \"def\"]\n</code></pre>"},{"location":"reference/functions/#split_lines","title":"split_lines","text":"<p>Splits a string by line endings. Handles all common styles: <code>\\n</code> (Unix), <code>\\r\\n</code> (Windows), and <code>\\r</code> (legacy Mac).</p> <pre><code>split_lines(_val: str) -&gt; list[str]\n</code></pre> <p>Use this instead of <code>split(\"\\n\")</code> when processing text that may come from different platforms.</p> <pre><code>\"a\\nb\\nc\".split_lines()          // -&gt; [\"a\", \"b\", \"c\"]\ncontent = read_file(\"data.txt\").content\nfor line in content.split_lines():\n    print(line)\n</code></pre> <p>Note</p> <p>A trailing line ending produces an empty string as the last element (same as <code>split()</code>). Trim first if unwanted: <code>content.trim().split_lines()</code>.</p>"},{"location":"reference/functions/#count","title":"count","text":"<p>Counts the number of non-overlapping instances of substring in string.</p> <pre><code>count(_str: str, _substr: str) -&gt; int\n</code></pre> <pre><code>count(\"hello world\", \"l\")     // -&gt; 3\ncount(\"banana\", \"na\")         // -&gt; 2\ncount(\"test\", \"xyz\")          // -&gt; 0\n</code></pre>"},{"location":"reference/functions/#index_of","title":"index_of","text":"<p>Finds the index of a target value within a string or list. Returns <code>null</code> if not found.</p> <pre><code>index_of(_subject: str|list, _target: any, *, n: int = 0, start: int = 0) -&gt; int?\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>_subject</code> <code>str\\|list</code> The string or list to search within <code>_target</code> <code>any</code> The value to search for <code>n</code> <code>int = 0</code> Which occurrence to find (0=first, 1=second, -1=last) <code>start</code> <code>int = 0</code> Position to start searching from <p>Examples:</p> <pre><code>// String search\n\"hello world hello\".index_of(\"hello\")           // -&gt; 0\n\"hello world hello\".index_of(\"hello\", n=1)      // -&gt; 12\n\"hello world hello\".index_of(\"hello\", n=-1)     // -&gt; 12\n\"hello\".index_of(\"xyz\")                         // -&gt; null\n\"hello\".index_of(\"xyz\") ?? -1                   // -&gt; -1\n\"hello\".index_of(\"\")                             // -&gt; null (empty target)\n\n// List search\n[\"a\", \"b\", \"c\", \"b\", \"a\"].index_of(\"b\")        // -&gt; 1\n[\"a\", \"b\", \"c\", \"b\", \"a\"].index_of(\"b\", n=-1)  // -&gt; 3\n[1, 2, 3].index_of(99)                          // -&gt; null\n</code></pre>"},{"location":"reference/functions/#trim","title":"trim","text":"<p>Strips all matching characters from both ends of a string. Preserves color attributes.</p> <pre><code>trim(_subject: str, _chars: str = \" \\t\\n\") -&gt; str\n</code></pre> <pre><code>trim(\"  hello  \")            // -&gt; \"hello\"\ntrim(\"***hello***\", \"*\")     // -&gt; \"hello\"\ntrim(\"abcHELLOabc\", \"abc\")   // -&gt; \"HELLO\"\n</code></pre>"},{"location":"reference/functions/#trim_left","title":"trim_left","text":"<p>Strips all matching characters from the start of a string. Preserves color attributes.</p> <pre><code>trim_left(_subject: str, _chars: str = \" \\t\\n\") -&gt; str\n</code></pre> <pre><code>trim_left(\"  hello  \")          // -&gt; \"hello  \"\ntrim_left(\"***hello***\", \"*\")   // -&gt; \"hello***\"\ntrim_left(\"aaabbb\", \"a\")        // -&gt; \"bbb\"\n</code></pre>"},{"location":"reference/functions/#trim_right","title":"trim_right","text":"<p>Strips all matching characters from the end of a string. Preserves color attributes.</p> <pre><code>trim_right(_subject: str, _chars: str = \" \\t\\n\") -&gt; str\n</code></pre> <pre><code>trim_right(\"  hello  \")         // -&gt; \"  hello\"\ntrim_right(\"***hello***\", \"*\")  // -&gt; \"***hello\"\ntrim_right(\"aaabbb\", \"b\")       // -&gt; \"aaa\"\n</code></pre>"},{"location":"reference/functions/#trim_prefix","title":"trim_prefix","text":"<p>Removes a literal prefix from the start of a string (once). Preserves color attributes.</p> <pre><code>trim_prefix(_subject: str, _prefix: str) -&gt; str\n</code></pre> <pre><code>trim_prefix(\"hello world\", \"hello \")  // -&gt; \"world\"\ntrim_prefix(\"aaabbb\", \"a\")            // -&gt; \"aabbb\" (one 'a' removed)\ntrim_prefix(\"test\", \"x\")              // -&gt; \"test\" (no match)\n</code></pre>"},{"location":"reference/functions/#trim_suffix","title":"trim_suffix","text":"<p>Removes a literal suffix from the end of a string (once). Preserves color attributes.</p> <pre><code>trim_suffix(_subject: str, _suffix: str) -&gt; str\n</code></pre> <pre><code>trim_suffix(\"hello world\", \" world\")  // -&gt; \"hello\"\ntrim_suffix(\"aaabbb\", \"b\")            // -&gt; \"aaabb\" (one 'b' removed)\ntrim_suffix(\"test\", \"x\")              // -&gt; \"test\" (no match)\n</code></pre>"},{"location":"reference/functions/#reverse","title":"reverse","text":"<p>Reverses a string or list. Preserves color attributes for strings.</p> <pre><code>reverse(_val: str|list) -&gt; str|list\n</code></pre> <pre><code>reverse(\"hello\")           // -&gt; \"olleh\"\nreverse([1, 2, 3, 4])      // -&gt; [4, 3, 2, 1]\nreverse(\"racecar\")         // -&gt; \"racecar\"\n</code></pre>"},{"location":"reference/functions/#hyperlink","title":"hyperlink","text":"<p>Creates a clickable hyperlink in supporting terminals.</p> <pre><code>hyperlink(_val: any, _link: str) -&gt; str\n</code></pre> <p>Converts text into a terminal hyperlink that can be clicked in supported terminals.</p> <pre><code>hyperlink(\"Visit Google\", \"https://google.com\")    // -&gt; Clickable \"Visit Google\" link\nhyperlink(\"localhost\", \"http://localhost:3000\")    // -&gt; Clickable \"localhost\" link\nhyperlink(42, \"https://example.com\")               // -&gt; Clickable \"42\" link\n</code></pre>"},{"location":"reference/functions/#colors-attributes","title":"Colors &amp; Attributes","text":"<p>Rad offers several functions to format text with colors and style attributes. All functions follow the same pattern:</p> <pre><code>color_or_style(_item: any) -&gt; str\n</code></pre> <pre><code>red(\"Hello\")           // -&gt; \"Hello\" (in red)\nblue(42)               // -&gt; \"42\" (in blue) \nbold(\"Important\")      // -&gt; \"Important\" (in bold)\n</code></pre> <p>Available colors:</p> <ul> <li><code>plain</code>, <code>black</code>, <code>red</code>, <code>green</code>, <code>yellow</code>, <code>blue</code>, <code>magenta</code>, <code>cyan</code>, <code>white</code>, <code>orange</code>, <code>pink</code></li> </ul> <p>Available style attributes:</p> <ul> <li><code>bold</code>, <code>italic</code>, <code>underline</code></li> </ul>"},{"location":"reference/functions/#color_rgb","title":"color_rgb","text":"<p>Applies RGB coloring to input text. RGB values must be in range [0, 255]. Not all terminals support this.</p> <pre><code>color_rgb(_val: any, *, red: int, green: int, blue: int) -&gt; str|error\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>_val</code> <code>any</code> Value to apply color to <code>red</code> <code>int</code> Red component (0-255) <code>green</code> <code>int</code> Green component (0-255) <code>blue</code> <code>int</code> Blue component (0-255) <p>RGB values must be in range [0, 255]. Not all terminals support this.</p> <pre><code>color_rgb(\"Hello\", red=255, green=0, blue=0)     // -&gt; \"Hello\" (in bright red)\ncolor_rgb(42, red=0, green=255, blue=128)        // -&gt; \"42\" (in green-cyan)\ncolor_rgb(\"test\", red=300, green=0, blue=0)      // -&gt; Error: RGB values must be [0, 255]\n</code></pre>"},{"location":"reference/functions/#colorize","title":"colorize","text":"<p>Assigns consistent colors to values from a set of possible values. The same value always gets the same color within the same set.</p> <pre><code>colorize(_val: any, _enum: any[], *, skip_if_single: bool = false) -&gt; str\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>_val</code> <code>any</code> Value to colorize <code>_enum</code> <code>any[]</code> Set of possible values for consistent coloring <code>skip_if_single</code> <code>bool = false</code> Don't colorize if only one value in set <p>Useful for automatically coloring table data or distinguishing values in lists.</p> <p>Examples:</p> <pre><code>names = [\"Alice\", \"Bob\", \"Charlie\"]\ncolorize(\"Alice\", names)     // -&gt; \"Alice\" (in consistent color)\ncolorize(\"Bob\", names)       // -&gt; \"Bob\" (in different consistent color)\n\n// In display blocks\nnames = [\"Alice\", \"Bob\", \"Charlie\", \"David\"]\ndisplay:\n    fields names\n    names:\n        map fn(n) colorize(n, names)\n</code></pre>"},{"location":"reference/functions/#maps","title":"Maps","text":""},{"location":"reference/functions/#keys","title":"keys","text":"<p>Returns all keys from a map as a list.</p> <pre><code>keys(_map: map) -&gt; list[any]\n</code></pre> <pre><code>keys({\"a\": 1, \"b\": 2, \"c\": 3})  // -&gt; [\"a\", \"b\", \"c\"]\nkeys({})                        // -&gt; []\n</code></pre>"},{"location":"reference/functions/#values","title":"values","text":"<p>Returns all values from a map as a list.</p> <pre><code>values(_map: map) -&gt; list[any]\n</code></pre> <pre><code>values({\"a\": 1, \"b\": 2, \"c\": 3})  // -&gt; [1, 2, 3]\nvalues({})                         // -&gt; []\n</code></pre>"},{"location":"reference/functions/#random","title":"Random","text":""},{"location":"reference/functions/#rand","title":"rand","text":"<p>Returns a random float between 0.0 (inclusive) and 1.0 (exclusive).</p> <pre><code>rand() -&gt; float\n</code></pre> <pre><code>rand()     // -&gt; 0.7394832\nrand()     // -&gt; 0.2847293\n</code></pre>"},{"location":"reference/functions/#rand_int","title":"rand_int","text":"<p>Returns a random integer in a specified range.</p> <pre><code>rand_int(_arg1: int = 9223372036854775807, _arg2: int?) -&gt; int\n</code></pre> <p>With one argument, returns random int from 0 to <code>_arg1</code> (exclusive). With two arguments, returns random int from <code>_arg1</code> to <code>_arg2</code> (exclusive). Min must be less than max.</p> <pre><code>rand_int(10)        // -&gt; Random int from 0-9\nrand_int(5, 15)     // -&gt; Random int from 5-14\nrand_int(10, 5)     // -&gt; Error: min (10) must be less than max (5)\n</code></pre>"},{"location":"reference/functions/#seed_random","title":"seed_random","text":"<p>Seeds the random number generator used by <code>rand</code> and <code>rand_int</code>.</p> <pre><code>seed_random(_seed: int) -&gt; void\n</code></pre> <pre><code>seed_random(42)\nrand()              // -&gt; Same sequence every time with seed 42\nrand_int(10)        // -&gt; Same sequence every time with seed 42\n</code></pre>"},{"location":"reference/functions/#uuid_v4","title":"uuid_v4","text":"<p>Generates a random V4 UUID.</p> <pre><code>uuid_v4() -&gt; str\n</code></pre> <pre><code>uuid_v4()  // -&gt; \"f47ac10b-58cc-4372-a567-0e02b2c3d479\"\n</code></pre>"},{"location":"reference/functions/#uuid_v7","title":"uuid_v7","text":"<p>Generates a random V7 UUID (time-ordered).</p> <pre><code>uuid_v7() -&gt; str\n</code></pre> <pre><code>uuid_v7()  // -&gt; \"01234567-89ab-7def-8123-456789abcdef\"\n</code></pre>"},{"location":"reference/functions/#gen_fid","title":"gen_fid","text":"<p>Generates a random flex ID (fid) - a time-ordered, URL-safe identifier.</p> <pre><code>gen_fid() -&gt; str|error\ngen_fid(*, alphabet: str?, tick_size_ms: int?, num_random_chars: int?) -&gt; str|error\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>alphabet</code> <code>str? = \"[0-9][A-Z][a-z]\"</code> Characters to use (base-62 by default) <code>tick_size_ms</code> <code>int? = 1</code> Time precision in milliseconds <code>num_random_chars</code> <code>int? = 6</code> Number of random characters to append <p>Defaults: <code>alphabet</code> is base-62 (<code>[0-9][A-Z][a-z]</code>), <code>tick_size_ms</code> is 1ms, <code>num_random_chars</code> is 6.</p> <pre><code>gen_fid()                                    // -&gt; \"1a2b3c4d5e\"\ngen_fid(alphabet=\"0123456789\")               // -&gt; \"1234567890\"\ngen_fid(num_random_chars=3)                  // -&gt; \"1a2b3c\"\n</code></pre>"},{"location":"reference/functions/#picking","title":"Picking","text":""},{"location":"reference/functions/#pick","title":"pick","text":"<p>Presents an interactive menu for selecting from a list of options.</p> <pre><code>pick(_options: list[str], _filter: str?|list[str]?, *, prompt: str = \"Pick an option\", prefer_exact: bool = false) -&gt; str\n</code></pre> <p>Shows a fuzzy-searchable menu. Filter can be a string or list of strings to pre-filter options.</p> <p>When <code>prefer_exact=true</code>, exact key matches (case-insensitive) are prioritized: if exactly one option exactly matches a filter, it's selected immediately; if multiple match exactly, only those are shown.</p> <pre><code>pick([\"apple\", \"banana\", \"cherry\"])                        // -&gt; Interactive menu\npick([\"red\", \"green\", \"blue\"], \"r\")                        // -&gt; Fuzzy-filtered to \"red\", \"green\"\npick([\"grape\", \"g\"], \"g\", prefer_exact=true)                 // -&gt; Immediately picks \"g\" (exact match)\npick([\"one\", \"two\", \"three\"], prompt=\"Choose:\")            // -&gt; Custom prompt\n</code></pre>"},{"location":"reference/functions/#pick_kv","title":"pick_kv","text":"<p>Presents an interactive menu showing keys but returns corresponding values.</p> <pre><code>pick_kv(keys: list[str], values: list[any], _filter: str?|list[str]?, *, prompt: str = \"Pick an option\", prefer_exact: bool = false) -&gt; any\n</code></pre> <p>Displays keys in the menu but returns the value at the same index when selected.</p> <p>When <code>prefer_exact=true</code>, exact key matches (case-insensitive) are prioritized: if exactly one key exactly matches a filter, its value is returned immediately; if multiple match exactly, only those are shown.</p> <pre><code>names = [\"Alice\", \"Bob\", \"Charlie\"]\nages = [25, 30, 35]\npick_kv(names, ages)                                        // -&gt; Shows names, returns age\npick_kv([\"Red\", \"Green\"], [\"#ff0000\", \"#00ff00\"])           // -&gt; Shows colors, returns hex\npick_kv([\"grape\", \"g\"], [1, 2], \"g\", prefer_exact=true)       // -&gt; Returns 2 (exact match)\n</code></pre>"},{"location":"reference/functions/#pick_from_resource","title":"pick_from_resource","text":"<p>Loads options from a resource file and presents an interactive menu.</p> <pre><code>pick_from_resource(path: str, _filter: str?, *, prompt: str = \"Pick an option\", prefer_exact: bool = true) -&gt; any\n</code></pre> <p>Loads data from a JSON file and presents it as selectable options. Returns the selected item(s).</p> <p>With <code>prefer_exact=true</code> (the default), exact key matches (case-insensitive) are prioritized: if exactly one entry has a key that exactly matches the filter, it's selected immediately; if multiple match exactly, only those are shown. Set <code>prefer_exact=false</code> to disable this and use pure fuzzy matching.</p> <pre><code>pick_from_resource(\"servers.json\")                    // -&gt; Menu from file\npick_from_resource(\"configs.json\", \"prod\")            // -&gt; Pre-filtered, exact match priority\npick_from_resource(\"data.json\", prompt=\"Select:\")     // -&gt; Custom prompt\npick_from_resource(\"data.json\", \"x\", prefer_exact=false) // -&gt; Pure fuzzy matching\n</code></pre>"},{"location":"reference/functions/#multipick","title":"multipick","text":"<p>Presents an interactive menu for selecting multiple options from a list.</p> <pre><code>multipick(_options: str[], *, prompt: str?, min: int = 0, max: int?) -&gt; str[]\n</code></pre> <p>Shows an interactive multi-select menu where users can select zero or more options. = Unlike <code>pick</code>, which returns a single selection, <code>multipick</code> returns a list of all selected items.</p> <p>Parameters:</p> Parameter Type Description <code>_options</code> <code>str[]</code> List of options to display in the menu <code>prompt</code> <code>str?</code> Custom prompt text. If not provided, automatically generated based on min/max <code>min</code> <code>int = 0</code> Minimum number of selections required (default 0 allows empty selection) <code>max</code> <code>int?</code> Maximum number of selections allowed (optional, unlimited if not set) <p>The <code>prompt</code> parameter has smart defaults that adjust based on the min/max constraints.</p> <p>Example:</p> <pre><code>fruits = [\"apple\", \"banana\", \"cherry\", \"date\"]\nselected = multipick(fruits)\n// selected equals e.g. [ \"apple\", \"cherry\" ]\n</code></pre>"},{"location":"reference/functions/#http","title":"HTTP","text":"<p>Rad provides functions for all HTTP methods. All functions have identical signatures and return the same response format.</p>"},{"location":"reference/functions/#http-functions","title":"HTTP Functions","text":"<p>Available methods:</p> <ul> <li><code>http_get</code>, <code>http_post</code>, <code>http_put</code>, <code>http_patch</code>, <code>http_delete</code></li> <li><code>http_head</code>, <code>http_options</code>, <code>http_trace</code>, <code>http_connect</code></li> </ul> <pre><code>http_method(url: str, *, body: any?, json: any?, headers: map?) -&gt; map\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>url</code> <code>str</code> The target URL <code>body</code> <code>any?</code> Request body content (sent as-is) <code>json</code> <code>any?</code> Request body content (JSON-serialized) <code>headers</code> <code>map?</code> Map of HTTP headers - optional. Values can be strings or lists of strings <ul> <li>Body vs JSON: The <code>body</code> parameter sends content as-is using string representation, while <code>json</code> automatically   JSON-serializes the content and sets <code>Content-Type: application/json</code> header only if no <code>headers</code> are provided at all.</li> <li>Mutually exclusive: Cannot use both <code>body</code> and <code>json</code> parameters together - you must choose one or the other.</li> </ul> <p>URL Encoding:</p> <p>Rad automatically normalizes URLs to ensure proper encoding:</p> <ul> <li>Spaces: Encoded as <code>%20</code> everywhere (path and query parameters)</li> <li>Special characters: Properly percent-encoded per RFC 3986</li> </ul> <p>This means you can write URLs naturally with spaces and special characters:</p> <pre><code>// URLs with spaces work naturally\nhttp_get(\"https://api.example.com/search?query=hello world\")\n// Sent as: https://api.example.com/search?query=hello%20world\n\n// Literal plus signs are preserved\nhttp_get(\"https://api.example.com?formula=a+b\")\n// Sent as: https://api.example.com?formula=a%2Bb\n\n// Parameter order is preserved\nhttp_get(\"https://api.example.com?zebra=1&amp;alpha=2\")\n// Sent as written (not reordered alphabetically)\n</code></pre> <p>Response map contains:</p> <ul> <li><code>success: bool</code> - Whether request succeeded</li> <li><code>duration_seconds: float</code> - Request duration</li> <li><code>status_code?: int</code> - HTTP status code (if response received)</li> <li><code>body?: any</code> - Response body parsed as JSON if possible (if present)</li> <li><code>error?: str</code> - Error message (if request failed)</li> </ul> <p>Examples:</p> <pre><code>// Simple GET request\nresponse = http_get(\"https://api.example.com/users\")\nif response.success:\n    users = response.body\n\n// POST with JSON body (automatic serialization and Content-Type header)\ndata = {\"name\": \"Alice\", \"email\": \"alice@example.com\"}\nresponse = http_post(\"https://api.example.com/users\", json=data)\n\n// POST with raw body content (sent as-is)\nresponse = http_post(\"https://api.example.com/webhook\", body=\"raw text data\")\n\n// With custom headers\nheaders = {\"Authorization\": \"Bearer token123\"}\nresponse = http_get(\"https://api.example.com/data\", headers=headers)\n\n// JSON with custom headers (Content-Type automatically added)\nresponse = http_post(\"https://api.example.com/users\", json=data, headers={\"Authorization\": \"Bearer token123\"})\n\n// Error handling\nresponse = http_get(\"https://invalid-url\")\nif not response.success:\n    print(\"Request failed:\", response.error)\n\n// Cannot use both body and json together - this will error:\n// response = http_post(\"url\", body=\"data\", json={\"key\": \"value\"})  // -&gt; Error\n</code></pre>"},{"location":"reference/functions/#math","title":"Math","text":""},{"location":"reference/functions/#abs","title":"abs","text":"<p>Returns the absolute value of a number.</p> <pre><code>abs(_num: int|float) -&gt; int|float\n</code></pre> <pre><code>abs(-5)      // -&gt; 5\nabs(3.14)    // -&gt; 3.14\nabs(-2.7)    // -&gt; 2.7\n</code></pre>"},{"location":"reference/functions/#sum","title":"sum","text":"<p>Sums all numbers in a list.</p> <pre><code>sum(_nums: list[float]) -&gt; int|float|error\n</code></pre> <p>The return type preserves the input type: returns <code>int</code> if all inputs are integers, <code>float</code> if any input is a float.</p> <pre><code>sum([1, 2, 3, 4])        // -&gt; 10\nsum([1.5, 2.5, 3.0])     // -&gt; 7.0\nsum([1, 2.0, 3])         // -&gt; 6.0 (float because 2.0 is float)\nsum([])                  // -&gt; 0\nsum([1, \"text\", 3])      // -&gt; Error: requires list of numbers\n</code></pre>"},{"location":"reference/functions/#round","title":"round","text":"<p>Rounds a number to the specified decimal precision.</p> <pre><code>round(_num: float, _decimals: int = 0) -&gt; int|float|error\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>_num</code> <code>float</code> Number to round <code>_decimals</code> <code>int = 0</code> Number of decimal places (must be non-negative) <p>With precision 0, returns an integer. With precision &gt; 0, returns a float. Precision must be non-negative.</p> <pre><code>round(3.14159)           // -&gt; 3 (integer)\nround(3.14159, 2)        // -&gt; 3.14 (float)\nround(2.7)               // -&gt; 3 (integer)\nround(3.14, -1)          // -&gt; Error: precision must be non-negative\n</code></pre>"},{"location":"reference/functions/#floor","title":"floor","text":"<p>Rounds a number down to the next integer.</p> <pre><code>floor(_num: float) -&gt; int\n</code></pre> <pre><code>floor(1.89)    // -&gt; 1\nfloor(-1.2)    // -&gt; -2\nfloor(5.0)     // -&gt; 5\n</code></pre>"},{"location":"reference/functions/#ceil","title":"ceil","text":"<p>Rounds a number up to the next integer.</p> <pre><code>ceil(_num: float) -&gt; int\n</code></pre> <pre><code>ceil(1.21)     // -&gt; 2\nceil(-1.8)     // -&gt; -1\nceil(5.0)      // -&gt; 5\n</code></pre>"},{"location":"reference/functions/#min","title":"min","text":"<p>Returns the minimum value from a list of numbers or from variadic arguments.</p> <pre><code>min(_nums: num|num[]) -&gt; int|float|error\n</code></pre> <p>Accepts either a single list of numbers or multiple number arguments. The return type preserves the input type: returns <code>int</code> if all inputs are integers, <code>float</code> if any input is a float.</p> <pre><code>min([1, 2, 3, 4])        // -&gt; 1\nmin(1, 2, 3, 4)          // -&gt; 1\nmin(5.5, 2.1, 8.9)       // -&gt; 2.1\nmin(1, 2.0, 3)           // -&gt; 1.0 (float because 2.0 is float)\nmin(5)                   // -&gt; 5\nmin([])                  // -&gt; Error: cannot find minimum of empty list\nmin([1, \"text\"])         // -&gt; Error: requires list of numbers\n</code></pre>"},{"location":"reference/functions/#max","title":"max","text":"<p>Returns the maximum value from a list of numbers or from variadic arguments.</p> <pre><code>max(_nums: num|num[]) -&gt; int|float|error\n</code></pre> <p>Accepts either a single list of numbers or multiple number arguments. The return type preserves the input type: returns <code>int</code> if all inputs are integers, <code>float</code> if any input is a float.</p> <pre><code>max([1, 2, 3, 4])        // -&gt; 4\nmax(1, 2, 3, 4)          // -&gt; 4\nmax(5.5, 2.1, 8.9)       // -&gt; 8.9\nmax(1, 2.0, 3)           // -&gt; 3.0 (float because 2.0 is float)\nmax(5)                   // -&gt; 5\nmax([])                  // -&gt; Error: cannot find maximum of empty list\nmax([1, \"text\"])         // -&gt; Error: requires list of numbers\n</code></pre>"},{"location":"reference/functions/#clamp","title":"clamp","text":"<p>Constrains a value between minimum and maximum bounds.</p> <pre><code>clamp(val: int|float, min: int|float, max: int|float) -&gt; int|float|error\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>val</code> <code>int|float</code> Value to constrain <code>min</code> <code>int|float</code> Minimum bound <code>max</code> <code>int|float</code> Maximum bound <p>Returns <code>val</code> if between min and max, otherwise returns the nearest bound. Min must be \u2264 max. The return type preserves the input type: returns <code>int</code> if all inputs are integers, <code>float</code> if any input is a float.</p> <pre><code>clamp(25, 20, 30)    // -&gt; 25\nclamp(10, 20, 30)    // -&gt; 20\nclamp(40, 20, 30)    // -&gt; 30\nclamp(5, 1.0, 10)    // -&gt; 5.0 (float because 1.0 is float)\nclamp(15, 30, 20)    // -&gt; Error: min must be &lt;= max\n</code></pre>"},{"location":"reference/functions/#pow","title":"pow","text":"<p>Raises <code>base</code> to the power of <code>exponent</code>. Useful for exponentiation, square roots, and cube roots.</p> <pre><code>pow(base: float, exponent: float) -&gt; float\n</code></pre> <pre><code>pow(2, 3)      // -&gt; 8\npow(4, 0.5)    // -&gt; 2.0 (square root)\npow(8, 1/3)    // -&gt; 2.0 (cube root)  \npow(2, -2)     // -&gt; 0.25\npow(-2, 3)     // -&gt; -8\n</code></pre>"},{"location":"reference/functions/#hashing-encodedecode","title":"Hashing &amp; Encode/Decode","text":""},{"location":"reference/functions/#hash","title":"hash","text":"<p>Generates a hash of the input text using various algorithms.</p> <pre><code>hash(_val: str) -&gt; str\nhash(_val: str, *, algo: [\"sha1\", \"sha256\", \"sha512\", \"md5\"] = \"sha1\") -&gt; str\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>_val</code> <code>str</code> Text to hash <code>algo</code> <code>[\"sha1\", \"sha256\", \"sha512\", \"md5\"] = \"sha1\"</code> Hashing algorithm to use <p>The default <code>sha1</code> is not cryptographically secure. Use <code>sha256</code> or <code>sha512</code> for security.</p> <pre><code>hash(\"hello world\")                    // -&gt; \"2aae6c35c94fcfb415dbe95f408b9ce91ee846ed\"\nhash(\"hello world\", algo=\"sha256\")     // -&gt; \"b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9\"\nhash(\"sensitive data\", algo=\"sha512\")  // -&gt; Long SHA-512 hash\n</code></pre>"},{"location":"reference/functions/#encode_base64","title":"encode_base64","text":"<p>Encodes text to Base64 format.</p> <pre><code>encode_base64(_content: str) -&gt; str\nencode_base64(_content: str, *, url_safe: bool = false, padding: bool = true) -&gt; str\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>_content</code> <code>str</code> Text to encode <code>url_safe</code> <code>bool = false</code> Replace <code>+/</code> with <code>-_</code> for URL-safe encoding <code>padding</code> <code>bool = true</code> Include <code>=</code> padding characters <p>Use <code>url_safe=true</code> to replace <code>+/</code> with <code>-_</code> for URL-safe encoding. Use <code>padding=false</code> to omit <code>=</code> padding.</p> <pre><code>encode_base64(\"Hello World\")                      // -&gt; \"SGVsbG8gV29ybGQ=\"\nencode_base64(\"Hello World\", url_safe=true)       // -&gt; URL-safe version\nencode_base64(\"Hello World\", padding=false)       // -&gt; \"SGVsbG8gV29ybGQ\"\n</code></pre>"},{"location":"reference/functions/#decode_base64","title":"decode_base64","text":"<p>Decodes Base64 text back to original string.</p> <pre><code>decode_base64(_content: str) -&gt; str|error\ndecode_base64(_content: str, *, url_safe: bool = false, padding: bool = true) -&gt; str|error\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>_content</code> <code>str</code> Base64 text to decode <code>url_safe</code> <code>bool = false</code> Expect URL-safe encoding (<code>-_</code> instead of <code>+/</code>) <code>padding</code> <code>bool = true</code> Expect padding characters (<code>=</code>) <p>Settings must match those used for encoding.</p> <pre><code>encoded = encode_base64(\"Hello World\")\ndecoded = decode_base64(encoded)           // -&gt; \"Hello World\"\n\n// URL-safe decoding\nurl_encoded = encode_base64(\"test\", url_safe=true)\ndecoded = decode_base64(url_encoded, url_safe=true)\n\n// Error handling\nresult = decode_base64(\"invalid base64!\")\nif result.error:\n    print(\"Decode failed:\", result.error)\n</code></pre>"},{"location":"reference/functions/#encode_base16","title":"encode_base16","text":"<p>Encodes text to Base16 (hexadecimal) format.</p> <pre><code>encode_base16(_content: str) -&gt; str\n</code></pre> <pre><code>encode_base16(\"Hello\")        // -&gt; \"48656c6c6f\"\nencode_base16(\"ABC\")          // -&gt; \"414243\"\n</code></pre>"},{"location":"reference/functions/#decode_base16","title":"decode_base16","text":"<p>Decodes Base16 (hexadecimal) text back to original string.</p> <pre><code>decode_base16(_content: str) -&gt; str|error\n</code></pre> <pre><code>decode_base16(\"48656c6c6f\")   // -&gt; \"Hello\"\ndecode_base16(\"414243\")       // -&gt; \"ABC\"\n\n// Error handling\nresult = decode_base16(\"invalid hex\")\nif result.error:\n    print(\"Invalid hex string\")\n</code></pre>"},{"location":"reference/functions/#system-files","title":"System &amp; Files","text":""},{"location":"reference/functions/#exit","title":"exit","text":"<p>Exits the script with the given exit code.</p> <pre><code>exit(_code: int|bool = 0) -&gt; void\n</code></pre> <pre><code>exit()          // -&gt; Exits with code 0\nexit(1)         // -&gt; Exits with code 1\nexit(true)      // -&gt; Exits with code 1 (bool conversion)\nexit(false)     // -&gt; Exits with code 0 (bool conversion)\n</code></pre>"},{"location":"reference/functions/#read_file","title":"read_file","text":"<p>Reads the contents of a file.</p> <pre><code>read_file(_path: str, *, mode: [\"text\", \"bytes\"] = \"text\") -&gt; map|error\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>_path</code> <code>str</code> Path to the file to read <code>mode</code> <code>[\"text\", \"bytes\"] = \"text\"</code> Read as UTF-8 text or raw bytes <p>In text mode, decodes as UTF-8 and returns a string. In bytes mode, returns a list of integers.</p> <p>Return map contains:</p> <ul> <li><code>size_bytes: int</code> - File size in bytes</li> <li><code>content: str|list[int]</code> - File contents (type depends on mode)</li> </ul> <p>Examples:</p> <pre><code>// Read text file\nresult = read_file(\"config.txt\")\nif result.success:\n    content = result.content  // -&gt; string\n\n// Read binary file\nresult = read_file(\"image.png\", mode=\"bytes\")\nif result.success:\n    bytes = result.content    // -&gt; list[int]\n\n// Handle errors\nresult = read_file(\"missing.txt\")\nif not result.success:\n    print(\"Error:\", result.error)\n</code></pre>"},{"location":"reference/functions/#write_file","title":"write_file","text":"<p>Writes content to a file. Creates the file if it doesn't exist.</p> <pre><code>write_file(_path: str, _content: str, *, append: bool = false) -&gt; map|error\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>_path</code> <code>str</code> Path where to write the file <code>_content</code> <code>str</code> Content to write <code>append</code> <code>bool = false</code> Append to existing content instead of overwriting <p>By default overwrites the file. Use <code>append=true</code> to append to existing content.</p> <p>Return map contains:</p> <ul> <li><code>bytes_written: int</code> - Number of bytes written</li> <li><code>path: str</code> - Full path to the written file</li> </ul> <p>Examples:</p> <pre><code>// Write new file\nresult = write_file(\"output.txt\", \"Hello world\")\nprint(\"Wrote\", result.bytes_written, \"bytes\")\n\n// Append to existing file\nwrite_file(\"log.txt\", \"\\nNew entry\", append=true)\n\n// Error handling\nresult, err = write_file(\"/readonly/file.txt\", \"data\")\nif err:\n    print(\"Write failed:\", err.msg)\n</code></pre>"},{"location":"reference/functions/#read_stdin","title":"read_stdin","text":"<p>Reads all data from stdin.</p> <pre><code>read_stdin() -&gt; str?|error\n</code></pre> <pre><code>read_stdin()                  // -&gt; \"piped content\" (if piped)\nread_stdin()                  // -&gt; null (if not piped)\nread_stdin()                  // -&gt; Error 20026 if read fails\ncontent = read_stdin()\nlines = content.split_lines() // Process stdin line-by-line\n</code></pre>"},{"location":"reference/functions/#has_stdin","title":"has_stdin","text":"<p>Checks if stdin is piped to the script.</p> <pre><code>has_stdin() -&gt; bool\n</code></pre> <pre><code>has_stdin()                     // -&gt; true (if piped)\nhas_stdin()                     // -&gt; false (if not piped)\nif has_stdin():\n  content = read_stdin()        // Conditional read\n</code></pre>"},{"location":"reference/functions/#get_path","title":"get_path","text":"<p>Gets information about a file or directory path.</p> <pre><code>get_path(_path: str) -&gt; map\n</code></pre> <p>Always returns:</p> <ul> <li><code>exists: bool</code> - Whether the path exists</li> <li><code>full_path: str</code> - Absolute path</li> </ul> <p>When path exists, also returns:</p> <ul> <li><code>base_name?: str</code> - File/directory name</li> <li><code>permissions?: str</code> - Permission string (e.g., \"rwxr-xr-x\")</li> <li><code>type?: str</code> - Either \"file\" or \"dir\"</li> <li><code>size_bytes?: int</code> - File size (only for files)</li> <li><code>modified_millis?: int</code> - Modification time as epoch milliseconds</li> <li><code>accessed_millis?: int</code> - Access time as epoch milliseconds (Unix/macOS only)</li> </ul> <p>Examples:</p> <pre><code>info = get_path(\"config.txt\")\nif info.exists:\n    print(\"File size:\", info.size_bytes, \"bytes\")\n    print(\"Type:\", info.type)\nelse:\n    print(\"File not found\")\n\n// Working with timestamps using parse_epoch()\ninfo = get_path(\"data.json\")\nif info.exists:\n    mtime = info.modified_millis.parse_epoch()\n    print(\"Last modified:\", mtime.date, mtime.time)\n</code></pre>"},{"location":"reference/functions/#find_paths","title":"find_paths","text":"<p>Returns a list of all paths under a directory.</p> <pre><code>find_paths(_path: str) -&gt; list[str]|error\nfind_paths(_path: str, *, depth: int = -1, relative: [\"target\", \"cwd\", \"absolute\"] = \"target\") -&gt; list[str]|error\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>_path</code> <code>str</code> Directory to search <code>depth</code> <code>int = -1</code> Max depth to search (-1 for unlimited) <code>relative</code> <code>[\"target\", \"cwd\", \"absolute\"] = \"target\"</code> How to format returned paths <ul> <li><code>\"target\"</code> - Relative to input path (default)</li> <li><code>\"cwd\"</code> - Relative to current directory</li> <li><code>\"absolute\"</code> - Full absolute paths</li> </ul> <p>Examples:</p> <pre><code>// Find all files in directory\npaths = find_paths(\"src/\")\nfor path in paths:\n    print(path)  // -&gt; \"file1.txt\", \"subdir/file2.txt\", etc.\n\n// Limit depth\npaths = find_paths(\"src/\", depth=1)  // -&gt; Only direct children\n\n// Get absolute paths\npaths = find_paths(\"src/\", relative=\"absolute\")\n</code></pre>"},{"location":"reference/functions/#get_env","title":"get_env","text":"<p>Retrieves the value of an environment variable.</p> <pre><code>get_env(_var: str) -&gt; str\n</code></pre> <p>Returns the environment variable value, or empty string if not set.</p> <pre><code>home_dir = get_env(\"HOME\")                    // -&gt; \"/Users/username\"\napi_key = get_env(\"API_KEY\") or \"default\"     // -&gt; Uses default if not set\nmissing = get_env(\"NONEXISTENT\")              // -&gt; \"\"\n</code></pre>"},{"location":"reference/functions/#delete_path","title":"delete_path","text":"<p>Deletes a file or directory at the specified path.</p> <pre><code>delete_path(_path: str) -&gt; bool\n</code></pre> <p>Returns <code>true</code> if the path was successfully deleted, <code>false</code> if it didn't exist or couldn't be deleted.</p> <pre><code>delete_path(\"temp.txt\")         // -&gt; true (if file existed and was deleted)\ndelete_path(\"missing.txt\")      // -&gt; false (file didn't exist)\ndelete_path(\"directory/\")       // -&gt; true (if directory existed and was deleted)\n</code></pre>"},{"location":"reference/functions/#get_rad_home","title":"get_rad_home","text":"<p>Returns Rad's home directory.</p> <pre><code>get_rad_home() -&gt; str\n</code></pre> <pre><code>home = get_rad_home()  // -&gt; \"/Users/username/.rad\" or $RAD_HOME\n</code></pre>"},{"location":"reference/functions/#get_args","title":"get_args","text":"<p>Returns the raw command-line arguments passed to the script.</p> <pre><code>get_args() -&gt; list[str]\n</code></pre> <p>Returns all arguments after the script name. Unlike parsed args, this gives you raw access to all arguments.</p> <pre><code>// If script was called: rad myscript.rad arg1 arg2 --flag\nargs = get_args()  // -&gt; [\"./myscript.rad\", \"arg1\", \"arg2\", \"--flag\"]\n</code></pre>"},{"location":"reference/functions/#error_1","title":"error","text":"<p>Creates an error object with the given message.</p> <pre><code>error(_msg: str) -&gt; error\n</code></pre> <pre><code>err = error(\"Something went wrong\")\nreturn err  // -&gt; Script will exit with this error message\n</code></pre>"},{"location":"reference/functions/#home-stash","title":"Home &amp; Stash","text":""},{"location":"reference/functions/#get_rad_home_1","title":"<code>get_rad_home</code>","text":"<p>Returns the path to rad's home folder on the user's machine.</p> <pre><code>get_rad_home() -&gt; string\n</code></pre> <p>Return Values</p> <p>Defaults to <code>$HOME/.rad</code>, or <code>$RAD_HOME</code> if it's defined.</p>"},{"location":"reference/functions/#get_stash_path","title":"<code>get_stash_path</code>","text":"<p>Returns the full path to the script's stash directory, with the given subpath if specified.</p> <p>Requires a stash ID to have been defined.</p> <pre><code>get_stash_path(subpath: string?) -&gt; string\n</code></pre> <p>Return Values</p> <ul> <li>Without subpath defined: <code>&lt;rad home&gt;/stashes/&lt;stash id&gt;</code></li> <li>With subpath defined: <code>&lt;rad home&gt;/stashes/&lt;stash id&gt;/&lt;subpath&gt;</code></li> </ul>"},{"location":"reference/functions/#load_state","title":"<code>load_state</code>","text":"<p>Loads the script's stashed state. Creates it if it doesn't already exist.</p> <p>Requires a stash ID to have been defined.</p> <pre><code>load_state() -&gt; map, bool\n</code></pre> <p>Return Values</p> <ol> <li><code>map</code> containing the saved state. Starts empty, before anything is saved to it.</li> <li><code>bool</code> representing if the state existed before the load, or if it was just created.</li> </ol>"},{"location":"reference/functions/#save_state","title":"save_state","text":"<p>Saves the script's state to persistent stash storage.</p> <pre><code>save_state(_state: map) -&gt; error?\n</code></pre> <pre><code>state = {\"counter\": 42, \"last_run\": now().date}\nsave_state(state)\nprint(\"State saved\")\n</code></pre>"},{"location":"reference/functions/#load_stash_file","title":"load_stash_file","text":"<p>Loads a file from the script's stash directory, creating it with default content if it doesn't exist.</p> <pre><code>load_stash_file(_path: str, _default: str = \"\") -&gt; map|error\n</code></pre> <p>Return map contains:</p> <ul> <li><code>full_path: str</code> - Full path to the file</li> <li><code>created: bool</code> - Whether the file was just created</li> <li><code>content?: str</code> - File contents (if successfully loaded)</li> </ul> <pre><code>result = load_stash_file(\"config.txt\", \"default config\")\nif result.success:\n    if result.created:\n        print(\"Created new config file\")\n    content = result.content\n</code></pre>"},{"location":"reference/functions/#write_stash_file","title":"write_stash_file","text":"<p>Writes content to a file in the script's stash directory.</p> <pre><code>write_stash_file(_path: str, _content: str) -&gt; error?\n</code></pre> <pre><code>write_stash_file(\"log.txt\", \"Script executed at \" + now().time)\nwrite_stash_file(\"data/results.json\", json_data)\nprint(\"Data saved to stash\")\n</code></pre>"},{"location":"reference/functions/#time","title":"Time","text":""},{"location":"reference/functions/#now","title":"now","text":"<p>Returns the current time with various accessible formats.</p> <pre><code>now(*, tz: str = \"local\") -&gt; map|error\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>tz</code> <code>str = \"local\"</code> Timezone (e.g., \"UTC\", \"America/Chicago\") <p>Map values:</p> Accessor Description Type Example <code>.date</code> Current date YYYY-MM-DD string 2019-12-13 <code>.year</code> Current calendar year int 2019 <code>.month</code> Current calendar month int 12 <code>.day</code> Current calendar day int 13 <code>.hour</code> Current clock hour (24h) int 14 <code>.minute</code> Current minute of the hour int 15 <code>.second</code> Current second of the minute int 16 <code>.time</code> Current time in \"hh:mm:ss\" format string 14:15:16 <code>.epoch.seconds</code> Seconds since 1970-01-01 00:00:00 UTC int 1576246516 <code>.epoch.millis</code> Millis since 1970-01-01 00:00:00 UTC int 1576246516123 <code>.epoch.nanos</code> Nanos since 1970-01-01 00:00:00 UTC int 1576246516123456789 <p>Examples:</p> <pre><code>time = now()\nprint(\"Current date:\", time.date)          // -&gt; \"2024-04-05\"\nprint(\"Current time:\", time.time)          // -&gt; \"14:30:25\"\nprint(\"Year:\", time.year)                  // -&gt; 2024\n\n// Use epoch for timestamps\ntimestamp = now().epoch.seconds\nprint(\"Timestamp:\", timestamp)             // -&gt; 1712345678\n\n// Different timezone\nutc_time = now(tz=\"UTC\")\nprint(\"UTC time:\", utc_time.time)          // -&gt; Time in UTC\n</code></pre>"},{"location":"reference/functions/#parse_epoch","title":"parse_epoch","text":"<p>Parses a Unix epoch timestamp into various time formats.</p> <pre><code>parse_epoch(_epoch: int|float) -&gt; map|error\nparse_epoch(_epoch: int|float, *, tz: str = \"local\") -&gt; map|error\nparse_epoch(_epoch: int|float, *, unit: [\"auto\", \"seconds\", \"milliseconds\", \"microseconds\", \"nanoseconds\"] = \"auto\") -&gt; map|error\nparse_epoch(_epoch: int|float, *, tz: str = \"local\", unit: [\"auto\", \"seconds\", \"milliseconds\", \"microseconds\", \"nanoseconds\"] = \"auto\") -&gt; map|error\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>_epoch</code> <code>int\\|float</code> Unix epoch timestamp (float for sub-unit precision) <code>tz</code> <code>str = \"local\"</code> Timezone (e.g., \"UTC\", \"America/Chicago\") <code>unit</code> <code>[\"auto\", \"seconds\", \"milliseconds\", \"microseconds\", \"nanoseconds\"] = \"auto\"</code> Timestamp unit (auto-detects by default) <p>Converts an epoch timestamp to the same format as <code>now()</code>. Auto-detects units from digit count, or specify explicitly. When using a float, the fractional part provides sub-unit precision (e.g., <code>1712345678.5</code> seconds includes 500 milliseconds).</p> <p>Examples:</p> <pre><code>// Parse seconds epoch (auto-detected)\ntime = parse_epoch(1712345678)\nprint(time.date, time.time)  // -&gt; \"2024-04-05 22:01:18\"\n\n// Parse milliseconds with timezone\ntime = parse_epoch(1712345678123, tz=\"America/Chicago\")\nprint(time.hour)  // -&gt; Hour in Chicago timezone\n\n// Explicit unit specification\ntime = parse_epoch(1712345678000, unit=\"milliseconds\")\n\n// Float epoch with sub-second precision\ntime = parse_epoch(1712345678.5)  // 1712345678 seconds + 500ms\nprint(time.epoch.millis)  // -&gt; 1712345678500\n\n// Float with explicit unit (sub-millisecond precision)\ntime = parse_epoch(1712345678123.25, unit=\"milliseconds\")\nprint(time.epoch.nanos)  // -&gt; 1712345678123250000\n\n// Error handling\ntime, err = parse_epoch(1712345678, tz=\"Invalid/Timezone\")\nif err:\n    print(\"Invalid timezone:\", err.msg)\n</code></pre>"},{"location":"reference/syntax/","title":"Rad Language Reference","text":"<p>This document provides a comprehensive overview of Rad's syntax for quick reference in development sessions.</p>"},{"location":"reference/syntax/#script-structure","title":"Script Structure","text":""},{"location":"reference/syntax/#basic-script-format","title":"Basic Script Format","text":"<pre><code>#!/usr/bin/env rad\n---\nScript description goes here.\nMulti-line descriptions are supported.\n---\n\n// Optional arguments section\nargs:\n    name str              # Required string argument\n    count int = 5         # Optional with default value\n    verbose v bool        # Boolean flag (can use short form)\n\n// Script body\nprint(\"Hello {name}!\")\n</code></pre>"},{"location":"reference/syntax/#file-header-for-automatic-help-generation","title":"File Header for Automatic Help Generation","text":"<p>The file header automatically generates the help text shown when users run your script with <code>-h</code> or <code>--help</code>. This is a core Rad feature that eliminates the need to manually write help documentation.</p> <pre><code>---\nScript description that appears in --help.\n\nDetailed explanation of what the script does.\nCan be multiple paragraphs.\n\n@stash_id = my_script_data\n@enable_global_options = true  \n@enable_args_block = true\n---\n</code></pre>"},{"location":"reference/syntax/#special-macros","title":"Special @ Macros","text":"<ul> <li><code>@stash_id</code> - Sets the stash identifier for the script</li> <li><code>@enable_global_options</code> - Enable/disable global Rad options (default: true)</li> <li><code>@enable_args_block</code> - Enable/disable argument parsing (default: true)</li> </ul>"},{"location":"reference/syntax/#static-analysis","title":"Static Analysis","text":"<p>Use <code>rad check &lt;script&gt;</code> to statically analyze your scripts for errors before running them. This catches syntax errors, type mismatches, and other issues without executing the script.</p> <pre><code>rad check my_script.rad\n</code></pre>"},{"location":"reference/syntax/#comments","title":"Comments","text":"<pre><code>// Code comments use double slash\n// Multi-line code comments use multiple // lines\n// like this\n\n// In args blocks, argument descriptions use # for help text generation:\nargs:\n    name str    # This comment appears in --help usage\n    count int   # This also appears in --help\n</code></pre>"},{"location":"reference/syntax/#data-types","title":"Data Types","text":""},{"location":"reference/syntax/#primitives","title":"Primitives","text":"<pre><code>// Strings\nname = \"alice\"\npath = 'path/to/file'\n\n// Multi-line strings (triple quotes)\ntext = \"\"\"\nHello world\nHow are you?\n\"\"\"\n\n// Numbers\nage = 25                   // int\nheight = 5.9               // float\nscientific = 1.23e4        // exponential notation\nlarge_num = 1_234_567      // underscore separators for readability\nfloat_with_sep = 123.456_789\n\n// Booleans\nis_valid = true\nis_empty = false\n\n// Null\nvalue = null\n</code></pre>"},{"location":"reference/syntax/#collections","title":"Collections","text":"<pre><code>// Lists\nnumbers = [1, 2, 3, 4, 5]\nmixed = [1, \"hello\", true, [1, 2]]\nempty_list = []\n\n// Maps/Objects\nperson = {\"name\": \"alice\", \"age\": 25}\nnested = {\"user\": {\"name\": \"bob\", \"roles\": [\"admin\", \"user\"]}}\nempty_map = {}\n</code></pre>"},{"location":"reference/syntax/#multi-line-strings-triple-quotes","title":"Multi-line Strings (Triple Quotes)","text":"<pre><code>// Basic multi-line string\ntext = \"\"\"\nHello world\nHow are you?\n\"\"\"\n\n// Indentation control - closing \"\"\" position determines whitespace stripping\nindented = \"\"\"\n  Line 1\n   Line 2\n     Line 4\n \"\"\"\n// Result: \" Line 1\\n  Line 2\\n    Line 4\\n\" (1 space stripped from each line)\n\n// String interpolation works in multi-line strings\nname = \"alice\"\nmessage = \"\"\"\nHello {name}!\nHow are you today?\n\"\"\"\n\n// Raw multi-line strings (no interpolation or escape processing)\nraw_text = r\"\"\"\nLiteral \\n and {name}\nNo processing here\n\"\"\"\n\n// Comments allowed after opening triple quotes\ndocumented = \"\"\" // This is allowed\nContent starts on next line\nAlways on next line\n\"\"\"\n</code></pre> <p>Multi-line String Rules: - Content must start on a new line after opening <code>\"\"\"</code> - The indentation of the closing <code>\"\"\"</code> determines how much leading whitespace is stripped from each line - Support string interpolation with <code>{variable}</code> syntax unless raw (<code>r\"\"\"</code>) - Support escape sequences (like <code>\\n</code>, <code>\\t</code>) unless raw - Comments can follow the opening <code>\"\"\"</code> on the same line - Cannot have content on the same line as the opening <code>\"\"\"</code></p>"},{"location":"reference/syntax/#variables-and-assignment","title":"Variables and Assignment","text":""},{"location":"reference/syntax/#basic-assignment","title":"Basic Assignment","text":"<pre><code>name = \"alice\"\nage = 25\n</code></pre>"},{"location":"reference/syntax/#multiple-assignment","title":"Multiple Assignment","text":"<pre><code>a, b = 1, 2\nx, y = some_function_returning_tuple()\n</code></pre>"},{"location":"reference/syntax/#compound-assignment","title":"Compound Assignment","text":"<pre><code>count = 5\ncount += 1              // count = 6\ncount -= 2              // count = 4\ncount *= 3              // count = 12\ncount /= 4              // count = 3\n</code></pre>"},{"location":"reference/syntax/#incrementdecrement","title":"Increment/Decrement","text":"<pre><code>i = 0\ni++                     // i = 1\ni--                     // i = 0\n</code></pre>"},{"location":"reference/syntax/#string-interpolation","title":"String Interpolation","text":"<pre><code>name = \"alice\"\nage = 25\nmessage = \"Hello {name}, you are {age} years old!\"\n\n// Works with expressions\ntotal = \"Result: {x + y}\"\n\n// Format specifiers\nprice = 123.456\nformatted = \"Price: {price:.2}\"          // \"Price: 123.46\" (2 decimal places)\npadded = \"Name: {name:&lt;10}\"              // \"Name: alice     \" (left-aligned, padded to 10)\nright_aligned = \"Name: {name:&gt;10}\"       // \"Name:      alice\" (right-aligned)\n\n// Thousands separators (numbers only)\nbig_num = 1234567\nformatted = \"{big_num:,}\"                // \"1,234,567\"\nwith_decimals = \"{big_num:,.2}\"          // \"1,234,567.00\"\npadded_thousands = \"{big_num:&gt;15,}\"      // \"      1,234,567\"\n</code></pre>"},{"location":"reference/syntax/#ternary-operator","title":"Ternary Operator","text":"<pre><code>// Basic ternary syntax\nresult = condition ? value_if_true : value_if_false\n\n// Examples\nstatus = age &gt;= 18 ? \"adult\" : \"minor\"\nmessage = count == 1 ? \"1 item\" : \"{count} items\"\nmax_value = a &gt; b ? a : b\n\n// Can be chained\ncategory = age &lt; 13 ? \"child\" : age &lt; 18 ? \"teen\" : \"adult\"\n</code></pre>"},{"location":"reference/syntax/#collection-access-and-slicing","title":"Collection Access and Slicing","text":""},{"location":"reference/syntax/#indexing","title":"Indexing","text":"<pre><code>items = [10, 20, 30, 40, 50]\nfirst = items[0]        // 10\nlast = items[-1]        // 50\n\nperson = {\"name\": \"alice\", \"age\": 25}\nname = person[\"name\"]   // \"alice\"\n\n// Fallback for out-of-bounds or missing keys with ??\nvalue = items[100] ?? \"not found\"       // \"not found\" (index out of bounds)\nrole = person[\"role\"] ?? \"guest\"        // \"guest\" (key not found)\nchar = \"hello\"[99] ?? \"?\"               // \"?\" (string index out of bounds)\n</code></pre>"},{"location":"reference/syntax/#slicing","title":"Slicing","text":"<pre><code>items = [10, 20, 30, 40, 50]\nsubset = items[1:3]     // [20, 30]\nfrom_start = items[:3]  // [10, 20, 30]\nto_end = items[2:]      // [30, 40, 50]\nall_items = items[:]    // [10, 20, 30, 40, 50]\n\n// Negative indices\nend_items = items[-2:]  // [40, 50]\n</code></pre>"},{"location":"reference/syntax/#string-slicing","title":"String Slicing","text":"<pre><code>text = \"hello\"\nsubstring = text[1:4]   // \"ell\"\n</code></pre>"},{"location":"reference/syntax/#control-flow","title":"Control Flow","text":""},{"location":"reference/syntax/#if-statements","title":"If Statements","text":"<pre><code>if age &gt;= 18:\n    print(\"Adult\")\nelse if age &gt;= 13:\n    print(\"Teen\")\nelse:\n    print(\"Child\")\n\n// Single condition\nif is_valid:\n    process_data()\n</code></pre>"},{"location":"reference/syntax/#switch-statements","title":"Switch Statements","text":"<pre><code>// Expression switches (single values)\nresult = switch value:\n    case \"a\" -&gt; \"Apple\"\n    case \"b\" -&gt; \"Banana\"\n    default -&gt; \"Unknown\"\n\n// Multiple cases\nstatus = switch code:\n    case 200, 201, 204 -&gt; \"Success\"\n    case 400, 401, 403 -&gt; \"Client Error\"\n    case 500, 502, 503 -&gt; \"Server Error\"\n    default -&gt; \"Unknown\"\n\n// Multi-assignment from switch\na, b = switch condition:\n    case true -&gt; 10, 20\n    case false -&gt; 30, 40\n\n// Block switches (multiple statements)\nswitch value:\n    case \"a\":\n        print(\"Found A!\")\n        do_something()\n    case \"b\", \"c\":\n        print(\"Found B or C!\")\n        do_something_else()\n    default:\n        print(\"Unknown value\")\n\n// Mixed syntax in same switch with yield\nresult = switch value:\n    case 1:\n        complex_processing()\n        yield calculated_result    // Return value from case block\n    case 2 -&gt; simple_result\n    default -&gt; fallback_value\n\n// Yield multiple values\na, b = switch condition:\n    case \"pair\":\n        calculate_values()\n        yield first_result, second_result\n    case \"single\" -&gt; default_value, 0\n</code></pre>"},{"location":"reference/syntax/#loops","title":"Loops","text":""},{"location":"reference/syntax/#for-loops","title":"For Loops","text":"<pre><code>// Iterate over list\nitems = [\"a\", \"b\", \"c\"]\nfor item in items:\n    print(item)\n\n// Access loop index and total via context\nfor item in items with loop:\n    print(\"{loop.idx + 1}/{loop.src.len()}: {item}\")\n\n// Iterate with unpacking (for lists of lists)\ndata = [[\"alice\", 25], [\"bob\", 30], [\"charlie\", 35]]\nfor name, age in data:\n    print(name, age)\n\n// Unpacking WITH context\nfor name, age in data with loop:\n    print(loop.idx, name, age)\n\n// Multiple variable unpacking with zip\nnames = [\"alice\", \"bob\", \"charlie\"]\nages = [25, 30, 35]\ncities = [\"NYC\", \"LA\", \"Chicago\"]\nfor name, age, city in zip(names, ages, cities):\n    print(name, age, city)\n\n// With context\nfor name, age, city in zip(names, ages, cities) with loop:\n    print(loop.idx, name, age, city)\n\n// Iterate over map keys\nperson = {\"name\": \"alice\", \"age\": 25}\nfor key in person:\n    print(key, person[key])\n\n// Map iteration with context\nfor key in person with loop:\n    print(loop.idx, key, person[key])\n\n// Map with key and value\nfor key, value in person:\n    print(key, value)\n\n// Map with key, value, and context\nfor key, value in person with loop:\n    print(loop.idx, key, value)\n\n// Range iteration\nfor i in range(5):      // 0, 1, 2, 3, 4\n    print(i)\n</code></pre> <p>Loop Context Object</p> <p>When you use <code>with &lt;identifier&gt;</code> in a for-loop, you get access to a context object with these fields:</p> <ul> <li><code>idx</code> - Current iteration index (0-based)</li> <li><code>src</code> - Immutable snapshot of the original collection</li> </ul> <pre><code>items = [10, 20, 30]\nfor item in items with loop:\n    print(\"Index: {loop.idx}, Item: {item}, Total: {loop.src.len()}\")\n</code></pre>"},{"location":"reference/syntax/#while-loops","title":"While Loops","text":"<pre><code>// Basic while loop\ncount = 0\nwhile count &lt; 5:\n    print(count)\n    count++\n\n// Infinite loop with break\nwhile:\n    if condition:\n        break\n    // do something\n\n// Continue statement\nwhile condition:\n    if skip_condition:\n        continue\n    process_item()\n</code></pre>"},{"location":"reference/syntax/#additional-control-flow","title":"Additional Control Flow","text":""},{"location":"reference/syntax/#delete-statement","title":"Delete Statement","text":"<pre><code>// Delete variables or data structures\nmy_var = \"test\"\ndel my_var              // Remove variable from scope\n\nmy_list = [1, 2, 3, 4]\ndel my_list[0]         // Remove first element\n\nmy_map = {\"a\": 1, \"b\": 2}\ndel my_map[\"a\"]        // Remove key \"a\"\n</code></pre>"},{"location":"reference/syntax/#return-statement","title":"Return Statement","text":"<pre><code>fn calculate(x, y):\n    if x &lt; 0:\n        return error(\"negative values not allowed\")\n    result = x * y\n    return result      // Return single value\n\nfn get_coordinates():\n    x = 10\n    y = 20\n    return x, y        // Return multiple values\n\nfn early_exit():\n    if condition:\n        return         // Early return with no value\n    do_more_work()\n</code></pre>"},{"location":"reference/syntax/#yield-statement","title":"Yield Statement","text":"<pre><code>// Yield can only be used in switch case blocks to return values\n// (Examples shown in Switch Statements section above)\n\n// NOT valid - yield cannot be used in regular functions\n// fn generate_values():\n//     yield i        // This would be an error\n</code></pre>"},{"location":"reference/syntax/#functions","title":"Functions","text":""},{"location":"reference/syntax/#function-definition","title":"Function Definition","text":"<pre><code>// Function definitions use fn name(): syntax\nfn double(x):\n    return x * 2\n\nfn add(a, b):\n    return a + b\n\nfn greet():\n    print(\"Hello!\")\n\n// Block functions\nfn calculate(x, y):\n    result = x * y + 10\n    return result\n\n// Function with multiple return values\nfn coords(point):\n    x = point[\"x\"]\n    y = point[\"y\"]\n    return x, y\n\n// Anonymous functions can be assigned to variables\ndouble_var = fn(x) x * 2\nadd_var = fn(a, b) a + b\ngreet_var = fn() print(\"Hello!\")\n</code></pre>"},{"location":"reference/syntax/#function-calls","title":"Function Calls","text":"<pre><code>result = double(5)      // 10\nsum_val = add(3, 4)     // 7\n\n// UFCS (Uniform Function Call Syntax)\n\"hello\".upper()         // \"HELLO\"\n[1, 2, 3].len()        // 3\n\n// You're encouraged to use UFCS, especially to un-nest function calls.\nupper(trim(text))    // BAD\ntext.trim().upper()  // GOOD\n\n// Built-in function assignment to variables\nmy_upper = upper\n\"test\".my_upper()      // \"TEST\"\n</code></pre>"},{"location":"reference/syntax/#named-arguments","title":"Named Arguments","text":"<pre><code>print(\"hello\", \"world\", sep=\"|\")    // hello|world\n</code></pre>"},{"location":"reference/syntax/#list-comprehensions","title":"List Comprehensions","text":"<pre><code>// Basic comprehension\nnumbers = [1, 2, 3, 4, 5]\nsquares = [x * x for x in numbers]\n\n// With function calls\nwords = [\"hello\", \"world\"]\nuppers = [upper(word) for word in words]\n\n// Side effects (returns empty list)\n[print(x) for x in items]\n</code></pre>"},{"location":"reference/syntax/#argument-parsing","title":"Argument Parsing","text":""},{"location":"reference/syntax/#basic-arguments","title":"Basic Arguments","text":"<pre><code>args:\n    name str                    # Required string\n    age int                     # Required integer\n    height float               # Required float\n    verbose bool               # Required boolean\n\n    // Optional arguments\n    role str?                  # Optional string (null if not provided)\n    count int = 10            # Optional with default\n    debug d bool              # Short form flag\n</code></pre>"},{"location":"reference/syntax/#int-short-clustering","title":"Int Short Clustering","text":"<p>Int arguments with short forms can be \"clustered\" to increment the value:</p> <pre><code>args:\n    verbosity v int\n</code></pre> <pre><code>./script -v        # verbosity = 1\n./script -vv       # verbosity = 2\n./script -vvvvv    # verbosity = 5\n./script -vv -v=10 # verbosity = 10 (explicit value overrides)\n</code></pre> <p>This is useful for verbosity levels and similar patterns where users want quick increment syntax.</p>"},{"location":"reference/syntax/#argument-constraints","title":"Argument Constraints","text":"<pre><code>args:\n    status str\n    age int\n    email str\n    username str?\n    password str?\n\n    status enum [\"active\", \"inactive\", \"pending\"]\n    age range [0, 120]        // Inclusive range\n    age range (0, 120]        // Exclusive start, inclusive end\n    email regex \".*@.*\\\\..*\"\n    username requires password   // If username provided, password required\n</code></pre> <p>Relational constraints: - <code>a requires b</code> - <code>a mutually requires b</code> - <code>a excludes b</code> - <code>a mutually excludes b</code></p>"},{"location":"reference/syntax/#script-commands","title":"Script Commands","text":"<p>Organize CLI tools around subcommands, like <code>git commit</code> or <code>docker build</code>. The <code>args:</code> and <code>command</code> blocks must appear before any executable code.</p> <pre><code>#!/usr/bin/env rad\n---\nA deployment tool.\n---\n\n// Shared args available to all commands\nargs:\n    verbose v bool\n    config str = \"config.yaml\"\n\ncommand deploy:\n    ---\n    Deploy the application.\n    ---\n    env str\n    calls do_deploy\n\ncommand status:\n    ---\n    Check deployment status.\n    ---\n    env str\n    calls do_status\n\n// Shared setup - runs before any command callback\nvalidate_config(config)\n\nfn do_deploy():\n    if verbose:\n        print(\"Config: {config}\")\n    print(\"Deploying to {env}...\")\n\nfn do_status():\n    print(\"Status of {env}...\")\n</code></pre> <p>Usage: <code>./tool.rad deploy staging --verbose</code></p>"},{"location":"reference/syntax/#command-name-hyphenation","title":"Command Name Hyphenation","text":"<p>Command names follow the same underscore-to-hyphen convention as arguments. Define with underscores, invoke with hyphens:</p> <pre><code>command deploy_staging:\n    calls do_deploy_staging\n\n// Invoked as: ./tool.rad deploy-staging\n</code></pre>"},{"location":"reference/syntax/#inline-callbacks","title":"Inline Callbacks","text":"<pre><code>// Short implementations can use inline lambdas\ncommand greet:\n    name str\n    calls fn():\n        print(\"Hello, {name}!\")\n</code></pre>"},{"location":"reference/syntax/#automatic-help","title":"Automatic Help","text":"<ul> <li><code>./tool.rad -h</code> \u2014 lists all commands with descriptions</li> <li><code>./tool.rad deploy -h</code> \u2014 shows command-specific arguments</li> </ul>"},{"location":"reference/syntax/#shell-commands","title":"Shell Commands","text":""},{"location":"reference/syntax/#invocation-critical-by-default","title":"Invocation (<code>$</code>) \u2014 critical by default","text":"<p>Shell commands can be invoked with <code>$</code> and are critical by default: if the exit <code>code != 0</code>, an error will propagate unless you handle it. If an error propagates up to the root level of the script and doesn't get handled, it exits.</p> <pre><code>// Fails script if code != 0\n$`make build`\ncode = $`cmd`\ncode, stdout = $`cmd`\ncode, stdout, stderr = $`cmd`\n</code></pre>"},{"location":"reference/syntax/#capture-assignment","title":"Capture &amp; assignment","text":"<p>Capture behavior depends on how many variables you assign:</p> <pre><code>$`cmd`                        // No capture, stdout/stderr \u2192 terminal\ncode = $`cmd`                 // Capture code, stdout/stderr \u2192 terminal\ncode, stdout = $`cmd`         // Capture code &amp; stdout, stderr \u2192 terminal\ncode, stdout, stderr = $`cmd` // Capture all\n</code></pre> <p>Assignment semantics support both positional and named assignment.</p> <ul> <li>Shell commands conceptually return (code, stdout, stderr) in that order.</li> <li>Positional (default): when variable names are arbitrary, assignment is by position.</li> </ul> <pre><code>c, out = $`cmd`                     // c = code, out = stdout\nexit_code, output, err = $`cmd`     // exit_code = code, output = stdout, err = stderr\nmyvar, stdout = $`cmd`              // myvar = code, stdout = stdout (positional despite name)\n</code></pre> <ul> <li>Named: if all variables are exactly <code>code</code>, <code>stdout</code>, or <code>stderr</code>, assignment is by name (order independent).</li> </ul> <pre><code>stdout, code = $`cmd`     // stdout = stdout, code = code\nstderr = $`cmd`           // only capture stderr\ncode, stderr = $`cmd`     // capture code and stderr\n</code></pre> <p>Rule: If all variables use the exact names <code>code</code>, <code>stdout</code>, or <code>stderr</code>, uses named assignment. Otherwise, assignment is positional.</p>"},{"location":"reference/syntax/#handling-failures-with-a-catch-block","title":"Handling failures with a <code>catch</code> block","text":"<p>Use a suffix <code>catch:</code> block to handle non\u2011zero exit codes. Variables are already assigned to the actual results inside the block; you may log or reassign fallbacks, then execution continues.</p> <pre><code>code, stdout = $`grep hello file` catch:\n    // Runs because code != 0\n    print_err(\"grep failed with code {code}: {stdout}\")\n    stdout = \"\"  // example fallback\n</code></pre> <p>You can also attach <code>catch:</code> without capturing any variables:</p> <pre><code>$`make build` catch:\n    pass  // continue on failure (do nothing)\n\n$`make build` catch:\n    print_err(\"Build failed\")\n    exit(1)\n</code></pre>"},{"location":"reference/syntax/#shell-command-modifiers","title":"Shell Command Modifiers","text":"<p>Two modifiers control shell command behavior:</p> <pre><code>// quiet - suppresses the \u26a1\ufe0f command echo\nquiet $`make build`\ncode, stdout = quiet $`grep pattern file` catch:\n    stdout = \"\"\n\n// confirm - prompts user approval before running (useful for destructive ops)\nconfirm $`rm -rf node_modules`\n</code></pre> <p>Modifiers go after <code>=</code> in assignments: <code>result = quiet $</code>cmd<code>, not `quiet result = $`cmd</code>.</p>"},{"location":"reference/syntax/#json-processing-and-display-blocks","title":"JSON Processing and Display Blocks","text":""},{"location":"reference/syntax/#json-path-definitions","title":"JSON Path Definitions","text":"<pre><code>// Define JSON field mappings\nName = json.results[].name\nEmail = json.results[].email\nAge = json.results[].age\n\n// JSON path with wildcards\nAllFields = json.results[].*         // All fields in each result\nDeepFields = json.data.*.value       // Wildcard in path\nIndexed = json.items[0].name         // Specific index\n</code></pre>"},{"location":"reference/syntax/#rad-blocks","title":"Rad Blocks","text":"<pre><code>// Rad blocks do HTTP request + JSON extraction + print table (all-in-one)\nurl = \"https://api.example.com/users\"\nName = json.results[].name\nEmail = json.results[].email\n\nrad url:\n    fields Name, Email\n    sort Name\n    // Automatically prints formatted table after extraction\n</code></pre>"},{"location":"reference/syntax/#display-blocks","title":"Display Blocks","text":"<pre><code>// Display assumes lists are already populated and prints data as table\nnames = [\"alice\", \"bob\", \"charlie\"]\nages = [25, 30, 35]\n\n// Display with pre-populated lists (no data source)\ndisplay:\n    fields names, ages\n    sort ages desc, names\n\n// OR display with data source (runs JSON extraction + prints table)\ndata = [\n    {\"name\": \"alice\", \"age\": 25},\n    {\"name\": \"bob\", \"age\": 30}\n]\n\nName = json[].name\nAge = json[].age\ndisplay data:\n    fields Name, Age\n    sort Age desc, Name\n</code></pre>"},{"location":"reference/syntax/#field-modifiers","title":"Field Modifiers","text":"<p>Field modifiers transform or filter data before display. Apply them to specific fields:</p> <pre><code>ages = [15, 25, 30, 12]\nnames = [\"Alice\", \"Bob\", \"Charlie\", \"David\"]\n\ndisplay:\n    fields ages, names\n    ages:\n        filter fn(a) a &gt;= 18       // Keep only adults\n        map fn(a) \"{a} years\"      // Transform display\n\n// Output:\n// ages       names\n// 25 years   Bob\n// 30 years   Charlie\n</code></pre> <p>Filter removes rows where the predicate returns false. Map transforms values for display. Filter runs before map.</p> <pre><code>// Apply same modifier to multiple fields\nages, scores:\n    map fn(v) \"{v}!\"\n\n// Use a named function\nis_adult = fn(age) age &gt;= 18\nages:\n    filter is_adult\n</code></pre>"},{"location":"reference/syntax/#field-modifier-context","title":"Field Modifier Context","text":"<p>When a map or filter lambda accepts two parameters, the second receives a context object:</p> <pre><code>nums = [10, 20, 30]\ndisplay:\n    fields nums\n    nums:\n        map fn(x, ctx) \"{ctx.idx + 1}. {x}\"\n        // Output: \"1. 10\", \"2. 20\", \"3. 30\"\n</code></pre> <p>Context fields:</p> Field Type Description <code>idx</code> <code>int</code> Current row index (0-based) <code>src</code> <code>list</code> Immutable snapshot of the full column data <code>field</code> <code>str</code> Name of the field being processed <pre><code>// Filter to values below average\nnums:\n    filter fn(x, ctx) x &lt; sum(ctx.src) / ctx.src.len()\n\n// Show position in total\nnums:\n    map fn(x, ctx) \"{x} ({ctx.idx + 1}/{ctx.src.len()})\"\n</code></pre> <p>Single-parameter lambdas continue to work unchanged for simple transformations.</p>"},{"location":"reference/syntax/#advanced-features","title":"Advanced Features","text":""},{"location":"reference/syntax/#string-escape-sequences","title":"String Escape Sequences","text":"<pre><code>// Supported escape sequences in strings\ntext = \"Quote: \\\"Hello\\\"\"          // Escaped double quote\nsingle = 'It\\'s working'           // Escaped single quote  \nbacktick = `Backtick: \\`command\\`` // Escaped backtick\nnewline = \"Line 1\\nLine 2\"         // Newline\ntab = \"Column1\\tColumn2\"           // Tab\nbackslash = \"Path\\\\to\\\\file\"       // Literal backslash\nbrace = \"Not interpolated: \\{var}\" // Escaped brace (literal {)\n</code></pre>"},{"location":"reference/syntax/#defer-and-error-defer-blocks","title":"Defer and Error Defer Blocks","text":"<pre><code>// Defer block - runs before script ends regardless of success/failure\ndefer:\n    print(\"This always runs before script exits\")\n    cleanup_resources()\n\n// Error defer block - only runs before script ends if an error occurs\nerrdefer:\n    print(\"This only runs if script exits with error\")\n    emergency_cleanup()\n\nprocess_data()\n// More code can run here\nexit(0)  // defer blocks run just before this\n</code></pre>"},{"location":"reference/syntax/#request-blocks","title":"Request Blocks","text":"<pre><code>// Request blocks run JSON extraction algorithm but don't print table\n// They populate lists with extracted field data\nurl = \"https://api.example.com/users\"\nName = json.results[].name\nEmail = json.results[].email\n\nrequest url:\n    fields Name, Email\n    sort Name\n\n// After this block, Name and Email contain the extracted data\nprint(Name)  // [\"alice\", \"bob\", \"charlie\"]\nprint(Email) // [\"alice@example.com\", \"bob@example.com\", \"charlie@example.com\"]\n</code></pre>"},{"location":"reference/syntax/#advanced-function-features","title":"Advanced Function Features","text":"<pre><code>// Vararg parameters\nfn sum_all(*numbers: int):\n    total = 0\n    for num in numbers:\n        total += num\n    return total\n\nresult = sum_all(1, 2, 3, 4, 5)\n\n// Named-only parameters (after *)\nfn format_text(text: str, *, uppercase: bool = false, prefix: str = \"\"):\n    result = prefix + text\n    return uppercase ? upper(result) : result\n\nformatted = format_text(\"hello\", uppercase=true, prefix=\"&gt;&gt;&gt; \")\n\n// Complex type annotations  \nfn process_data(\n    input: list[str], \n    callback: fn(str) -&gt; bool,\n    options: {config: str, debug?: bool}\n) -&gt; error|{processed: int, failed: int}:\n    // function implementation\n    return {processed: 10, failed: 0}\n</code></pre>"},{"location":"reference/syntax/#map-dot-syntax","title":"Map Dot Syntax","text":"<pre><code>person = {\"name\": \"alice\", \"details\": {\"age\": 25}}\nname = person.name              // Same as person[\"name\"]\nage = person.details.age        // Nested access\n</code></pre>"},{"location":"reference/syntax/#error-handling","title":"Error Handling","text":"<p>Errors in Rad are values. Functions typically return <code>value | error</code>. By default, errors propagate and exit if unhandled.</p>"},{"location":"reference/syntax/#simple-fallback","title":"Simple fallback: <code>??</code>","text":"<p>Use <code>??</code> to provide a fallback value when the left side returns an error (right side is evaluated lazily).</p> <pre><code>result = text.parse_int() ?? 0\nresult = text.parse_int() ?? compute_fallback()\n// Multi-return requires an explicit list fallback\na, b = fallible_pair() ?? [0, 0]\n</code></pre>"},{"location":"reference/syntax/#complex-handling-suffix-catch","title":"Complex handling: suffix <code>catch:</code>","text":"<p>Attach a <code>catch:</code> block to inspect the error (the assigned variable is the error string inside the block), log, and/or reassign a fallback. Execution continues after the block, unless it invokes <code>exit()</code>.</p> <pre><code>value = text.parse_int() catch:\n    print_err(\"Parse failed: {value}\")\n    value = 0\n</code></pre> <p>For multi-return functions with <code>catch:</code>:</p> <pre><code>a, b = fallible_pair() catch:\n    // a = error string, b = null\n    print_err(\"Failed: {a}\")\n    a, b = 0, 0\n</code></pre>"},{"location":"reference/syntax/#operators","title":"Operators","text":""},{"location":"reference/syntax/#arithmetic","title":"Arithmetic","text":"<pre><code>a + b       // Addition\na - b       // Subtraction\na * b       // Multiplication\na / b       // Division\na % b       // Modulo\n</code></pre>"},{"location":"reference/syntax/#comparison","title":"Comparison","text":"<pre><code>a == b      // Equal\na != b      // Not equal\na &lt; b       // Less than\na &lt;= b      // Less than or equal\na &gt; b       // Greater than\na &gt;= b      // Greater than or equal\n</code></pre>"},{"location":"reference/syntax/#logical","title":"Logical","text":"<pre><code>a and b     // Logical AND\na or b      // Logical OR\nnot a       // Logical NOT\n</code></pre>"},{"location":"reference/syntax/#membership","title":"Membership","text":"<pre><code>item in collection      // Check if item exists in collection\nitem not in collection  // Check if item doesn't exist\n</code></pre>"},{"location":"reference/syntax/#coalescing-operator","title":"Coalescing Operator (<code>??</code>)","text":"<p>The <code>??</code> operator yields the left value if it is not null or an error; otherwise it evaluates and yields the right-hand side. Useful for concise fallbacks when calling fallible functions or handling nullable values.</p> <pre><code>count = get_env(\"COUNT\").parse_int() ?? 0\ndata = read_file(\"config.txt\") ?? {\"content\": \"\"}\na, b = some_fallible_fn() ?? [0, 0]  // multi-return requires list fallback\n</code></pre>"},{"location":"reference/syntax/#error-catching-operator-catch","title":"Error Catching Operator (<code>catch</code>)","text":"<p>The <code>catch</code> operator catches errors from the left side and returns the right side instead. Unlike <code>??</code>, it only catches errors - <code>null</code> values pass through.</p> <pre><code>count = parse_int(input_str) catch 0\ndata = parse_json(raw) catch {}\nresult = risky_call() catch fallback_call() catch \"final\"\n</code></pre> <p><code>catch</code> is distinct from the <code>catch:</code> block syntax. The operator form is an inline expression, while <code>catch:</code> is a block attached to statements.</p>"},{"location":"reference/syntax/#scoping-and-variables","title":"Scoping and Variables","text":"<pre><code>// Global scope\nglobal_var = \"global\"\n\nif true:\n    // Can access global variables\n    print(global_var)\n\n    // Variables defined in blocks persist after the block\n    block_var = \"accessible\"\n\n// block_var IS accessible here\nprint(block_var)  // Works fine\n\n// Variables defined in for loops also persist\nfor i in range(3):\n    loop_var = \"also accessible\"\n\nprint(i)          // Last value: 2\nprint(loop_var)   // \"also accessible\"\n\n// Function closures with anonymous functions assigned to variables\nouter_var = 10\nfn_with_closure = fn(x):\n    return x + outer_var    // Can access outer_var\n</code></pre>"},{"location":"reference/syntax/#built-in-types-and-methods","title":"Built-in Types and Methods","text":"<p>For a complete reference of all built-in functions, see: https://amterp.github.io/rad/reference/functions/</p>"},{"location":"reference/syntax/#string-methods","title":"String Methods","text":"<pre><code>text = \"hello world\"\ntext.upper()            // \"HELLO WORLD\"\ntext.lower()            // \"hello world\" \ntext.split(\" \")         // [\"hello\", \"world\"]\ntext.replace(\"hello\", \"hi\")  // \"hi world\"\n</code></pre>"},{"location":"reference/syntax/#list-methods","title":"List Methods","text":"<pre><code>items = [3, 1, 4, 1, 5]\nitems.len()             // 5\nitems.sort()            // Returns sorted copy\nitems.reverse()         // Returns reversed copy\n</code></pre>"},{"location":"reference/syntax/#type-checking","title":"Type Checking","text":"<pre><code>// Runtime type checking happens automatically\n// Type errors will be caught during execution\n</code></pre>"},{"location":"reference/syntax/#type-system","title":"Type System","text":"<p>Rad has a dynamic type system with runtime type checking. Here are the type annotations used in function signatures and documentation:</p>"},{"location":"reference/syntax/#basic-types","title":"Basic Types","text":"<pre><code>str           // String type\nint           // Integer type  \nfloat         // Float type\nbool          // Boolean type\nany           // Any type (dynamic)\nvoid          // No return value\nerror         // Error type\n</code></pre>"},{"location":"reference/syntax/#collection-types","title":"Collection Types","text":"<pre><code>list          // List of any type\nlist[T]       // List of specific type T\nstr[]         // List of strings (shorthand for list[str])\nany[]         // List of any type\nmap           // Map/object with any keys/values\nmap[K,V]      // Map with specific key/value types\n</code></pre>"},{"location":"reference/syntax/#optional-types","title":"Optional Types","text":"<pre><code>str?          // Optional string (can be null)\nany?          // Optional any type  \nint?          // Optional integer\n</code></pre>"},{"location":"reference/syntax/#union-types","title":"Union Types","text":"<pre><code>int|float     // Either int or float\nstr|list      // Either string or list\nerror|str     // Either error or string (common for fallible operations)\n</code></pre>"},{"location":"reference/syntax/#enum-types","title":"Enum Types","text":"<pre><code>[\"option1\", \"option2\"]        // Enum with specific string values\n[\"auto\", \"seconds\", \"millis\"] // Enum for time units\n</code></pre>"},{"location":"reference/syntax/#function-types","title":"Function Types","text":"<pre><code>fn(any) -&gt; any                     // Function taking any, returning any\nfn(any, any) -&gt; bool               // Function taking two any params, returning bool\nfn() -&gt; any                        // Function with no params, returning any\n</code></pre>"},{"location":"reference/syntax/#complex-return-types","title":"Complex Return Types","text":"<pre><code>// Map with specific structure\n{ \"exists\": bool, \"size\"?: int }\n\n// Map with optional fields (? suffix)\n{ \"content\": str, \"created\"?: bool }\n\n// Nested structures\n{ \"epoch\": { \"seconds\": int, \"millis\": int } }\n</code></pre>"},{"location":"reference/syntax/#variadic-parameters","title":"Variadic Parameters","text":"<pre><code>*_items: any          // Variable number of any type\n*_others: list|str    // Variable number of lists or strings\n</code></pre>"},{"location":"reference/syntax/#named-parameters","title":"Named Parameters","text":"<pre><code>// Required named parameter\nfunc(*, required_param: str)\n\n// Optional named parameter with default\nfunc(*, optional_param: str = \"default\")\n\n// Mixed positional and named\nfunc(_pos: str, *, named: int = 5)\n</code></pre>"},{"location":"reference/syntax/#parameter-constraints","title":"Parameter Constraints","text":"<pre><code>// Parameter with underscore prefix (positional-only)\n_path: str\n\n// Named parameter (after *)\nsep: str = \" \"\n\n// Optional with default value\nend: str = \"\\n\"\n</code></pre>"},{"location":"reference/syntax/#real-examples-from-built-ins","title":"Real Examples from Built-ins","text":"<pre><code>print(*_items: any, *, sep: str = \" \", end: str = \"\\n\") -&gt; void\nrange(_arg1: float|int, _arg2: float?|int?, _step: float|int = 1) -&gt; list[float|int] \nzip(*_lists: list, *, fill: any?, strict: bool = false) -&gt; error|list[]\nread_file(_path: str, *, mode: [\"text\", \"bytes\"] = \"text\") -&gt; error|{ \"size_bytes\": int, \"content\": str|[int] }\n</code></pre>"},{"location":"reference/syntax/#rad-code-style","title":"Rad Code Style","text":""},{"location":"reference/syntax/#argument-block-formatting","title":"Argument Block Formatting","text":"<pre><code>// Good: Group args together, then constraints with empty line separation\nargs:\n    name str           # Required string argument\n    count int = 5      # Optional with default\n    verbose v bool     # Boolean flag with short form\n    email str?         # Optional argument\n\n    name regex \"^[a-zA-Z]+$\"\n    count range [1, 100]\n    email requires verbose\n</code></pre>"},{"location":"reference/syntax/#comment-alignment","title":"Comment Alignment","text":"<p>As a convention, align comments 2 spaces from the longest argument in the aligned group.</p> <pre><code>// Good: Align comments within reason (2 spaces from longest)\nargs:\n    name str        # User's full name\n    age int         # Age in years\n    email str?      # Contact email\n    very_long_param str  # Don't align with this one if it's much longer\n    city str        # Align with the shorter ones instead\n\n// Bad: Inconsistent alignment\nargs:\n    name str      # User's full name\n    age int            # Age in years\n    email str?  # Contact email\n</code></pre>"},{"location":"reference/syntax/#shell-command-delimiters","title":"Shell Command Delimiters","text":"<pre><code>// Good: Prefer backticks to avoid delimiter conflicts\nresult = $`echo \"Hello world\"`\noutput = $`grep 'pattern' file.txt`\nstatus = $`curl -H \"Content-Type: application/json\" api.example.com`\n\n// Avoid: Quotes can conflict with shell command content\n// result = $\"echo \"Hello world\"\"  // This breaks\n</code></pre>"},{"location":"reference/syntax/#variable-naming","title":"Variable Naming","text":"<pre><code>// Good: Use snake_case for variables\nuser_name = \"alice\"\nmax_retry_count = 3\nis_valid = true\n\n// Good: Common abbreviations are fine for CLI scripting\nmsg = \"Hello world\"\nreq = http_get(url)\ncfg = load_config()\nargs = get_args()\n\n// Good: Use descriptive names when clarity matters\nuser_data = load_user_info()\nprocessed_items = filter(items, is_active)\n\n// Avoid: Unclear single letters and confusing abbreviations\nx = load_user_info()  // Too generic\na, b = 1, 2          // Meaningless names\nusr_nm = \"alice\"     // Unclear abbreviation\n</code></pre>"},{"location":"reference/syntax/#function-definition-style","title":"Function Definition Style","text":"<pre><code>// Good: Clear, descriptive function names\nfn calculate_tax(amount, rate):\n    return amount * rate\n\nfn validate_email(email):\n    return \"@\" in email and \".\" in email\n\n// Good: Anonymous functions for simple operations (note lack of colon)\ndouble = fn(x) x * 2\nis_even = fn(n) n % 2 == 0\n</code></pre>"},{"location":"reference/syntax/#control-flow-formatting","title":"Control Flow Formatting","text":"<pre><code>// Good: Consistent indentation and spacing\nif user.is_admin:\n    print(\"Admin access granted\")\n    log_admin_action(user.name)\nelse if user.is_moderator:\n    print(\"Moderator access granted\")\nelse:\n    print(\"Regular user access\")\n\n// Good: Switch formatting\nresult = switch status:\n    case \"active\" -&gt; \"Running\"\n    case \"paused\" -&gt; \"Waiting\" \n    case \"stopped\" -&gt; \"Inactive\"\n    default -&gt; \"Unknown\"\n</code></pre>"},{"location":"reference/syntax/#collection-and-data-structure-style","title":"Collection and Data Structure Style","text":"<pre><code>// Good: Readable list formatting with trailing commas\nusers = [\n    {\"name\": \"alice\", \"role\": \"admin\"},\n    {\"name\": \"bob\", \"role\": \"user\"},\n    {\"name\": \"charlie\", \"role\": \"moderator\"},\n]\n\n// Good: Multiline maps with trailing commas\nconfig = {\n    \"host\": \"localhost\",\n    \"port\": 8080,\n    \"debug\": true,\n}\n\n// Good: Simple lists on one line when short\ncolors = [\"red\", \"green\", \"blue\"]\nnumbers = [1, 2, 3, 4, 5]\n\n// Good: Clear JSON path definitions\nUserName = json.users[].name\nUserEmail = json.users[].email  \nUserRole = json.users[].role\n</code></pre>"},{"location":"reference/syntax/#string-interpolation-style","title":"String Interpolation Style","text":"<pre><code>// Good: Clear variable interpolation\nmessage = \"Hello {user_name}, you have {message_count} messages\"\nfile_path = \"{base_dir}/{filename}.txt\"\n\n// Good: Format specifiers for numbers\nprice = \"Total: ${amount:.2}\"\npercentage = \"Progress: {progress:.1}%\"\n</code></pre>"},{"location":"reference/syntax/#error-handling-style","title":"Error Handling Style","text":"<pre><code>// Good: Clear handling with suffix catch:\nuser_data = load_user(user_id) catch:\n    print_err(\"Failed to load user data: {user_id}\")\n    exit(1)\n\n// Good: Simple fallback with ?? (right side evaluated lazily)\nbackup_data = load_backup() ?? {\"version\": \"none\"}\n\n// Good: Multi-return fallback with ?? list\na, b = risky_pair() ?? [0, 0]\n\n// Good: Shell command handling with catch\ncode, stdout = $`potentially_failing_command` catch:\n    print_err(\"Command failed with code {code}\")\n    stdout = \"\"\n</code></pre>"}]}