{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Rad","text":""},{"location":"#new","title":"New?","text":"<p>Check out the Getting Started guide!</p>"},{"location":"#reference","title":"Reference","text":"<p>See 'Reference' in the side panel.</p> <p>These docs are still a work in progress!</p> <p>These docs are actively being worked on at the moment, and there are critical sections missing.</p> <p>The Guide is pretty substantial and gives you quite a lot to go on, feel free to check it out!</p>"},{"location":"guide/args/","title":"Args","text":"<p>This section covers syntax for defining arguments that your script can accept.</p>"},{"location":"guide/args/#arg-declarations","title":"Arg Declarations","text":"<p>RSL takes a declarative approach to arguments. You simply declare what arguments your script accepts, and let RSL take care of the rest, including parsing user input.</p> <p>Arguments are declared as part of an args block.</p> <p>Here's an example for a script we'll call <code>printwords</code> which prints an input word N number of times:</p> <pre><code>args:\n    word string\n    repeats int\n\nfor _ in range(repeats):\n    print(word)\n</code></pre> <p>We can print its usage string using the <code>--help</code> flag:</p> <pre><code>rad printwords --help\n</code></pre> <pre><code>Usage:\n  printwords &lt;word&gt; &lt;repeats&gt;\n\nScript args:\n      --word string\n      --repeats int\n</code></pre> <p>This script defines two mandatory arguments: <code>word</code> that is expected to be a string, and <code>repeats</code> which is expected to be an integer.</p> <p>Some important things to note:</p> <ul> <li>All arguments can be defined positionally or via a flag.</li> <li>The positional ordering of args follows the order of declaration in the block.</li> <li>Flags are automatically generated and can be used by users to pass values for that argument, instead of doing it positionally.</li> </ul> <p>Let's look at a more complex example to demonstrate some more features. Let's call it <code>wordjoin</code>.</p> <pre><code>args:\n    words string[]  # Words to join together.\n    joiner j string = \"-\"  # Joiner for the words.\n    should_capitalize \"capitalize\" c bool  # If true, capitalize the words.\n\nif should_capitalize:\n    words = words[upper(w) for w in words]\n\nprint(join(words, joiner))\n</code></pre> <p>If we run <code>--help</code> on this one:</p> <pre><code>rad wordjoin --help\n</code></pre> <pre><code>Usage:\n  wordjoin &lt;words&gt; [joiner] [-c, --capitalize]\n\nScript args:\n      --words string,string    Words to join together.\n      -j, --joiner string      Joiner for the words. (default -)\n      -c, --capitalize         If true, capitalize the words.\n</code></pre> <p>Let's break down each declaration to see what's going on here.</p> <ol> <li><code>words string[]  # Words to join together.</code></li> </ol> <p>We declare an arg <code>words</code> which is a list of strings. Note that <code>int[]</code>, <code>float[]</code> and <code>bool[]</code> can be used for int, float, and bool lists respectively. We also define an arg comment to make the usage string include a description of what the argument is.</p> <ol> <li><code>joiner j string = \"-\"  # Joiner for the words.</code></li> </ol> <p>We declare a second argument, this one a string called <code>joiner</code>. We also define a shorthand flag <code>j</code>, allowing users to specify the arg with a simple <code>-j</code> flag. After that, we define a default for this parameter that will be used if the user doesn't provide one. We finish with another arg comment.</p> <ol> <li><code>should_capitalize \"capitalize\" c bool  # If true, capitalize the words.</code></li> </ol> <p>We declare our final argument <code>should_capitalize</code>. We rename it with <code>\"capitalize\"</code>, which will be what users see exposed to them, instead of the initial variable name. <code>should_capitalize</code> will remain the name of the variable to be referenced throughout the script. We define a shorthand <code>c</code>, and specify the parameter is a <code>bool</code> before finally giving it an arg comment.</p> <p>Bool args are always false by default.</p> <p>To bring it all together, this is the anatomy of an arg declaration (<code>&lt;angle brackets&gt;</code> represent it's required, <code>[square brackets]</code> indicate it's optional):</p> <p><code>&lt;name&gt; [rename] [shorthand flag] &lt;type&gt; [= default] [# arg comment]</code></p> <p>Feel free to go back up and check this against the example scripts we wrote, you'll see how each one fits this mold.</p>"},{"location":"guide/args/#constraints","title":"Constraints","text":"<p>In addition to declaring the arguments themselves, RSL also allows you to declare constraints on those arguments, such as what kinds of values are valid.</p> <p>By doing this in the args block, RSL can use this information to validate input for you, and automatically include in the information in your script's usage string.</p> <p>If a user gives an input which doesn't meet one of the listed constraints, rad will print:</p> <ol> <li> <p>The specific error and constraint that was violated.</p> </li> <li> <p>The usage string.</p> </li> </ol>"},{"location":"guide/args/#enums","title":"Enums","text":"<p>If you have a string argument where you really only want to accept some limited number of known values, you can use an enum constraint.</p> <p>Let's use a simple example, we'll call the script <code>colors</code>:</p> <pre><code>args:\n    color string\n    color enum [\"red\", \"green\", \"blue\"]\nprint(\"You like {color}!\")\n</code></pre> <p>If we print the usage string, you can see it tells users what values are valid:</p> <pre><code>rad colors --help\n</code></pre> <pre><code>Usage:\n  colors &lt;color&gt;\n\nScript args:\n      --color string    Valid values: [red, green, blue].\n</code></pre> <p>If we invoke this script with a value outside the listed valid values:</p> <pre><code>rad colors yellow\n</code></pre> <pre><code>Invalid 'color' value: yellow (valid values: red, green, blue)\nUsage:\n  colors &lt;color&gt;\n\nScript args:\n      --color string    Valid values: [red, green, blue].\n</code></pre> <p>Whereas using a valid value will run the script as intended:</p> <pre><code>rad colors green\n</code></pre> <pre><code>You like green!\n</code></pre>"},{"location":"guide/args/#regex","title":"Regex","text":"<p>If you'd like input strings to match a certain pattern, you can do that via a regex constraint.</p> <pre><code>args:\n    name string\n    name regex \"[A-Z][a-z]*\"\nprint(\"Hi, {name}\")\n</code></pre> <p>In this example, a valid <code>name</code> value must start with a capital letter, and can then be followed by any number of lowercase letters. No other characters will be accepted, so <code>Alice</code> will be a valid value, but <code>bob</code> or <code>John123</code> are not.</p> <p>As with other constraints, rad will validate input against this regex, and if it doesn't match, it will print an error. The constraint is also printed in the script's usage string.</p>"},{"location":"guide/args/#learnings-summary","title":"Learnings Summary","text":"<ul> <li>RSL takes a declarative approach to args. Rad handles parsing user input.</li> <li>All args can be specified positionally or via a flag from the user.</li> <li> <p>The anatomy of an arg declaration is this:</p> <p><code>&lt;name&gt; [rename] [shorthand flag] &lt;type&gt; [= default] [# arg comment]</code></p> </li> <li> <p>You can apply constraints to arguments inside the arg block, such as <code>enum</code> and <code>regex</code> constraints.</p> </li> <li>Details in the arg block are used by rad to provide a better usage/help string.</li> </ul>"},{"location":"guide/args/#next","title":"Next","text":"<p>Nice, let's now look at another RSL feature which makes it uniquely suited to certain types of scripting: Rad Blocks.</p>"},{"location":"guide/basics/","title":"Basics","text":"<p>This section of the guide will rapidly cover the basics of RSL. RSL shares a lot of conventions and syntax with popular languages like Python, so if you're familiar with programming, this will be pretty straightforward.</p>"},{"location":"guide/basics/#variables-assignment","title":"Variables &amp; Assignment","text":"<p>To create a variable, you can do it through assignment. Let's use a string example:</p> <pre><code>name = \"Alice\"\n</code></pre> <p>You can re-assign variables. Types don't need to stay the same:</p> <pre><code>name = 2\n</code></pre> <p>You cannot create multiple variables this way on one line.</p> <p>The following is illegal syntax</p> <pre><code>a, b = \"one\", \"two\"\n</code></pre> <p>instead, declare each variable on one line.</p> <pre><code>a = \"one\"\nb = \"two\"\n</code></pre>"},{"location":"guide/basics/#data-types","title":"Data Types","text":"<p>RSL has 6 data types: strings, ints, floats, bools, lists, and maps. </p>"},{"location":"guide/basics/#string","title":"string","text":"<p>Strings can be delimited in three ways:</p> <ol> <li>Double quotes: <code>\"text\"</code></li> <li>Single quotes: <code>'text'</code></li> <li>Backticks: <code>`text`</code></li> </ol> <p>All three behave the same way. To demonstrate:</p> <pre><code>greeting = \"Hello!\"\nprint(greeting)\n\ngreeting = 'Hello!'\nprint(greeting)\n\ngreeting = `Hello!`\nprint(greeting)\n</code></pre> <pre><code>Hello!\nHello!\nHello!\n</code></pre> <p>Why 3 different delimiters?</p> <p>Having 3 different delimiters is particularly useful when you want your string to contain one (or more) of the delimiter characters.</p> <p>For example, if you want a double quote in your string, you can use double quote delimiters and escape them:</p> <pre><code>\"She said \\\"Goodbye\\\"\"\n</code></pre> <p>However, this can be finicky and hard to read. Instead, you can pick one of the other two delimiters, for example:</p> <pre><code>'She said \"Goodbye\"'\n`She said \"Goodbye\"`\n</code></pre> <p>We'll cover this again later, but as a note, backticks can be particularly useful in shell commands, as shell/bash commands may include single or double quotes, and backticks save us from having to escape them.</p> <p>Strings can include special characters such as <code>\\n</code> for new lines and <code>\\t</code> for tabs.</p> <pre><code>print(\"Hello\\tdear\\nreader!\")\n</code></pre> <pre><code>Hello   dear\nreader!\n</code></pre> <p>Strings also support interpolation. String interpolation allows you to write expressions inside your string that will be evaluated and replaced for the final string. We'll cover this in more depth in a future section, but to give a very simple example:</p> <pre><code>name = \"Alice\"\nprint(\"Hi, {name}!\")\n</code></pre> <pre><code>Hi, Alice!\n</code></pre> <p>Anything encapsulated in a <code>{}</code> gets treated as an expression. Here, the expression is just the identifier <code>name</code>, which gets evaluated and substituted, giving us the final <code>Hi, Alice!</code> string.</p> <p>Those are the basics for strings - we'll cover additional string concepts in a future section, Strings (Advanced).</p>"},{"location":"guide/basics/#int","title":"int","text":"<p>RSL has ints. There's nothing unusual about them. Example:</p> <pre><code>team_size = 20\ncelsius = -5\n</code></pre> <p>Note that if you divide two ints, you will get back a float.</p> <pre><code>liters = 10\npeople = 4\nprint(\"This is a float:\", liters / people)\n</code></pre> <pre><code>This is a float: 2.5\n</code></pre>"},{"location":"guide/basics/#float","title":"float","text":"<p>The other number type is float:</p> <pre><code>length_meters = 2.68\n</code></pre> <p>If you want to define a whole number as a float, simply include a decimal place:</p> <pre><code>years = 20.0\n</code></pre>"},{"location":"guide/basics/#bool","title":"bool","text":"<p>RSL uses lowercase <code>true</code> / <code>false</code>:</p> <pre><code>is_running = true\nis_tired = false\n</code></pre>"},{"location":"guide/basics/#list","title":"list","text":"<p>RSL has two collection types: lists and maps. First, let's look at lists. These are also sometimes referred to as 'arrays' in other languages.</p> <pre><code>names = [\"alice\", \"bob\", \"charlie\"]\n</code></pre> <p>Lists you define can contain any types:</p> <pre><code>mixed = [\"alice\", true, 50, -2.4]\n</code></pre> <p>They can also be nested:</p> <pre><code>nested = [\"alice\", [1, [\"very nested\", \"ahhh\"]]]\n</code></pre> <p>Indexing and slicing works very similarly to Python. If we assume the 3 variables above exist, you can index with both positive and negative indexes:</p> <pre><code>print(names[0])\nprint(mixed[-1])  // grab last element in the list\nprint(nested[1][1][0])\n</code></pre> <pre><code>alice\n-2.4\nvery nested\n</code></pre> <p>And also you can slice:</p> <pre><code>numbers = [10, 20, 30, 40, 50]\nprint(numbers[1:3])\nprint(numbers[2:])\nprint(numbers[:-1])\n</code></pre> <pre><code>[20, 30]\n[30, 40, 50]\n[10, 20, 30, 40]\n</code></pre>"},{"location":"guide/basics/#map","title":"map","text":"<p>The last type, and second of two collection types, is a 'map'. These may also be referred to as 'hashmap' or 'dictionary' in other languages.</p> <pre><code>scores = { \"alice\": 25, \"bob\": 17, \"charlie\": 36 }\n</code></pre> <p>Like lists, they can contain mixed types for values, and can nest. However, keys must be strings.</p> <pre><code>mixed_map = { \n  \"alice\": \"accountant\",\n  \"mylist\": [ \"London\", 25 ],\n}\n\nnested_map = {\n  \"error\": {\n    \"msg\": \"Request failed!\",\n    \"code\": 400,\n  }\n}\n</code></pre> <p>If we take the above example, values can then be accessed in two ways. First is the square bracket lookup:</p> <pre><code>print(mixed_map[\"alice\"])\nprint(nested_map[\"error\"][\"msg\"])\n</code></pre> <pre><code>accountant\nRequest failed!\n</code></pre> <p>Alternatively, you can use a dot syntax. Note this second way only works for keys with no spaces in the name.</p> <pre><code>print(mixed_map.alice)\nprint(nested_map.error.msg)\n</code></pre> <pre><code>accountant\nRequest failed!\n</code></pre> <p>You can modify maps using either syntax:</p> Using brackets<pre><code>mymap = { \"alice\": 30 }\n\nmymap[\"alice\"] = 40\nprint(mymap)\n\nmymap.alice = 50\nprint(mymap)\n</code></pre> <pre><code>{ alice: 40 }\n{ alice: 50 }\n</code></pre> <p>You can also add keys this way:</p> <pre><code>mymap = { \"alice\": 30 }\nmymap[\"bob\"] = 31\nmymap.charlie = 32\nprint(mymap)\n</code></pre> <pre><code>{ alice: 30, bob: 31, charlie: 32 }\n</code></pre>"},{"location":"guide/basics/#operators","title":"Operators","text":"<p>RSL offers operators similar to many other languages. Below sections very quickly demonstrate.</p>"},{"location":"guide/basics/#arithmetic","title":"Arithmetic","text":"<p>RSL follows the standard order of operations for operators <code>() , + , - , * , / , %</code>:</p> <ol> <li>Parentheses</li> <li>Multiplication, Division, Modulo</li> <li>Addition, Subtraction</li> </ol> <pre><code>print(1 + 4 / 2)    // 3\nprint(2.5 * 3 - 1)  // 6.5\nprint((4 + 5) * 2)  // 18\nprint(5 % 3)        // 2\n</code></pre> <p>Dividing two integers will result in a floating point number.</p> <pre><code>print(5 / 2)  // 2.5\n</code></pre>"},{"location":"guide/basics/#comparison","title":"Comparison","text":"<p>Comparisons return bools that can be used in e.g. if statements.</p> <p>String comparison is done based on contents.</p> <pre><code>print(\"alice\" == \"alice\")  // true\nprint(\"alice\" == \"bob\")    // false\nprint(\"alice\" != \"bob\")    // true\nprint(\"alice\" == \"Alice\")  // false\n</code></pre> <p>Numbers can also be compared with the standard comparators <code>&gt; , &gt;= , &lt; , &lt;= , ==</code>.</p> <pre><code>print(2 &gt;= 2)  // true\nprint(2 &gt; 2)   // false\nprint(2 &lt;= 2)  // true\nprint(2 &lt; 2)   // false\nprint(2 == 2)  // false\n</code></pre> <p>You cannot use these operators (outside of <code>==</code>) to compare non-numbers such as strings:</p> <pre><code>print(\"alice\" &gt; \"bob\")  // error\n</code></pre> <p>But you can check them for equality (will always return false, except ints and floats that are equal):</p> <pre><code>print(2 == \"alice\")  // false\nprint(2 == 2.0)      // true\n</code></pre> <p>Difference From Python on <code>True == 1</code> and <code>False == 0</code></p> <p>In Python, <code>False == 0</code> and <code>True == 1</code> are true, because under the hood, False is really int 0 and True is really int 1, hence they're equal. That's not the case in RSL. In RSL, any two values of different types are not equal.</p> <p>The reasoning stems from truthy/falsy-ness. In Python, both <code>1</code> and <code>2</code> are truthy. But only <code>1</code> equals <code>True</code>. RSL avoids this oddity of making <code>1</code> special by instead making any two different types not equal (except ints/floats).</p>"},{"location":"guide/basics/#logical","title":"Logical","text":"<p>RSL uses <code>and</code> and <code>or</code> for binary logical operations.</p> <pre><code>print(false and false)  // false\nprint(false and true)   // false\nprint(true  and false)  // false\nprint(true  and true)   // true\n\nprint(false or  false)  // false\nprint(true  or  false)  // true\nprint(false or true)    // true\nprint(true  or  true)   // true\n</code></pre> <p>And it uses <code>not</code> for logical negation.</p> <pre><code>print(not true)   // false\nprint(not false)  // true\n</code></pre>"},{"location":"guide/basics/#concatenation","title":"Concatenation","text":"<p>You can concatenate strings with <code>+</code>. </p> <pre><code>first = \"Alice\"\nlast = \"Bobson\"\nprint(first + last)\n</code></pre> <pre><code>Alice Bobson\n</code></pre> <p>You cannot concatenate a string and a non-string. First convert the non-string into a string.</p> <p>This can be done in several ways, the easiest is probably via string interpolation:</p> <pre><code>a = 5\ntext = \"Number: \"\nprint(text + \"{a}\")\n</code></pre> <pre><code>Number: 5\n</code></pre>"},{"location":"guide/basics/#compound-operators","title":"Compound Operators","text":"<pre><code>a = 3\na += 2   // a is now 5\na -= 1   // a is now 4\na *= 3   // a is now 12\na %= 10  // a is now 2\na /= 4   // a is now 0.5\n</code></pre>"},{"location":"guide/basics/#increment-decrement","title":"Increment / Decrement","text":"<p>You can quickly increment and decrement ints and floats using <code>++</code> and <code>--</code> syntax.</p> <pre><code>a = 2\na++\nprint(a)\n\nb = 2.5\nb--\nprint(b)\n</code></pre> <pre><code>3\n1.5\n</code></pre> <p>The increment and decrement operators produce statements, not expressions. This means that <code>a++</code> does not return anything, and so cannot be used inside e.g. a conditional.</p> <p>For example, the following two uses are invalid, because <code>a++</code> doesn't return a value:</p> <pre><code>a = 5\nif a++ &gt; 0:  // invalid, nothing for &gt; to evaluate against on the left side\n  ...\n\nb = a++  // also invalid because a++ doesn't return any value\n</code></pre> <p>Because of that, there's also no reason to support pre-incrementing, and so <code>++a</code> or <code>--a</code> are invalid statements.</p>"},{"location":"guide/basics/#ternary","title":"Ternary","text":"<p>RSL supports <code>? :</code> style ternary operators. </p> <p><code>&lt;condition&gt; ? &lt;true case&gt; : &lt;false case&gt;</code></p> <pre><code>a = 5\nb = a &gt; 0 ? \"larger than 0\" : \"less than 0\"\nprint(b)\n</code></pre> <pre><code>larger than 0\n</code></pre>"},{"location":"guide/basics/#control-flow","title":"Control Flow","text":""},{"location":"guide/basics/#if-statements","title":"If Statements","text":"<p>RSL employs very standard if statements.</p> <p>You are not required to wrap conditions in parentheses <code>()</code>.</p> <pre><code>if units == \"metric\":\n  print(\"That's 10 meters.\")\nelse if units == \"imperial\":\n  print(\"That's almost 33 feet.\")\nelse:\n  print(\"I don't know what measurement system!\")\n</code></pre>"},{"location":"guide/basics/#for-loops","title":"For Loops","text":"<p>RSL allows \"for each\" loops for iterating through collections such as lists.</p> <pre><code>names = [\"Alice\", \"Bob\", \"Charlie\"]\nfor name in names:\n  print(\"Hi {name}!\")\n</code></pre> <pre><code>Hi Alice!\nHi Bob!\nHi Charlie!\n</code></pre> <p>You can also iterate through a range of numbers using the <code>range</code> function, which returns a list of numbers within some specified range.</p> <pre><code>for i in range(5):\n  print(i)\n</code></pre> <pre><code>0\n1\n2\n3\n4\n</code></pre> <p>You can also invoke <code>range</code> with a starting value i.e. <code>range(start, end)</code> and with a step value i.e. <code>range(start, end, step)</code>.</p> <p>If you want to iterate through a list while also having a variable for the item's index, you can do that by adding in an additional variable after the <code>for</code>. The first variable will be the index, and the second the item.</p> <pre><code>names = [\"Alice\", \"Bob\", \"Charlie\"]\nfor i, name in names:\n  print(\"{name} is at index {i}\")\n</code></pre> <pre><code>Alice is at index 0\nBob is at index 1\nCharlie is at index 2\n</code></pre> <p>When iterating through a map, if you have one variable in the loop, then that variable will be the key:</p> <pre><code>colors = { \"alice\": \"blue\", \"bob\": \"green\" }\nfor k in colors:\n  print(k)\n</code></pre> <pre><code>alice\nbob\n</code></pre> <p>If you have two, then the first will be the key, and the second will be the value.</p> <pre><code>colors = { \"alice\": \"blue\", \"bob\": \"green\" }\nfor k, v in colors:\n  print(k, v)\n</code></pre> <pre><code>alice blue\nbob green\n</code></pre> <ul> <li>TBC</li> <li>switch</li> </ul>"},{"location":"guide/basics/#truthy-falsy","title":"Truthy / Falsy","text":"<p>RSL supports truthy/falsy logic.</p> <p>For those unfamiliar, this means that, instead of writing the following (as an example):</p> <pre><code>if len(my_list) &gt; 0:\n    print(\"My list has elements!\")\n</code></pre> <p>you can write</p> <pre><code>if my_list:\n    print(\"My list has elements!\")\n</code></pre> <p>Essentially, you can use any type as a condition, and it will resolve to true or false depending on the value.</p> <p>The following table shows which values return false for each type. All other values resolve to true.</p> Type Falsy Description string <code>\"\"</code> Empty strings int <code>0</code> Zero float <code>0.0</code> Zero list <code>[]</code> Empty lists map <code>{}</code> Empty maps <p>Note that a string which is all whitespace e.g. <code>\" \"</code> is truthy.</p>"},{"location":"guide/basics/#converting-types","title":"Converting Types","text":"<ul> <li>TBC</li> <li>parsing</li> <li>casting (once implemented)</li> </ul>"},{"location":"guide/basics/#learnings-summary","title":"Learnings Summary","text":"<ul> <li>We rapidly covered many basic topics such as assignment, data types, operators, and control flow.</li> <li>RSL has 6 data types that map from JSON: strings, ints, floats, bools, lists, and maps.</li> <li>RSL has operators such as <code>+ , - , * , / , %</code>. For bool logic, it uses <code>or</code> and <code>and</code>.</li> <li>RSL uses a \"for-each\" variety <code>for</code> loop. You always loop through items in a collection (or string).<ul> <li>If you want to increment through a number range, use the <code>range</code> function to generate you a list of ints.</li> </ul> </li> <li>RSL offers truthy/falsy logic for more concise conditional expressions.</li> </ul>"},{"location":"guide/basics/#next","title":"Next","text":"<p>Good job on getting through the basics of the language! </p> <p>Next, let's dive into one of the areas of RSL that make it shine: Args.</p>"},{"location":"guide/defer-errdefer/","title":"Defer & Errdefer","text":"<p>WIP</p>"},{"location":"guide/functions/","title":"Functions","text":"<p>RSL offers a range of built-in functions to help you write your scripts. In this section, we'll take a look at the syntax and a few examples. For a complete list of available functions, see the reference.</p>"},{"location":"guide/functions/#syntax","title":"Syntax","text":"<p>The syntax for invoking functions is pretty standard. Here's a script with some examples:</p> <pre><code>names = [\"Bob\", \"Charlie\", \"Alice\"]\nnum_people = len(names)\nprint(\"There are {num_people} people.\")\n\nsorted_names = sort(names)\nprint(sorted_names)\n</code></pre> <pre><code>There are 3 people.\n[Alice, Bob, Charlie]\n</code></pre> <p>This example uses a few different functions:</p> <ul> <li><code>len</code></li> <li><code>print</code></li> <li><code>sort</code></li> </ul>"},{"location":"guide/functions/#no-arguments","title":"No Arguments","text":"<p>Some functions take no arguments. For example, <code>rand()</code> returns a random float between 0 and 1:</p> <pre><code>random_float = rand()\nprint(random_float)\n</code></pre> <pre><code>0.8436881320514183\n</code></pre>"},{"location":"guide/functions/#fixed-arguments","title":"Fixed Arguments","text":"<p>Some functions take a fixed number of arguments, such as <code>upper</code> and <code>lower</code> that always take one argument:</p> <pre><code>text = \"oh WOW!\"\nprint(upper(text))\nprint(lower(text))\n</code></pre> <pre><code>OH WOW!\noh wow!\n</code></pre>"},{"location":"guide/functions/#variadic-arguments","title":"Variadic Arguments","text":"<p>Some functions can take different numbers of arguments! For example <code>join</code>:</p> <pre><code>numbers = [1, 2, 3]\nprint(join(numbers, \"... \"))\n\nprint(join(numbers, \"... \", \"Okay I'll count. \"))\n\nprint(join(numbers, \"... \", \"Okay I'll count. \", \"!\"))\n</code></pre> <pre><code>1... 2... 3\nOkay I'll count. 1... 2... 3\nOkay I'll count. 1... 2... 3!\n</code></pre> <p>In this example, <code>join</code> is being invoked with all these valid variations:</p> <ul> <li><code>join(list, joiner)</code></li> <li><code>join(list, joiner, prefix)</code></li> <li><code>join(list, joiner, prefix, suffix)</code></li> </ul> <p>Example using join for url query params</p> <p>The second variation of <code>join</code> can be handy for generating the query params in a url. For example:</p> <pre><code>url = \"https://api.github.com/repos/amterp/rad/commits\"\nquery_params = [\"per_page=5\", \"path=README.md\"]\nurl += join(query_params, \"&amp;\", \"?\")\nprint(url)\n</code></pre> <p>In this example, the final url will be the following valid URL utilizing those query params: <code>https://api.github.com/repos/amterp/rad/commits?path=README.md&amp;per_page=5</code></p>"},{"location":"guide/functions/#named-arguments","title":"Named Arguments","text":"<p>Finally, some functions may also have named arguments. An example of this is <code>http_post</code>. <code>http_post</code> (unsurprisingly) performs an HTTP POST request against an input url, usually with a body of some sort. One variation of the function only takes that url:</p> <pre><code>response = http_post(url, body)\n</code></pre> <p>However, if you wish to customize the headers on your HTTP request, you can do so:</p> <pre><code>my_headers = {\n    \"Authorization\": \"Bearer {token}\",\n}\nresponse = http_post(url, body, headers=my_headers)\n</code></pre> <p>In this example, the named arg <code>headers</code> expects a map. Named args are always optional. Required arguments cannot be specified as required arguments.</p>"},{"location":"guide/functions/#reference","title":"Reference","text":"<p>There are a lot of built-in functions. If you just want to see what's available and how to use them, it's best to refer to the reference.</p> <p>RSL does not allow defining your own functions</p> <p>RSL currently does not allow you to define your own functions, so any function you use is built-in.</p>"},{"location":"guide/functions/#learnings-summary","title":"Learnings Summary","text":"<ul> <li>Function invocation syntax is similar to most other C-like languages such as Python, Java, etc.</li> <li>Functions may take no arguments, a fixed number of arguments, a varying number of args, and/or named arguments.</li> <li>RSL does not allow you to define your own functions - all functions are built-in.</li> </ul>"},{"location":"guide/functions/#next","title":"Next","text":"<p>We've already covered the Basics of strings, but there are some more advanced string concepts which are worth covering, such as string interpolation, raw strings, etc. We'll cover these in the next section: Strings (Advanced)!</p>"},{"location":"guide/getting-started/","title":"Getting Started","text":""},{"location":"guide/getting-started/#installation","title":"Installation","text":""},{"location":"guide/getting-started/#macos","title":"macOS","text":"<pre><code>brew tap amterp/rad\nbrew install rad\n</code></pre> <p>Other than building from source, rad is not available for other platforms/package managers (yet).</p>"},{"location":"guide/getting-started/#checking-installation","title":"Checking Installation","text":"<p>After you've installed rad, you can check your installation:</p> <pre><code>rad -V\n</code></pre> <p>If this prints rad's version, you're set!</p>"},{"location":"guide/getting-started/#your-first-rsl-script-hello-world","title":"Your First RSL Script - Hello World","text":"<p>Let's write the classic \"Hello, World!\" program. We'll then modify it to give it a bit of an RSL twist, demoing a couple of features rad provides.</p> <p>Terminology: Rad &amp; RSL</p> <p>Rad is the name of the CLI tool and interpreter capable of running RSL scripts.</p> <p>Rad stands for \"Request And Display\", and RSL stands for \"Rad Scripting Language\".</p> <p>First, create a file, let's call it simply <code>hello</code>, and give it the following contents:</p> <pre><code>print(\"Hello, World!\") \n</code></pre> <p><code>print()</code></p> <p><code>print()</code> is the go-to function for outputting to stdout. It behaves a lot like <code>print()</code> in Python.</p> <p>You can read more about it in the reference.</p> <p>RSL Extensions</p> <p>If you want to give your RSL scripts an extension, you can follow <code>.rsl</code> as a convention.</p> <p>Then, run the script from your CLI by invoking <code>rad</code> on it, and you should see it print out like so:</p> <pre><code>&gt; rad ./hello\n</code></pre> <pre><code>Hello, World!\n</code></pre> <p>Nice! Next, let's spruce it up with a few RSL features.</p>"},{"location":"guide/getting-started/#adding-in-some-rsl-features","title":"Adding In Some RSL Features","text":"<p>One of the selling points of rad is that it makes defining arguments to your script super simple, using a declarative style.</p> <p>Let's modify the script to greet a name you input from command line.</p> <pre><code>args:\n  name string\n\nprint(\"Hello, {name}!\")\n</code></pre> <p>A couple of things to note here:</p> <ol> <li>We define an \"args block\". Right now it contains just the one line, but you can do lots of things in here.</li> <li>The modified <code>print()</code> utilizes string interpolation. String interpolation in RSL behaves a lot like it does in Python (you'll see this is a pattern).</li> </ol> <p>Now, let's try invoking the script again, and this time, input your (or someone's) name:</p> <pre><code>&gt; rad ./hello Alex\n</code></pre> <pre><code>Hello, Alex!\n</code></pre> <p>Cool! What if we invoke without a name?</p> <pre><code>&gt; rad ./hello\n</code></pre> <pre><code>Usage:\n  hello &lt;name&gt;\n\nScript args:\n      --name string\n</code></pre> <p>If you run an RSL script without providing any args to a script which expects at least one, rad will print out the script usage, interpreting your invocation similar to if you had passed <code>--help</code>.</p> <p>This shows a little of the automatic script usage string generation that rad gives you. Let's explore that a bit more.</p>"},{"location":"guide/getting-started/#improving-script-usage-string","title":"Improving Script Usage String","text":"<p>RSL facilitates writing well-documented and easy-to-use scripts, in part through unique syntax that it offers. Let's use a couple of those now.</p> <p>First, we'll add a file header to your script.</p> <pre><code>---\nPrints a polite greeting using an input name.\n---\nargs:\n  name string\n\nprint(\"Hello, {name}!\")\n</code></pre> <p>File Headers</p> <p>File headers, as the name suggests, go at the top of RSL scripts (with the exception of shebangs, to be covered later).  They allow you to write a description for your script in between two <code>---</code> lines. The contents will get printed as part of the script's usage string.</p> <p>Some ideas on what to cover in your file headers:</p> <ul> <li>A brief description of what the script does.</li> <li>Why you might want to use the script.</li> <li>Examples of valid invocations and what they do.</li> </ul> <p>Second, we can add comments to args that a script declares. Let's do that too:</p> <pre><code>---\nPrints a polite greeting using an input name.\n---\nargs:\n  name string # The name of someone to greet.\n\nprint(\"Hello, {name}!\")\n</code></pre> <p>Note on <code>#</code> vs. <code>//</code></p> <p>RSL uses <code>#</code> to denote a arg comments in RSL. <code>#</code> comments are special and do get passed to RSL's parser and can affect script behavior (namely in this case, adding information to the script usage string). </p> <p>Standard code comments in RSL use <code>//</code>, similar to Java or C/C++. These are stripped prior to parsing and don't impact script behavior.</p> <p>You can use code comments on your arg comments, if you so choose e.g.</p> <pre><code>name string # A name.  // todo make this more descriptive\n</code></pre> <p>Now, when someone reads the script, it's pretty clear what the script does and what the expected arguments are.</p> <p>But it gets better! Let's try invoking the script's usage string again (this time let's try using the <code>-h</code> flag explicitly, though it's not necessary):</p> <pre><code>&gt; rad ./hello -h\n</code></pre> <pre><code>Prints a polite greeting using an input name.\n\nUsage:\n  hello &lt;name&gt;\n\nScript args:\n      --name string   The name of someone to greet.\n</code></pre> <p>Not only is the script now easier to maintain for developers, it's also easier for users to understand!</p>"},{"location":"guide/getting-started/#shebang","title":"Shebang","text":"<p>Last thing, as part of this introduction guide.</p> <p>Needing to manually invoke <code>rad</code> each time you want to run an RSL script can be a little cumbersome. Thankfully, Unix kernels provide a mechanism known as a \"shebang\".</p> <p>Let's add one to our script. It has to go on the very first line.</p> <pre><code>#!/usr/bin/env rad\n---\nPrints a polite greeting using an input name.\n---\nargs:\n  name string # The name of someone to greet.\n\nprint(\"Hello, {name}!\")\n</code></pre> <p>Then, make the script executable using the following command:</p> <pre><code>chmod +x ./hello\n</code></pre> <p>Now, you can invoke the script directly:</p> <pre><code>&gt; ./hello Bob\n</code></pre> <pre><code>Hello, Bob!\n</code></pre> <p>Basically, when you invoke an executable script this way, the Kernel scans for a shebang (<code>#!</code>) in the first line. If it finds a path to an interpreter (in this case, it will find <code>rad</code> if you've correctly put it in your <code>PATH</code>), it will invoke said interpreter on the script (equivalent to <code>rad ./hello</code> like we were doing before).</p>"},{"location":"guide/getting-started/#learnings-summary","title":"Learnings Summary","text":"<ul> <li>We learned how to print, and saw an example of string interpolation.</li> <li>We were introduced to the args block</li> <li>We saw how we can write self-documenting scripts that also help our users by leveraging file headers and arg comments.</li> <li>We saw how we can leverage shebangs to make our scripts more convenient to run.</li> </ul> <p>Note on RSL file contents ordering</p> <p>Rad expects a certain order between shebangs, file headers, arg blocks, and the rest of your code.</p> <p>It's important to adhere to the following ordering in RSL scripts, or you'll see errors:</p> <p>1) Shebang (if present)</p> <p>2) File header (if present)</p> <p>3) Args block (if present)</p> <p>4) Rest of the file</p>"},{"location":"guide/getting-started/#next","title":"Next","text":"<p>Great job on getting this far! You've gotten a peek at what rad and RSL have to offer.</p> <p>From here, you have two options:</p> <ol> <li> <p>Continue your RSL journey: dive into more details with the next section: Basics.</p> </li> <li> <p>If you're interested instead in seeing additional unique RSL features, feel free to skip ahead to any of these sections:</p> <ul> <li>Args</li> <li>Rad Blocks</li> <li>Shell Commands</li> </ul> </li> </ol>"},{"location":"guide/global-flags/","title":"Global Flags","text":"<p>RSL offers a range of global flags that are available with every RSL script. We'll explore some of them in this section.</p>"},{"location":"guide/global-flags/#help","title":"<code>help</code>","text":"<p>The most basic global flag is <code>--help</code> or <code>-h</code>. All RSL scripts automatically generate a usage string that can be displayed by invoking this flag.</p> <p><code>--help</code> also prints available global flags:</p> <pre><code>Global flags:\n  -h, --help                   Print usage string.\n  -D, --DEBUG                  Enables debug output. Intended for RSL script developers.\n      --RAD-DEBUG              Enables Rad debug output. Intended for Rad developers.\n      --NO-COLOR               Disable colorized output.\n  -Q, --QUIET                  Suppresses some output.\n      --SHELL                  Outputs shell/bash exports of variables, so they can be eval'd\n  -V, --VERSION                Print rad version information.\n      --STDIN script-name      Enables reading RSL from stdin, and takes a string arg to be treated as the 'script name'.\n      --MOCK-RESPONSE string   Add mock response for json requests (pattern:filePath)\n</code></pre> <p>Note that, outside of <code>help</code>, all the global flags are ALL CAPS.</p>"},{"location":"guide/global-flags/#debug","title":"<code>DEBUG</code>","text":"<p><code>debug</code> is an built-in function which behaves exactly like <code>print</code>, except it only prints if the global flag <code>--DEBUG</code> is enabled. You can use them in your script for debugging as desired.</p> <p>For example, given this example:</p> debug.rsl<pre><code>print(\"1\")\ndebug(\"2\")\nprint(\"3\")\n</code></pre> <p>the following invocations will give the respective outputs:</p> <pre><code>rad debug.rsl\n</code></pre> <pre><code>1\n3\n</code></pre> <pre><code>rad debug.rsl -D\n</code></pre> <pre><code>1\nDEBUG: 2\n3\n</code></pre>"},{"location":"guide/global-flags/#quiet","title":"<code>QUIET</code>","text":"<p>Use <code>--QUIET</code> or <code>-Q</code> to suppress some outputs, including print statements and errors. Some outputs still get printed e.g. shell command outputs.</p>"},{"location":"guide/global-flags/#no-color","title":"<code>NO-COLOR</code>","text":"<p>A lot of rad's outputs have colors e.g. <code>pick</code> interaction or <code>pprint</code> JSON formatted output. Sometimes you just want monochrome output, and while rad aims to do this automatically when it detects e.g. you're redirecting output to file, you can force it by using the  <code>--NO-COLOR</code> flag.</p>"},{"location":"guide/global-flags/#mock-response","title":"<code>MOCK-RESPONSE</code>","text":"<p>You might be writing a script which hits a JSON API and uses its output e.g. formatting it into a table using a <code>rad</code> block.</p> <p>In writing said script, you may wish to test it against certain responses that the live API isn't giving you at the moment, perhaps because the server is down. To accomplish this, you can use the <code>MOCK-RESPONSE</code> flag.</p> <p><code>MOCK-RESPONSE</code> takes an argument in a <code>&lt;url regex&gt;:&lt;file path&gt;</code> format. In other words, you can mock responses based on a regex match of the queried URL, and make them return the contents of a specified file.</p> <p>For example, if you wanted to mock a response from GitHub's API, you could define an example response in a file:</p> commits.json<pre><code>[\n  {\n    \"sha\": \"306f3a4ddb3b09747d61a5eab264c3d72fbbc36e\",\n    \"commit\": {\n      \"author\": {\n        \"name\": \"Alice Smith\",\n        \"date\": \"2025-01-11T04:15:06Z\"\n      }\n    }\n  },\n  {\n    \"sha\": \"2b642c482b32e4d87924839b2f5a9592670dee69\",\n    \"commit\": {\n      \"author\": {\n        \"name\": \"Charlie Johnson\",\n        \"date\": \"2025-01-10T12:21:03Z\"\n      }\n    }\n  }\n]\n</code></pre> <p>And then define it as the mock response with the following example invocation:</p> <pre><code>rad commits.rsl --MOCK-RESPONSE \"api.github.*:commits.json\"\n</code></pre> <p>Before executing the HTTP request, rad checks for defined mock responses and if there's a regex match against the URL, it will short circuit, avoiding the HTTP request, and simply returning the contents of the mocked response.</p> <p>Match all URLs with .*</p> <p>It's common for scripts to perform just one API query, in which case the regex filter doesn't need to be specific. Instead, you can just write <code>.*</code> e.g. <code>.*:commits.json</code>.</p>"},{"location":"guide/global-flags/#additional-commands","title":"Additional Commands","text":"<p>There are more global flags - see the reference for a complete coverage of what's available.</p>"},{"location":"guide/global-flags/#learnings-summary","title":"Learnings Summary","text":"<ul> <li>Rad provides several global flags that can be used across all RSL scripts.</li> <li>Generally, global flags are in ALL CAPS, such as <code>DEBUG</code> and <code>QUIET</code>.</li> <li>Use <code>MOCK-RESPONSE</code> to test your scripts.</li> </ul>"},{"location":"guide/global-flags/#next","title":"Next","text":"<p>Sometimes you may wish to run commands before your script ends, either normally or via an error, such as cleanups. RSL provides a way to do this that we will explore in the next section: Defer &amp; Errdefer.</p>"},{"location":"guide/rad-blocks/","title":"Rad Blocks","text":"<p>This section discusses another unique RSL concept, including rad blocks. These allow you to easily and concisely define queries to JSON APIs and what data you want to extract from the response, so that it can be displayed as a nice, readable table.</p>"},{"location":"guide/rad-blocks/#basic-example","title":"Basic Example","text":"<p>This concept will become clearer with an example.</p> <p>Below is a simple script capable of querying a given GitHub repo (leveraging GitHub's public API) for information about its latest commits.</p> File: commits<pre><code>args:\n    repo string    # The repo to query. Format: user/project\n    limit int = 20 # The max commits to return.\n\nurl = \"https://api.github.com/repos/{repo}/commits?per_page={limit}\"\n\nTime = json[].commit.author.date\nAuthor = json[].commit.author.name\nSHA = json[].sha\n\nrad url:\n    fields Time, Author, SHA\n</code></pre> <p>Here's an example of running it, and the command line output:</p> <pre><code>rad commits amterp/rad 5\n</code></pre> <pre><code>Querying url: https://api.github.com/repos/amterp/rad/commits?per_page=5\nTime                  Author          SHA\n2025-01-11T04:15:06Z  Alexander Terp  306f3a4ddb3b09747d61a5eab264c3d72fbbc36e\n2025-01-11T03:07:56Z  Alexander Terp  304a914644dfd73a59b85a191481f9c429b4d25e\n2025-01-11T01:00:42Z  Alexander Terp  7171ec92ae729f9d04e224e16272c9b888dffe41\n2025-01-10T12:11:08Z  Alexander Terp  4b64f585d08d9a5ee40549b6b9624530ac713eb1\n2025-01-09T11:34:51Z  Alexander Terp  abfcf2d940a18b819f7ae9e9040550a9644e5120\n</code></pre> <p>This is a simple example, but it demonstrates the ability to query GitHub's API (which returns JSON), extracting fields we're interested in (commits' time, author, and hash string).</p> <p>And that's with just a few lines of code! Let's break it down piece by piece.</p>"},{"location":"guide/rad-blocks/#arg-block","title":"Arg Block","text":"<pre><code>args:\n    repo string    # The repo to query. Format: user/project\n    limit int = 20 # The max commits to return.\n\nurl = \"https://api.github.com/repos/{repo}/commits?per_page={limit}\"\n</code></pre> <p>Here we have an args block where we declare a <code>repo</code> string and a <code>limit</code> int with a default of 20. After the args block, we create a <code>url</code> string using string interpolation to fill in the repo name, and the limit for how many commits we want GitHub to give us.</p>"},{"location":"guide/rad-blocks/#json-field-definitions","title":"Json Field Definitions","text":"<pre><code>Time = json[].commit.author.date\nAuthor = json[].commit.author.name\nSHA = json[].sha\n</code></pre> <p>This is where things get more interesting. The above definitions correspond to expected paths in the JSON response i.e. a series of keys to look up.</p> <p>In RSL nomenclature, we refer to these as json field definitions.</p> <p>If you query GitHub's API and take a look at the JSON response, you can see how these fields correspond to the data. Example URL if you want to see for yourself:</p> <p>https://api.github.com/repos/amterp/rad/commits?per_page=2</p> <p>Here's a simplified example response with two commits, showing the structure we're interested in:</p> <pre><code>[\n  {\n    \"sha\": \"306f3a4ddb3b09747d61a5eab264c3d72fbbc36e\",\n    \"commit\": {\n      \"author\": {\n        \"name\": \"Alexander Terp\",\n        \"date\": \"2025-01-11T04:15:06Z\"\n      }\n    }\n  },\n  {\n    \"sha\": \"2b642c482b32e4d87924839b2f5a9592670dee69\",\n    \"commit\": {\n      \"author\": {\n        \"name\": \"Alexander Terp\",\n        \"date\": \"2025-01-10T12:21:03Z\"\n      }\n    }\n  }\n]\n</code></pre> <p>You can see how the path for <code>Author = json[].commit.author.name</code> corresponds to a final value of \"Alexander Terp\".</p> <p>Json field definitions leverage a special syntax that RSL offers. They always start with <code>json</code>. <code>json</code> can be thought of as representing the JSON blob as a whole, or its root, if you want to think of the JSON data as a tree.</p> <p>The <code>[]</code> after <code>json</code> tells RSL that you expect the <code>json</code> blob to be a list, and to \"unwrap\" it and dig into individual items in that list for the remainder of the path. <code>commit</code> then tells it to look up a key of that name (literally <code>commit</code>), and to then look up <code>author</code> next, and then finally <code>name</code>.</p> <p>The json field definition syntax can do a lot of things that we won't cover here. For details, see its reference page.</p> <p>When the json field assignment is executed, its variable (<code>Author</code> for example) is initialized as an empty list. It's a \"special\" list though, as it has a json field definition tied to it, which can be used in a rad block, let's look at that one next.</p>"},{"location":"guide/rad-blocks/#rad-block","title":"Rad Block","text":"<pre><code>rad url:\n    fields Time, Author, SHA\n</code></pre> <p><code>rad</code> is a keyword. As with the name of the interpreter and CLI tool which runs it, it stands for \"Request And Display\", to give you an idea for what it does.</p> <p>Following the <code>rad</code> keyword, we provide the <code>url</code> variable which will get used to execute an <code>HTTP GET</code> request. Then, inside the rad block itself, using the keyword <code>fields</code>, we specify the earlier json fields that we defined. Listing them here will tell the rad block to extract data from the resulting JSON blob according to the json field paths that you defined. The ordering in which the fields are listed also controls the ordering of columns in the ensuing table that gets printed.</p> <p>When run, this will print the table we saw earlier; here it is again for reference (with a limit of 3).</p> <pre><code>Time                  Author          SHA\n2025-01-11T04:15:06Z  Alexander Terp  306f3a4ddb3b09747d61a5eab264c3d72fbbc36e\n2025-01-11T03:07:56Z  Alexander Terp  304a914644dfd73a59b85a191481f9c429b4d25e\n2025-01-11T01:00:42Z  Alexander Terp  7171ec92ae729f9d04e224e16272c9b888dffe41\n</code></pre> <p>Note that the variable names we choose for the json field definitions become the header names in the table.</p>"},{"location":"guide/rad-blocks/#additional-rad-block-options","title":"Additional Rad Block Options","text":"<p>Rad blocks offer additional syntax for controlling what your final table looks like.</p>"},{"location":"guide/rad-blocks/#sorting","title":"Sorting","text":"<p>By default, the rows in your table are sorted by their original order in the JSON blob. However, you can control this.</p> <p>Let's say we have the following table by default:</p> <pre><code>City         Country  Population\nLos Angeles  USA      3800000\nLondon       England  8800000\nHouston      USA      2300000\nCopenhagen   Denmark  640000\n</code></pre> <p>The simplest sorting option is alphabetically, across the whole row.</p> <pre><code>rad url:\n    fields City, Country, Population\n    sort\n</code></pre> <pre><code>City         Country  Population\nCopenhagen   Denmark  640000\nHouston      USA      2300000\nLondon       England  8800000\nLos Angeles  USA      3800000\n</code></pre> <p>What if we wanted to sort by Country, though? And then break ties with City? We can do that:</p> <pre><code>rad url:\n    fields City, Country, Population\n    sort Country, City\n</code></pre> <pre><code>City         Country  Population\nCopenhagen   Denmark  640000\nLondon       England  8800000\nHouston      USA      2300000\nLos Angeles  USA      3800000\n</code></pre> <p>If we wanted to sort by descending population, you can add <code>desc</code> after the name of the column:</p> <pre><code>rad url:\n    fields City, Country, Population\n    sort Population desc\n</code></pre> <pre><code>City         Country  Population\nLondon       England  8800000\nLos Angeles  USA      3800000\nHouston      USA      2300000\nCopenhagen   Denmark  640000\n</code></pre> <p>'asc' is the default</p> <p><code>sort City</code> and <code>sort City asc</code> are both valid and identical in functionality - you can include it if you want to be explicit.</p>"},{"location":"guide/rad-blocks/#mapping","title":"Mapping","text":"<p>You can also transform a column's values before it gets printed.</p> <p>For example, let's say you wanted the 'Population' column in the above example to be in millions, and to display one decimal place, you can do that with a <code>map</code> column modifier:</p> <pre><code>rad url:\n    fields City, Country, Population\n    Population:\n        map p -&gt; \"{p/1000000:.1}\"\n</code></pre> <p>If we run this, you'll see the change:</p> <pre><code>City         Country  Population\nLos Angeles  USA      3.8\nLondon       England  8.8\nHouston      USA      2.3\nCopenhagen   Denmark  0.6\n</code></pre> <p>This example is actually using string interpolation formatting, which we haven't covered yet, so is a bit of a preview. Let's break down this syntax though. After declaring the fields:</p> <pre><code>Population:\n    map p -&gt; \"{p/1000000:.1}\"\n</code></pre> <p><code>Population:</code> begins a column modifier block. The identifier prior to the colon is expected to be one of the fields. Inside one of these blocks, you can apply modifiers on that column, such as <code>map</code> or <code>color</code>.</p> <p><code>map</code> is considered a keyword in the context of rad blocks. After <code>map</code>, a lambda expression is expected, which you can think of as a mini-function.</p> <p>In this case, we've written <code>p -&gt; \"{p/1000000:.1}\"</code>. Left of the arrow is an identifier <code>p</code> (name could be any valid identifier). This will represent an individual value in the <code>Population</code> list. Right of the arrow is an expression for what that entry in the list should become. It is the output of your lambda mini-function. In this example, we turn it into a string, created using string interpolation.</p> <p>Inside the string interpolation expression, we first divide it by one million (<code>p/1000000</code>), and then use formatting syntax (right of the colon) to specify that we want the resulting float to be stringified with one decimal place (<code>.1</code>).</p> <p>Note that sorting operations are done on the pre-mapping column values.</p>"},{"location":"guide/rad-blocks/#color","title":"Color","text":"<p>Another column modifier uses the keyword <code>color</code>. You can tell rad to color a cell's value depending on its contents by using a regex.</p> <p>For example:</p> <pre><code>rad url:\n    fields City, Country, Population\n    Country:\n        color \"pink\" \".*\"\n        color \"red\" \"Denmark\"\n        color \"blue\" \"USA\"\n</code></pre> <p>The syntax is <code>color &lt;color&gt; &lt;regex&gt;</code>. You can apply multiple rules, and later rules override earlier ones.  For example, here we start off by coloring everything pink. Then, we add three more rules: any sequence \"Denmark\" should be colored red, and \"USA\" should be colored blue.</p> <p></p> <p>This screenshot from a terminal demonstrates the colors. England is colored pink because the initial <code>.*</code> rule is the only regex that matched it.</p> <p>Note that the specific colors that appear varies between terminals and user settings.</p> <p>See the reference for a list of valid colors.</p>"},{"location":"guide/rad-blocks/#if-statements","title":"If Statements","text":"<p>Rad blocks can contain if statements, so if you want slightly different behavior for your rad block based on some condition, you don't need to copy and paste the whole block into two separate if blocks.</p> <p>Let's say your script had a flag for sorting by population or not. Here's an example of how that could look:</p> <pre><code>args:\n    sort_by_population \"sort-by-population\" p bool  # Enable to sort by population.\n\n// ... some script stuff here\n\nrad url:\n    fields City, Country, Population\n    if sort_by_population:\n        sort Population desc\n    else:\n        sort\n</code></pre> <p>If the flag is enabled, we sort by descending population, otherwise we sort rows alphabetically.</p> <p>You can put any rad block statements into these if blocks, including <code>fields</code>, column modifiers, etc.</p>"},{"location":"guide/rad-blocks/#request-blocks","title":"Request Blocks","text":"<p>There are two other types of rad blocks: \"request\" blocks and \"display\" blocks. Let's first discuss the former.</p> <p>A request block is similar to a <code>rad</code> block, however it does not print out any table after executing its query and field extraction steps. You can use them to just query and extract fields from a returned json blob and stop there - allowing you to separately process the populated json fields/lists further if need be, or do whatever else you'd like.</p> <p>Generally the syntax is very similar between <code>request</code> and <code>rad</code> blocks.</p> <pre><code>request url:\n    fields City, Country, Population\n\n// from here the above fields' lists are populated with extracted values\n</code></pre> <p>Naturally, block statements like sorting or coloring have no effect, and may be considered invalid and error.</p> <p>Wait, so is a request block different from a rad block, or is it a type of rad block?</p> <p>We generally consider \"display\" and \"request\" blocks to be types of rad blocks, just with slightly different syntax and behavior. We may still compare them to the rad block (i.e. the one using <code>rad</code> as its keyword) when discussing differences however - it depends on the context in which they're discussed.</p>"},{"location":"guide/rad-blocks/#display-blocks","title":"Display Blocks","text":"<p>Display blocks are the opposite side of the coin from request blocks. Where the request blocks will perform a request, populate your lists, and not print, the display block will simply take already-populated lists and display them as a table.</p> <p>To demonstrate, you can even manually populate your lists (columns) and use them as fields for the table:</p> <pre><code>Nums = [1, 2]\nWords = [\"hi\", \"hello\"]\ndisplay:\n    fields Nums, Words\n</code></pre> <pre><code>Nums  Words\n1     hi\n2     hello\n</code></pre> <p>Notice <code>display</code> does not take any <code>url</code> or equivalent thereof, as it doesn't perform any requests, and gets all it needs from the specified <code>fields</code>.</p> <p>Combining request and display blocks</p> <p>Sometimes you want to display more information in your table than the JSON blob itself provides. For example, you may wish to derive an additional column off two others. To accomplish this, you can write a <code>request</code> block, derive whatever additional columns you want, and then write a <code>display</code> block to print your final range of columns.</p> <p>For example:</p> <pre><code>request url:\n    fields width, height\n\narea = [width[i] * height[i] for i in range(width)]\n\ndisplay:\n    fields width, height, area\n</code></pre>"},{"location":"guide/rad-blocks/#learnings-summary","title":"Learnings Summary","text":"<ul> <li>RSL provides first-class support for scripts whose primary purpose is to query a JSON API and present parts of its response in a useful, readable table.</li> <li>This is offered by the <code>rad</code> blocks, and its siblings <code>display</code> and <code>request</code>.</li> <li>RSL has syntax for specifying json field definitions or json field paths, that rad blocks can then use to extract fields from a JSON blob response.<ul> <li>e.g. <code>Author = json[].commit.author.name</code></li> </ul> </li> <li>Rad blocks offer customization options, such as coloring, transforming cell values, and sorting.</li> <li>You can also use if statements inside them.</li> </ul>"},{"location":"guide/rad-blocks/#next","title":"Next","text":"<p>RSL offers a range of useful built-in functions to help you write your scripts. We'll take a look at those in the next section: Functions.</p>"},{"location":"guide/resources/","title":"Resources","text":"<p>Depending on your script, you may wish to look up values at some point, such as URL endpoints depending on your input. RSL offers a function for this, <code>pick_from_resource</code>, but before we dive into it, we'll first cover a couple of related functions.</p>"},{"location":"guide/resources/#pick","title":"<code>pick</code>","text":"<p><code>pick</code> is an in-built function which allows you to choose one value from a list of inputs, using some filter. If the filter has several matches, rad will enter an interactive mode which allows the user to pick a single value to continue with.</p> <p>You can try it yourself with this example:</p> <pre><code>options = [\"chicken burger\", \"chicken sandwich\", \"ham sandwich\"]\noutput = pick(options, \"sandwich\")\nprint(\"You chose: {output}\")\n</code></pre> <p>When you initially run this, the <code>sandwich</code> filter should exclude <code>chicken burger</code> and ask you to select between two remaining options:</p> <pre><code>\u2503 Pick an option\n\u2503 &gt; chicken sandwich\n\u2503   ham sandwich\n</code></pre> <p>After you choose, you get the final output:</p> <pre><code>You chose: chicken sandwich\n</code></pre>"},{"location":"guide/resources/#pick_kv","title":"<code>pick_kv</code>","text":"<p>A similar function is <code>pick_kv</code>. However, instead of the values you're filtering and picking between also being the output, <code>pick_kv</code> performs the filtering/picking on a list of keys, each which map to a value that will get output from the function if its associated key is picked. For example:</p> <pre><code>keys = [\"chicken burger\", \"chicken sandwich\", \"ham sandwich\"]\nvalues = [\"CHICKEN\", \"CHICKEN\", \"HAM\"]\n\noutput = pick_kv(keys, values)\n\nprint(\"We'll need {output}!\")\n</code></pre> <p>In this example, we leave out the filter, as it's optional, which will launch us into an interactive select between all the key values:</p> <pre><code>\u2503 Pick an option\n\u2503   chicken burger\n\u2503   chicken sandwich\n\u2503 &gt; ham sandwich\n</code></pre> <p>If we pick this third option, this is the final output of the script:</p> <pre><code>We'll need HAM!\n</code></pre> <p>Notice that the function did not output the key <code>ham sandwich</code> that was selected, but instead the value <code>HAM</code> that it mapped to.</p>"},{"location":"guide/resources/#pick_from_resource","title":"<code>pick_from_resource</code>","text":"<p>Now we'll look at actually using what this section is about - resources. <code>pick_from_resource</code> allows you to pre-define a resource file (using JSON) which contains a range of key-value pairs. When invoked, it will behave similarly to the two previous <code>pick</code> functions i.e. it lets you apply an optional filter, and will launch into an interactive picking mode to narrow down a single choice, if needed.</p> <p>Let's do a simple example. As mentioned, a resource file is simply a JSON file. We'll create an example where we look up a url based on user input:</p> websites.json<pre><code>{\n  \"options\": [\n    {\n      \"keys\": [\"gl\", \"lab\"],\n      \"values\": [\"gitlab.com\", \"GitLab\"]\n    },\n    {\n      \"keys\": [\"gh\", \"hub\"],\n      \"values\": [\"github.com\", \"GitHub\"]\n    }\n  ]\n}\n</code></pre> <p>You may see some similarity here to what we did with <code>pick_kv</code>. We're defining two options: one which can get matched by either <code>gl</code> or <code>lab</code>, and one which gets matched by <code>gh</code> or <code>hub</code>. In the first case, if chosen, <code>pick_from_resource</code> will return two values: <code>gitlab.com</code> and <code>GitLab</code>. Similarly it will return <code>github.com</code> and <code>GitHub</code> for the latter.</p> <p>Let's create an RSL script to use this resource:</p> example.rsl<pre><code>args:\n    website string = \"\"\n\nurl, name = pick_from_resource(\"./resources/websites.json\", website)\nprint(\"url: {url}, name: {name}\")\n</code></pre> <p>Note that the first argument to <code>pick_from_resource</code> is a path to a resource file. This path is relative to the script's path. This allows you to store your resources with your scripts. In this example, we'll place our files like so:</p> <pre><code>.\n\u251c\u2500\u2500 example.rsl\n\u2514\u2500\u2500 resources\n    \u2514\u2500\u2500 websites.json\n</code></pre> <p>This means that it doesn't matter where on your computer you invoke your script from including if it's on your PATH - the script will consistently look in the same spot for resource files.</p> <p>TBC</p>"},{"location":"guide/resources/#learnings-summary","title":"Learnings Summary","text":"<ul> <li><code>pick</code> and <code>pick_kv</code> are built-in functions that allow users to select one option from many, allowing for an optional filter.</li> <li><code>pick_from_resource</code> is similar, but uses a pre-defined resource file to define the options.</li> <li>The resource file is defined in JSON.</li> <li>The resource file path can be defined relative to the script's path.</li> </ul>"},{"location":"guide/resources/#next","title":"Next","text":"<p>The shell offers a ton of useful utilities, and RSL allows you to leverage them from within your scripts.</p> <p>We'll look at that in the next section: Shell Commands.</p>"},{"location":"guide/shell-commands/","title":"Shell Commands","text":"<p>The shell offers a wide range of utilities and is a great way to interact with your system e.g. reading/writing files, invoking installed programs, etc.</p> <p>While you can do a lot with in-built RSL functionality, sometimes you'll want to invoke things from your shell, and RSL makes that convenient through  syntax we'll explore in this section.</p>"},{"location":"guide/shell-commands/#basic-shell-commands","title":"Basic Shell Commands","text":"<p>Shell commands can be written via strings. You can then invoke shell commands by prefixing a string with a dollar sign <code>$</code>.</p> <p>For example:</p> <pre><code>$`ls`\n</code></pre> <p>Here we have the intent to run <code>ls</code> from your shell and printing the output to your terminal.</p> <p>Note that you can write the shell command inline like above, or pre-define a string as an identifier (e.g. <code>cmd = ...</code>) and then prefix the identifier with <code>$</code> i.e. <code>$cmd</code> to invoke that pre-defined command.</p> <p>The above example won't run as-is though -- RSL requires you to define some handling for if the command exits with a non-0 exit code i.e. if it errors. To do this, you must define either a <code>fail</code> or a <code>recover</code> block below your command invocation. If the command fails, the block you define will get run, but if it succeeds, the block will not run and will be skipped.</p> <p>When the <code>fail</code> block is run and finishes, the script will exit.</p> <p>When the <code>recover</code> block is run and finishes, the script will continue with whatever comes after the block.</p> <p>You can think of each block as saying how you want shell command failure to be handled - either you want the script to fail or you want it to recover.</p> <p>Here are a couple of examples to demonstrate what happens if the command fails. We create a <code>cmd</code> string to <code>curl</code> a <code>url</code> we defined earlier.</p> <pre><code>cmd = `curl {url}`\n$cmd\nfail:\n    print(\"Oh no, curl failed!\")\n\nprint(\"Hello!\")\n</code></pre> <pre><code>Oh no, curl failed!\n</code></pre> <p>The <code>Hello!</code> does not get printed because the <code>fail</code> block exits after it runs. The exit code of running this script will be non-0, indicating failure.</p> <pre><code>cmd = `curl {url}`\n$cmd\nrecover:\n    print(\"Oh no, curl failed!\")\n\nprint(\"Hello!\")\n</code></pre> <pre><code>Oh no, curl failed!\nHello!\n</code></pre> <p>Here, the <code>Hello!</code> gets printed because we used <code>recover</code> to indicate that the script should recover from the command failure and keep going.</p> <p>In each example, if the command runs successfully, we simply print the output to console and then the <code>Hello!</code>.</p> <p>Prefer backticks for shell command strings</p> <p>Shell commands often make use of 'single' and \"double\" quotes, so to minimize delimiter collision, `backticks` often work best to contain shell commands when writing them into strings. However, there's nothing stopping you from using other delimiters.</p>"},{"location":"guide/shell-commands/#critical-shell-commands","title":"Critical Shell Commands","text":"<p>RSL requires <code>fail</code> or <code>recover</code> blocks when using <code>$</code> syntax for shell commands in order to help developers write safe and well-behaved scripts.</p> <p>However, a very common expectation is that the command should succeed, and if it doesn't, we should fail the script and exit immediately with a non-0 exit code. Rather than requiring explicit <code>fail</code> blocks, which can be a little cumbersome to write every time, you can instead use <code>$!</code> syntax to express that a command is critical i.e. it must succeed, else the script exits.</p> <pre><code>$!`ls`\n</code></pre> <p>This line alone is a perfectly valid shell command and RSL script. If the command fails, we propagate the error code and print the error.</p>"},{"location":"guide/shell-commands/#unsafe-shell-commands","title":"Unsafe Shell Commands","text":"<p>If you want to run a shell command and don't care if it succeeds, you can use the <code>unsafe</code> keyword:</p> <pre><code>unsafe $`ls`\n</code></pre> <p>Regardless of if this invocation succeeds or fails, the script will continue.</p> <p>Use these judiciously.</p>"},{"location":"guide/shell-commands/#capturing-output","title":"Capturing Output","text":"<p>So far, all example shell invocations have not involved capturing their output. When we don't capture command outputs, they're automatically printed to the terminal. However, you can capture command output as strings using the below example syntaxes. In each example, <code>cmd</code> is a predefined string variable representing a shell command.</p> <p>1) Capturing exit codes</p> <p>You can get the exit code from your invocation by writing it as an assignment to one identifier:</p> <pre><code>code = $cmd\n</code></pre> <p>The code returned by your invocation depends on the command. Commonly, a code of <code>0</code> indicates success, and non-0 indicates failure.</p> <p>2) Capturing stdout</p> <p>Commands have two channels for outputting text: stdout (standard out) and stderr (standard error). The former is commonly used for normal output from applications, while the latter is often reserved for errors or exceptional circumstances. With RSL, you can capture each independently. To capture stdout, simply define a second identifier in your assignment:</p> <pre><code>code, stdout = $cmd\n</code></pre> <p>Note that, when capturing stdout (or stderr), it does not get printed to the terminal. It gets redirected to your variable.</p> <p>3) Capturing stderr</p> <p>Lastly, you can capture stderr by adding a third identifier to the assignment:</p> <pre><code>code, stdout, stderr = $cmd\n</code></pre> <p>Note that if you don't care about certain outputs, you can conventionally use an underscore <code>_</code> as the respective identifier to indicate to readers that you don't intend to use those outputs later.</p> <p>For example, if you're only interested in stderr:</p> <pre><code>_, _, stderr = $cmd\n</code></pre> <p>Silencing command output</p> <p>Because capturing stdout and stderr means they don't get printed to the console automatically when the command runs, you can use this fact to hide the output of commmands and run them silently:</p> <pre><code>_, _, _ = $cmd\n</code></pre> <p>This example will run \"silently\", in that none of its output will get printed to the terminal.</p>"},{"location":"guide/shell-commands/#suppressing-announcements","title":"Suppressing Announcements","text":"<p>By default, whenever you invoke a shell command, rad will print an 'announcement' to indicate to users what command is being run. For example:</p> create.rsl<pre><code>args:\n    filename string\n$!`touch {filename}.txt`\n</code></pre> <p>This short script simply creates a file based on its argument. When invoked, it prints the following output:</p> <pre><code>rad create.rsl hi\n</code></pre> <pre><code>\u26a1\ufe0f Running: touch hi.txt\n</code></pre> <p>If you wish to suppress this output, use the <code>quiet</code> keyword: </p> <pre><code>quiet $!`touch {filename}.txt`\n</code></pre>"},{"location":"guide/shell-commands/#learnings-summary","title":"Learnings Summary","text":"<ul> <li>RSL offers first-class support for interacting with your shell and invoking shell commands.</li> <li>Basic invocations (using <code>$</code>) require either a <code>fail</code> or <code>recover</code> command immediately after.</li> <li>If you wish to simply exit when a command fails, you can write it as a critical command with <code>$!</code>.</li> <li>You can capture command outputs by progressively adding more identifiers to an assignment with the invocation.<ul> <li>Identifier 1 = exit code </li> <li>Identifier 2 = stdout </li> <li>Identifier 3 = stderr</li> </ul> </li> <li>Suppress command announcements with the <code>quiet</code> keyword.</li> <li>`Backticks` are particularly well-suited to writing shell commands as strings.</li> </ul>"},{"location":"guide/shell-commands/#next","title":"Next","text":"<p>Rad offers several global flags that are available to every script. We'll explore some of those in the next section: Global Flags.</p>"},{"location":"guide/strings-advanced/","title":"Strings (Advanced)","text":"<p>In this section, we'll cover some more advanced string concepts:</p> <ul> <li>string interpolation</li> <li>formatting</li> <li>multiline strings</li> <li>raw strings</li> </ul>"},{"location":"guide/strings-advanced/#string-interpolation","title":"String Interpolation","text":"<p>RSL allows embedding expressions inside your strings that will get evaluated and replaced to produce the 'final' string.</p> <p>Some examples:</p> <pre><code>name = \"Alice\"\nprint(\"Hi, {name}!\")\n\nprint(\"Uppercase: {upper(name)}\")\n\nprint(\"Conditions: {len(name) &gt; 5 ? 'long name' : 'short name'}!\")\n</code></pre> <pre><code>Hi, Alice!\nUppercase: ALICE\nConditions: short name!\n</code></pre> <p>String interpolation expressions can be as simple as just an identifier, or can involve function calls, math, list comprehensions, etc (though you should consider extracting complex expressions into named variables beforehand for the sake of clarity).</p> <p>Note the use of single quote <code>'</code> strings inside the ternary example's expression. Using double quotes would've closed the \"outer\" string prematurely, but using another delimiter allows us to avoid that without also needing to escape anything.</p>"},{"location":"guide/strings-advanced/#formatting","title":"Formatting","text":"<p>You can format expression results while doing string interpolation. To do so, follow your expression with <code>:</code> and then the relevant syntax for the formatting you want to do. We'll demonstrate through some examples:</p> <pre><code>pi = 3.14159265359\n\nprint(\"Pi: {pi}\")       // no formatting\nprint(\"Pi: {pi:20}\")    // left-pad to 20 places\nprint(\"Pi: {pi:&gt;20}\")   // equivalent to above left-pad, &gt; is redundant\nprint(\"Pi: {pi:&lt;20}\")   // right-pad to 20 places\nprint(\"Pi: {pi:.3}\")    // print to 3 decimal places\nprint(\"Pi: {pi:10.2}\")  // left-pad to 10 places, including 2 decimal places\n</code></pre> <pre><code>Pi: 3.14159265359\nPi:             3.141593\nPi:             3.141593\nPi: 3.141593            \nPi: 3.142\nPi:       3.14\n</code></pre> <p>The decimal place formatting is only relevant to expressions that result in numbers. If it results in a string, then the formatting will error.</p>"},{"location":"guide/strings-advanced/#multiline-strings","title":"Multiline Strings","text":"<p>Sometimes you want to write strings that contain several lines. These strings may themselves also contain string delimiters e.g. <code>\"</code> or <code>'</code>. For these scenarios, RSL offers <code>\"\"\"</code> multiline string syntax. To demonstrate:</p> <pre><code>text = \"\"\"\nThis is an\nexample of text\nthat \"may contain quotes\"!\n\"\"\"\nprint(text)\n</code></pre> <pre><code>This is an\nexample of text\nthat \"may contain quotes\"!\n</code></pre> <p>Some things to note:</p> <ol> <li>The opening <code>\"\"\"</code> must not be followed by any non-comment tokens on the same line.</li> <li>The newline after the opening <code>\"\"\"</code> is excluded from the contents of the string. Contents begin on the next line.</li> <li>The closing <code>\"\"\"</code> must not be preceded by any non-whitespace characters on that same line.</li> <li>Whitespace preceding the closing <code>\"\"\"</code> will get removed from the front of each line in the string block.<ul> <li>In other words, you can use the indentation of the closing <code>\"\"\"</code> to control the desired indentation of your contents.</li> <li>If the closing <code>\"\"\"</code> is preceded by more whitespace than exists on any line of string contents, that means we cannot remove that amount of whitespace from the line, leading to an error.</li> </ul> </li> </ol> <p>Below, we demonstrate the 4th point. Note that to make the \"whitespaces\" more visible, I've replaced them with dots, but keep in mind they do represent spaces:</p> <pre><code>text = \"\"\"\n....This is an\n.....example of text\n..that \"may contain quotes\"!\n..\"\"\"  // &lt; 2 preceding spaces. will get removed from each line in the contents.\n</code></pre> <pre><code>..This is an\n...example of text\nthat \"may contain quotes\"!\n</code></pre>"},{"location":"guide/strings-advanced/#raw-strings","title":"Raw Strings","text":"<p>RSL also supports raw strings. Raw strings don't have any sort of processing done on them (such as string interpolation) and do not allow any escaping (including the delimiter used to create them). Use them when you want your contents to remain as \"raw\" and unprocessed as possible.</p> <p>To use them, just prefix the delimiter of your choice (single/double quotes or backticks) with <code>r</code>.</p> <pre><code>text = r\"Hello\\n{name}\"\nprint(text)\n</code></pre> <pre><code>Hello\\n{name}\n</code></pre> <p>Notice the printed string is exactly as written in code - the newline character and string interpolation are left as-is.</p> <p>You could use any of the three delimiters for raw strings:</p> <pre><code>text = r\"Hello\\n{name}\"\ntext = r'Hello\\n{name}'\ntext = r`Hello\\n{name}`\n</code></pre> <p>Raw strings for file paths</p> <p>Raw strings can be quite handy for file paths, especially Windows-style ones that use backslashes:</p> <pre><code>path = r\"C:\\Users\\Documents\\notes.txt\"\n</code></pre> <p>You cannot escape the raw string's own delimiter</p> <p>RSL raw strings behave more like their equivalent in Go than Python. In Python, you can escape the delimiter used to make the raw string i.e. <code>r\"quote: \\\"!\"</code>. If printed, this will display as <code>quote: \\\"!</code> i.e. the escape character is also printed. There are lots of discussions online about this somewhat odd behavior, which is why RSL (and Go) opted to instead keep the rules very simple and not allow escaping in raw strings of any kind.</p> <p>Instead, if you try the same thing in RSL, you will get an error because the quote following <code>\\</code> will close the string, leaving a dangling <code>!\"</code> at the end, which is invalid syntax.</p>"},{"location":"guide/strings-advanced/#learnings-summary","title":"Learnings Summary","text":"<ul> <li>We learned about string interpolation, and how we can put expressions directly into strings for evaluation.</li> <li>We saw that we can also format the result of said expressions, by using a colon <code>:</code> following the expression itself.</li> <li>Finally, we learned about raw strings and multiline strings.</li> </ul>"},{"location":"guide/strings-advanced/#next","title":"Next","text":"<p>Next, we'll cover another useful concept for writing scripts: resource files.</p>"},{"location":"reference/args/","title":"Args","text":""},{"location":"reference/args/#basics","title":"Basics","text":"<pre><code>args:\n    argVar \"alias\"? shorthand? type = default? # Description?\n</code></pre> <pre><code>args:\n    name n string # A required arg 'name' which can be specified positionally or also with -n.\n    is_employee \"is-employee\" bool # Variable for script is is_employee, but users will see it as is-employee.\n\nif is_employee:\n    print(\"{name} is an employee.\")\nelse:\n    print(\"{name} is not an employee.\") \n</code></pre> <pre><code>args:\n    name string\n    age_years \"age-years\" int\n    height float # Height in meters\n    is_employee \"is-employee\" e bool\n    friends string[] # Specified as e.g. Alice,Bob\n    nationality n string = \"Australian\" # Defaults to this if not specified.\n</code></pre> <p>Example usage:</p> <pre><code>script Charlie 30 -e --friends David,Eve -h 1.86\n</code></pre>"},{"location":"reference/args/#constraint-statements","title":"Constraint Statements","text":""},{"location":"reference/args/#enum","title":"Enum","text":"<pre><code>args:\n    name string\n    name enum [\"alice\", \"bob\", \"charlie\"]\n</code></pre> <pre><code>// valid!\nmyscript alice\n\n// invalid, will print error\nmyscript david\n</code></pre>"},{"location":"reference/assignment/","title":"Assignment","text":"<p>Generally speaking, multi-assignments are only legal for switch expressions, or single operations (e.g. functions) that return multiple values.</p>"},{"location":"reference/assignment/#legal-assignments","title":"Legal Assignments","text":"<pre><code>a = 1\na, b = pick_from_resoure(...)\na, b = switch ...\na, b = parse_int(text)\n\nmyMap[\"key\"] = 2\nmyList[1] = 3\n</code></pre>"},{"location":"reference/assignment/#illegal-assignments","title":"Illegal Assignments","text":"<pre><code>a, b = 1, 2\nmyMap[\"key\"], myMap[\"key2\"] = 2, 3\nmyList[1], myList[2] = 3, 4\n</code></pre>"},{"location":"reference/defer/","title":"Defer & Errdefer","text":"<ul> <li><code>defer</code> and <code>errdefer</code> run in LIFO order, each kind being part of the same one queue.</li> <li>If there are several defer statements, and one fails, further defer statements will still attempt to run.</li> <li>Rad's error code will become an error if the main script succeeded but a defer statement failed.</li> <li>errdefers will not get triggered if the main script succeeded but a <code>defer</code> or <code>errdefer</code> statement failed.</li> </ul>"},{"location":"reference/defer/#defer","title":"<code>defer</code>","text":"defer Example<pre><code>defer:\n    print(1)\n    print(2)\ndefer:\n    print(3)\n    print(4)\nprint(\"Hello!\")\n</code></pre> defer Example Output<pre><code>Hello!\n3\n4\n1\n2\n</code></pre>"},{"location":"reference/defer/#errdefer","title":"<code>errdefer</code>","text":"errdefer Example 1<pre><code>defer:\n    print(1)\n    print(2)\nerrdefer:\n    print(3)\n    print(4)\ndefer:\n    print(5)\n    print(6)\nerrdefer:\n    print(7)\n    print(8)\nprint(\"Hello!\")\nexit(0)  // successful script run\n</code></pre> errdefer Example 1 Output<pre><code>Hello!\n5\n6\n1\n2\n</code></pre> errdefer Example 2<pre><code>defer:\n    print(1)\n    print(2)\nerrdefer:\n    print(3)\n    print(4)\ndefer:\n    print(5)\n    print(6)\nerrdefer:\n    print(7)\n    print(8)\nprint(\"Hello!\")\nexit(1)  // perceived as error!\n</code></pre> errdefer Example 2 Output<pre><code>Hello!\n7\n8\n5\n6\n3\n4\n1\n2\n</code></pre>"},{"location":"reference/functions/","title":"Functions","text":""},{"location":"reference/functions/#output","title":"Output","text":""},{"location":"reference/functions/#print","title":"print","text":"<p>Description:</p> <p>Prints the given input. Includes a newline after. Stringifies whatever is given to it.</p> <pre><code>print(items ...any?)\n</code></pre> <p>Parameters:</p> <ul> <li><code>items: ...any?</code>: Zero or more items to print. If several are given, they get printed separated by spaces.</li> </ul> <p>Examples:</p> <pre><code>print(\"Hello!\")\n</code></pre> <pre><code>name = \"Alice\"\nprint(\"Hello\", name)  // prints \"Hello Alice\"\n</code></pre> <pre><code>print()  // prints a newline\n</code></pre> <pre><code>numbers = [1, 20, 300]\nprint(numbers)  // prints \"[1, 20, 300]\"\n</code></pre>"},{"location":"reference/functions/#pprint","title":"pprint","text":"<p>Description:</p> <p>Pretty prints the given input. Mainly useful for maps so they get printed in a json-style.</p> <pre><code>pprint(item any?)\n</code></pre> <p>Parameters:</p> <ul> <li><code>input: any?</code>: Zero or one item to pretty print. If zero, just prints a newline.</li> </ul> <p>Examples:</p> Example 1<pre><code>item = { \"name\": \"Alice\", age: 30 }\npprint(item)\n</code></pre> Example 1 Output<pre><code>{\n  \"name\": \"Alice\",\n  \"age\": 30\n}\n</code></pre>"},{"location":"reference/functions/#debug","title":"debug","text":"<p>Behaves like <code>print</code> but only prints if debug is enabled via the <code>--DEBUG</code> flag.</p> <pre><code>debug(items ...any?)\n</code></pre>"},{"location":"reference/functions/#misc","title":"Misc","text":""},{"location":"reference/functions/#exit","title":"exit","text":"<pre><code>exit(code int = 0)\n</code></pre>"},{"location":"reference/functions/#sleep","title":"sleep","text":"<pre><code>sleep(seconds int)\nsleep(seconds float)\nsleep(duration string)\n</code></pre>"},{"location":"reference/functions/#len","title":"len","text":"<pre><code>len(input string) -&gt; int\nlen(input any[]) -&gt; int\nlen(input map) -&gt; int\n</code></pre>"},{"location":"reference/functions/#range","title":"range","text":"<pre><code>range(end int|float) -&gt; int|float[]\nrange(start int|float, end int|float) -&gt; int|float[]\nrange(start int|float, end int|float, step int|float) -&gt; int|float[]\n</code></pre> <pre><code>range(5)         -&gt; [0, 1, 2, 3, 4]\nrange(5.5)       -&gt; [0, 1, 2, 3, 4, 5]\nrange(0.5, 5)    -&gt; [0.5, 1.5, 2.5, 3.5, 4.5]\nrange(10, 5, -2) -&gt; [10, 8, 6]\n</code></pre>"},{"location":"reference/functions/#confirm","title":"confirm","text":"<pre><code>confirm() -&gt; bool\nconfirm(prompt string) -&gt; bool\n</code></pre> Example 1<pre><code>if confirm():\n    print(\"Confirmed!\")\nelse:\n    print(\"Not confirmed!\")\n</code></pre> Example 1 Output<pre><code>Confirm? [y/n] y\nConfirmed!\n</code></pre> Example 2<pre><code>if confirm(\"Are you sure? &gt; \"):\n    print(\"You're sure!\")\nelse:\n    print(\"Unsure!\")\n</code></pre> Example 2 Output<pre><code>Are you sure? &gt; n\nUnsure!\n</code></pre>"},{"location":"reference/functions/#join","title":"join","text":"<pre><code>join(input any[], joiner string, prefix string|int|float|bool?, suffix string|int|float|bool?) -&gt; string\n</code></pre>"},{"location":"reference/functions/#unique","title":"unique","text":"<pre><code>unique(input any[]) -&gt; any[]\n</code></pre> <pre><code>unique([2, 1, 2, 3, 1, 3, 4])  // [2, 1, 3, 4]\n</code></pre>"},{"location":"reference/functions/#sort","title":"sort","text":"<pre><code>sort(input any[], reverse=bool?)\n</code></pre> <pre><code>sort([3, 4, 2, 1])                 // [1, 2, 3, 4]\nsort([3, 4, 2, 1], reversed=true)  // [4, 3, 2, 1]\nsort([3, 4, \"2\", 1, true])         // [true, 1, 3, 4, \"2\"]\n</code></pre>"},{"location":"reference/functions/#parsing","title":"Parsing","text":""},{"location":"reference/functions/#parse_int","title":"parse_int","text":"<pre><code>parse_int(input str) -&gt; int, err\n</code></pre>"},{"location":"reference/functions/#parse_float","title":"parse_float","text":"<pre><code>parse_float(input str) -&gt; float, err\n</code></pre>"},{"location":"reference/functions/#parse_json","title":"parse_json","text":"<pre><code>parse_json(input string) -&gt; any\n</code></pre>"},{"location":"reference/functions/#time","title":"Time","text":""},{"location":"reference/functions/#now_date","title":"now_date","text":"<pre><code>now_date() -&gt; string  // e.g. \"2006-11-25\"\n</code></pre>"},{"location":"reference/functions/#now_year","title":"now_year","text":"<pre><code>now_year() -&gt; int  // e.g. 2006\n</code></pre>"},{"location":"reference/functions/#now_month","title":"now_month","text":"<pre><code>now_month() -&gt; int  // e.g. 11\n</code></pre>"},{"location":"reference/functions/#now_day","title":"now_day","text":"<pre><code>now_day() -&gt; int  // e.g. 25\n</code></pre>"},{"location":"reference/functions/#now_hour","title":"now_hour","text":"<pre><code>now_hour() -&gt; int  // e.g. 14\n</code></pre>"},{"location":"reference/functions/#now_minute","title":"now_minute","text":"<pre><code>now_minute() -&gt; int  // e.g. 31\n</code></pre>"},{"location":"reference/functions/#now_second","title":"now_second","text":"<pre><code>now_second() -&gt; int  // e.g. 35\n</code></pre>"},{"location":"reference/functions/#epoch_seconds","title":"epoch_seconds","text":"<pre><code>epoch_seconds() -&gt; int  // e.g. 1731063226\n</code></pre>"},{"location":"reference/functions/#epoch_millis","title":"epoch_millis","text":"<pre><code>epoch_millis() -&gt; int  // e.g. 1731063226123\n</code></pre>"},{"location":"reference/functions/#epoch_nanos","title":"epoch_nanos","text":"<pre><code>epoch_nanos() -&gt; int  // e.g. 1731063226123456789\n</code></pre>"},{"location":"reference/functions/#text","title":"Text","text":""},{"location":"reference/functions/#upper","title":"upper","text":"<ul> <li>Preserves string color attributes.</li> </ul> <pre><code>upper(input any) -&gt; string\n</code></pre>"},{"location":"reference/functions/#lower","title":"lower","text":"<ul> <li>Preserves string color attributes.</li> </ul> <pre><code>lower(input any) -&gt; string\n</code></pre>"},{"location":"reference/functions/#replace","title":"replace","text":"<ul> <li>Does not preserve string color attributes.</li> </ul> <p>Parameters:</p> <ul> <li><code>input: string</code></li> <li><code>old: string</code>: Regex pattern of what text to replace.</li> <li><code>new: string</code>: Regex pattern of what to replace matches with.</li> </ul> <pre><code>replace(input string, old string, new string) -&gt; string\n</code></pre> <p>Examples:</p> Example 1<pre><code>input = \"Name: Charlie Brown\"\nreplace(input, \"Charlie (.*)\", \"Alice $1\") \n</code></pre> Example 1 Output<pre><code>\"Alice Brown\" \n</code></pre>"},{"location":"reference/functions/#starts_with","title":"starts_with","text":"<pre><code>starts_with(input string, substring string) -&gt; bool\n</code></pre>"},{"location":"reference/functions/#ends_with","title":"ends_with","text":"<pre><code>ends_with(input string, substring string) -&gt; bool\n</code></pre>"},{"location":"reference/functions/#truncate","title":"truncate","text":"<pre><code>truncate(input string, length int) -&gt; string\n</code></pre>"},{"location":"reference/functions/#split","title":"split","text":"<ul> <li>Does not preserve string color attributes.</li> </ul> <pre><code>split(input string, delimiter_regex string) -&gt; string[]\n</code></pre>"},{"location":"reference/functions/#maps","title":"Maps","text":""},{"location":"reference/functions/#keys","title":"keys","text":"<pre><code>keys(input map) -&gt; any[]\n</code></pre>"},{"location":"reference/functions/#values","title":"values","text":"<pre><code>values(input map) -&gt; any[]\n</code></pre>"},{"location":"reference/functions/#random","title":"Random","text":""},{"location":"reference/functions/#rand","title":"rand","text":"<pre><code>rand() -&gt; float\n</code></pre>"},{"location":"reference/functions/#rand_int","title":"rand_int","text":"<pre><code>rand_int(max int) -&gt; int\nrand_int(min int, max int) -&gt; int\n</code></pre>"},{"location":"reference/functions/#seed_random","title":"seed_random","text":"<pre><code>seed_random(seed int)\n</code></pre>"},{"location":"reference/functions/#picking","title":"Picking","text":""},{"location":"reference/functions/#pick","title":"pick","text":"<pre><code>pick(options string[], filter string?) -&gt; string\n</code></pre> <p>Named args: - <code>prompt</code></p>"},{"location":"reference/functions/#pick_kv","title":"pick_kv","text":"<pre><code>pick_kv(keys string[], values string[], filter string?) -&gt; string\n</code></pre> <p>Named args: - <code>prompt</code></p>"},{"location":"reference/functions/#pick_from_resource","title":"pick_from_resource","text":"<pre><code>pick_from_resource(resource_path string, filter string?) -&gt; any...\n</code></pre>"},{"location":"reference/functions/#http","title":"HTTP","text":"<p>Map outputs contain the following keys: - <code>status_code</code> - <code>body</code></p> <p>Failed queries (e.g. invalid url, no response) will result in an error and script exit.</p>"},{"location":"reference/functions/#http_get","title":"http_get","text":"<pre><code>http_get(url string) -&gt; map\nhttp_get(url string, headers = map) -&gt; map\n</code></pre>"},{"location":"reference/functions/#http_post","title":"http_post","text":"<pre><code>http_post(url string, body any?) -&gt; map\nhttp_post(url string, body any?, headers = map) -&gt; map\n</code></pre>"},{"location":"reference/functions/#http_put","title":"http_put","text":"<pre><code>http_put(url string, body any?) -&gt; map\nhttp_put(url string, body any?, headers = map) -&gt; map\n</code></pre>"},{"location":"reference/functions/#math","title":"Math","text":""},{"location":"reference/functions/#abs","title":"abs","text":"<pre><code>abs(int) -&gt; int\nabs(float) -&gt; float\n</code></pre>"},{"location":"reference/global-flags/","title":"Global Flags","text":"<p>WIP</p>"},{"location":"reference/json-field-definition/","title":"Json Field Definition","text":"<p>TODO perhaps reframe as general 'json extraction logic' reference?</p>"},{"location":"reference/logic/","title":"Boolean Logic","text":""},{"location":"reference/logic/#truthy-falsy","title":"Truthy / Falsy","text":"<p>RSL supports truthy/falsy logic.</p> <p>For those unfamiliar, this means that, instead of writing the following (as an example):</p> <pre><code>if len(my_list) &gt; 0:\n    print(\"My list has elements!\")\n</code></pre> <p>you can write</p> <pre><code>if my_list:\n    print(\"My list has elements!\")\n</code></pre> <p>Essentially, you can use any type as a condition, and it will resolve to true or false depending on the value.</p> <p>The following table shows which values return false for each type. All other values resolve to true.</p> Type Falsy Description string <code>\"\"</code> Empty strings int <code>0</code> Zero float <code>0.0</code> Zero list <code>[]</code> Empty lists map <code>{}</code> Empty maps <p>Note that a string which is all whitespace e.g. <code>\" \"</code> is truthy.</p>"},{"location":"reference/math/","title":"Math","text":""},{"location":"reference/math/#modulo","title":"Modulo","text":"<p>RSL has a modulo operator. It can be used to get the remainder after performing integer division.</p> <pre><code>print(5 % 3)\n</code></pre> <pre><code>2\n</code></pre> <p>This also works for floats, or mixes between floats and ints.</p> <pre><code>print(5.6 % 4.1)\nprint(5 % 4.5)\n</code></pre> <pre><code>1.5\n0.5\n</code></pre> <p>Negative numbers is a somewhat complex topic, and different languages handle them differently. Here is a brief overview:</p> -11 % 7 = Approach Result takes sign of... Example Languages -4 Truncated Division Numerator (dividend) RSL, C/C++, Java, JavaScript, Go, Rust, Swift, C# 3 Floored Division Denominator (divisor) Python, Ruby, R <p>Notice RSL behaves differently from Python, and instead follows the behavior of most other major languages.</p>"},{"location":"reference/rad-blocks/","title":"Rad Blocks","text":""},{"location":"reference/rad-blocks/#rad-block","title":"<code>rad</code> block","text":"<pre><code>rad url:\n    fields Name, Birthdate, Height\n    Name:\n        map n -&gt; truncate(n, 20)\n    if sort_by_height:\n        sort Height, Name, Birthdate\n    else:\n        sort\n</code></pre>"},{"location":"reference/rad-blocks/#request-block","title":"<code>request</code> block","text":"<pre><code>request url:\n    fields Name, Birthdate, Height\n</code></pre>"},{"location":"reference/rad-blocks/#display-block","title":"<code>display</code> block","text":"<pre><code>display:\n    fields Name, Birthdate, Height\n</code></pre>"},{"location":"reference/rad-blocks/#colors","title":"Colors","text":"<p>Valid colors:</p> <p><code>plain, black, red, green, yellow, blue, magenta, cyan, white, orange, pink</code></p>"},{"location":"reference/shell-commands/","title":"Shell Commands","text":""},{"location":"reference/shell-commands/#basic-shell-commands","title":"Basic Shell Commands","text":"<pre><code>$`ls -l`\nfail:\n    print(\"Command failed! Exiting script!\")\n</code></pre> <pre><code>$`ls -l`\nrecover:\n    print(\"Command failed! Continuing script...\")\n</code></pre>"},{"location":"reference/shell-commands/#critical-shell-commands","title":"Critical Shell Commands","text":"<pre><code>$!`ls -l`\n</code></pre>"},{"location":"reference/shell-commands/#unsafe-shell-commands","title":"Unsafe Shell Commands","text":"<pre><code>unsafe $`ls -l`\n</code></pre>"},{"location":"reference/shell-commands/#output-capture","title":"Output Capture","text":"<pre><code>err_code = $!`ls -l`\nerr_code, stdout = $!`ls -l`\nerr_code, stdout, stderr = $!`ls -l`\n</code></pre>"},{"location":"reference/shell-commands/#suppress-announcements","title":"Suppress Announcements","text":"<p>By default, Rad will 'announce' (i.e. print) commands as they're executed. Example:</p> Without quiet<pre><code>$!`ls`\n$!`echo hello`\n</code></pre> Without quiet output<pre><code>\u26a1\ufe0f Running: ls\npick.rsl  simple.rsl  sorting.rsl\n\u26a1\ufe0f Running: echo hello\nhello\n</code></pre> <p>These announcements can be suppressed with the <code>quiet</code> keyword. It does not impact stdout/stderr output for the command.</p> With quiet<pre><code>quiet $!`ls`\nquiet $!`echo hello`\n</code></pre> With quiet output<pre><code>pick.rsl  simple.rsl  sorting.rsl\nhello\n</code></pre>"},{"location":"reference/strings/","title":"Strings","text":"<p>RSL has three delimiters for strings:</p> <pre><code>\"double quotes\"\n'single quotes'\n`backticks`\n</code></pre> <p>All three of these behave the same way. RSL offers three so you have alternatives to pick between depending on the contents of your string. For example, if you have a string which itself contains lots of single quotes, you may choose to use the double quotes delimiter. Or, if your string has both single and double quotes, you can use backticks to delimit your string. Specific example:</p> <pre><code>`Single quotes: 'Hi!', double quotes: \"Hi!\"`\n</code></pre>"},{"location":"reference/strings/#string-attributes","title":"String Attributes","text":"<ul> <li>Not all strings are just plain text. They may have attributes such as color.</li> <li>This means that RSL contains logic on how to handle attributes when strings are combined or operated on<ul> <li>e.g. concatenation, slicing, replace functions, etc</li> </ul> </li> <li>The following operations maintain color attributes:<ul> <li>concatenation</li> <li>index lookup</li> </ul> </li> <li>The following do not, and just return a plain string:<ul> <li>slicing (to be added)</li> <li>functions: <code>replace</code>, <code>split</code></li> </ul> </li> <li>Attributes do not impact things like equality or comparing strings.<ul> <li>A green string \"Alice\" and a yellow string \"Alice\" will be considered 'equal'.</li> </ul> </li> </ul>"},{"location":"reference/strings/#string-interpolation","title":"String Interpolation","text":""},{"location":"reference/strings/#formatting","title":"Formatting","text":"<ul> <li>Float formatting does not require a <code>f</code> at the end.<ul> <li>Correct: <code>{myFloat:.2}</code></li> <li>Incorrect: <code>{myFloat:.2f}</code></li> </ul> </li> </ul> <p>Examples:</p> <pre><code>\"{myString:20}\"\n\"{myString:&lt;20}\"\n\"{myString:&gt;20}\"\n\"{myFloat:.2}\"\n</code></pre>"},{"location":"reference/strings/#escaping","title":"Escaping","text":"<ul> <li><code>\\</code> will escape:</li> <li><code>{</code> (to prevent string interpolation)</li> <li><code>\\n</code> new line</li> <li><code>\\t</code> tab</li> <li><code>\\</code> i.e. itself, so you can write backslashes</li> <li>The respective string delimiter itself, so <code>\\\"</code>, <code>\\'</code>, or <code>\\`</code>, depending on the delimiter you're using.<ul> <li>However, it's advised you use delimiters that don't clash with the contents of your string, if possible.</li> </ul> </li> </ul>"},{"location":"reference/strings/#raw-strings","title":"Raw Strings","text":"<p>Raw strings can be used when you want RSL to treat the string as it's written, rather than performing escaping, interpolation, etc.</p> <p>Raw strings are created by prefixing an <code>r</code> to the opening delimiter of your string. For example:</p> <pre><code>name = \"alice\"\ntext = r\"Regards,\\n{name}\"\nprint(text)\n</code></pre> <pre><code>Regards,\\n{name}\n</code></pre> <p>Notice RSL did not render the <code>\\n</code> as a newline as it would in a regular string, and that <code>{name}</code> is also left as-is i.e. no interpolation was performed.</p> <p>Unlike Python, you cannot escape anything in raw strings, including the delimiter. For example:</p> <pre><code>r\"\\\"\"\n</code></pre> <p>is illegal because the backslash does not escape the following <code>\"</code>, and so that quote actually ends the raw string. Then we're left with a third and dangling <code>\"</code> at the end, causing a syntax error.</p>"}]}